<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kenny 肉桂的主页</title>
  <meta name="author" content="桂庆">
  
  <meta name="description" content="Kenny 肉桂的主页 记录自己的进步">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Kenny 肉桂的主页"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kenny 肉桂的主页" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Kenny 肉桂的主页</a></h1>
  <h2><a href="/">记录自己的进步</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-26T02:14:06.000Z"><a href="/2016/09/26/研究随笔/Protocolkit中宏的用法分析/">2016-09-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/26/研究随笔/Protocolkit中宏的用法分析/">ProtocolKit中宏的用法分析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>宏本身不难理解,但是往往嵌套多了,或者利用一些不常用的特性之后,会让人觉得迷惑.</p>
<h2 id="ProtocolKit中的一段宏定义">ProtocolKit中的一段宏定义</h2><p>在<code>ProtocolKit</code>中有这么一段宏的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Get container class name by counter&#10;#define _pk_get_container_class($protocol) _pk_get_container_class_imp($protocol, __COUNTER__)&#10;#define _pk_get_container_class_imp($protocol, $counter) _pk_get_container_class_imp_concat(__PKContainer_, $protocol, $counter)&#10;#define _pk_get_container_class_imp_concat($a, $b, $c) $a ## $b ## _ ## $c</span><br></pre></td></tr></table></figure>
<p>当时知道:</p>
<p><code>##</code> 连字符,通常用来拼接</p>
<p><code>__COUNTER__</code>  计数器,一般用来后缀在变量上面,保证变量的唯一性.在程序中,每使用一次,这个数字就<code>+1</code>,默认是<code>0</code></p>
<p>再看实际拼接的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_pk_get_container_class(MyProtocol);&#10;//&#30456;&#24403;&#20110;&#10;__PKContainer_MyProtocol_0;</span><br></pre></td></tr></table></figure>
<p>一开始的时候在想, 不就是要拼接么,为何要弄那么多层嵌套.难道是故意增加复杂度,让人觉得高深? 还有变量前面的<code>$</code>,是和shell中的一个意思? 表示变量?</p>
<h2 id="尝试简化">尝试简化</h2><p>遇到看不懂的东西,我喜欢先去掉,把自己知道的代码罗列出来.然后依次加上不懂得东西,看它对既有结果的改变.然后判断它的作用.<br>于是,我写了下面一个宏:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define _kn_get_container_class(prefix,protocol) prefix##_##protocol##_##__COUNTER__</span><br></pre></td></tr></table></figure>
<p>然后使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *  _kn_get_container_class(__kn,MyProtocol);</span><br></pre></td></tr></table></figure></p>
<p>可是根据编译器的警告来看,并不是我想要的结果:</p>
<p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/20160926147485714436151.jpg?imageView2/0/format/jpg" alt="20160926147485714436151.jpg"></p>
<p>原来在<code>##</code>的作用下,<code>__COUNTER__</code>被当成了字面上的表示,并没有解析.<br>然后,根据作者的写法,把实现加深一层,改写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define _simpleifyGetContainerClass(prefix,protocol,counter) _simple_getContainerClass_imp(prefix,protocol,counter)&#10;#define _simple_getContainerClass_imp(a,b,c) a##b##_##c</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString * _simpleifyGetContainerClass(__PKContainer_,MyProtocol,__COUNTER__);</span><br></pre></td></tr></table></figure>
<p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/2016092614748581939059.jpg?imageView2/0/format/jpg" alt="2016092614748581939059.jpg"></p>
<p>发现结果正确.</p>
<p>我这种写法,需要使用者传递多个参数,也已经必须嵌套一层了.作者在此基础上加上默认的参数实现,也是很合理的.</p>
<p>另外可以看到,这个<code>$</code>符号,不加也可以,所以,个人猜想.这个和shell中<code>使用变量</code>不是一回事.可能加上仅仅为了阅读者明白,这个地方是个变量.若理解不正确,请您指正.</p>
<h2 id="GCC中一个可变参数的宏">GCC中一个可变参数的宏</h2><p>之前项目中,封装过打印.当时就用到了可变参数的宏:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;#define GUIError(message,...) DDLogError(@&#34;\n[   FILE  ]  %s \n[  METHOD ]  %s\n[   LINE  ] %d \n[ Message ]\n%@\n\n=======================================================\n&#34;,__FILE__,__FUNCTION__,__LINE__,[NSString stringWithFormat:message,## __VA_ARGS__])</span><br></pre></td></tr></table></figure>
<p>就是在定义的时候,以<code>...</code>作为最后一个参数,使用的时候,<code>__VA_ARGS__</code>就代指这一系列可变参数.</p>
<p>今天想找找关于宏的资料,发现GCC的文档中,也有关于可变参数宏的说明.在此,就不赘述了,想深入了解的,可以<a href="https://gcc.gnu.org/onlinedocs/gcc-6.2.0/gcc/Variadic-Macros.html#Variadic-Macros" target="_blank" rel="external">查看文档</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-25T11:54:37.000Z"><a href="/2016/09/25/研究随笔/attribute-constructor-用法探究/">2016-09-25</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/25/研究随笔/attribute-constructor-用法探究/">__attribute__((constructor))用法探究</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天在看ProtocolKit的源码,看到了这么一行代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) static void _pk_extension_inject_entry(void) &#123;</span><br></pre></td></tr></table></figure>
<p>主要造成疑惑的是 <code>__attribute__((constructor))</code>,以前看过关于<code>__attribute__</code>这个关键字的,大概还记得就是可以修饰类型,函数什么的.类似一个编译标记.但是具体用法忘记了.</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/09/25/研究随笔/attribute-constructor-用法探究/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-24T02:49:05.000Z"><a href="/2016/09/24/iOS Tips/GCD实现线程同步的三种方式/">2016-09-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/24/iOS Tips/GCD实现线程同步的三种方式/">GCD实现线程同步的三种方式</a></h1>
  

    </header>
    <div class="entry">
      
        <p>写这篇文章的原因是自己几天前的一个面试,当时面试官问这个线程同步的问题,感觉自己回答的不好,知识接触过,却不系统条理.所以这次特地整理一下</p>
<h2 id="什么是线程同步">什么是线程同步</h2><p>同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。<br>“同”字从字面上容易理解为一起动作<br>其实不是，“同”字应是指协同、协助、互相配合。<br>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。</p>
<p><strong>以上内容来自百度百科</strong></p>
<h2 id="GCD中实现线程同步的方式">GCD中实现线程同步的方式</h2><h3 id="dispatch_group">dispatch_group</h3><p><code>dispatch_group</code>是GCD中经常使用的线程同步方式,具体用法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&#34;cc.imguiqing&#34;, DISPATCH_QUEUE_CONCURRENT);&#10;dispatch_group_t group = dispatch_group_create();&#10;dispatch_group_async(group, queue, ^&#123;&#10;    NSLog(@&#34;task 1 on %@&#34;,[NSThread currentThread]);&#10;&#125;);&#10;&#10;dispatch_group_async(group, queue, ^&#123;&#10;    NSLog(@&#34;task 2 on %@&#34;,[NSThread currentThread]);&#10;&#125;);&#10;&#10;dispatch_group_async(group, queue, ^&#123;&#10;    NSLog(@&#34;task 3 on %@&#34;,[NSThread currentThread]);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看出,这个和普通的GCD任务相比,每个API都多了一个group参数.但是如果仅仅是像上面的方式使用,就没有什么必要了.我们使用Group的原因,更多是想要知道这个Group中的执行情况.借此来获得时机做一些逻辑操作.所以<code>dispatch_group</code>提供了两个API:</p>
<ol>
<li>通知Group中的任务都执行完毕</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;dispatch_group_notify(group, queue, ^&#123;&#10;    NSLog(@&#34;all task done&#34;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>阻塞式的等待Group中的任务都执行完毕</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);&#10;NSLog(@&#34;since all done , I move on&#34;);</span><br></pre></td></tr></table></figure>
<h4 id="更常见的写法">更常见的写法</h4><p>上面的写法虽然简单,但是如果看过一些三方库的代码,发现那么用的并不多.更多的是利用<code>dispatch_group_enter(group)</code>和<code>dispatch_group_leave(group)</code>来包装任务,本质上两者没有区别,多说这些仅仅是让你别以后看代码的时候感到疑惑,<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue( 0, 0 );&#10;dispatch_group_t group = dispatch_group_create();&#10;&#10;dispatch_group_enter(group);&#10;dispatch_async( queue, ^&#123;&#10;    NSLog( @&#34;task 1 --- %@&#34;, [NSThread currentThread] );&#10;    dispatch_group_leave(group);&#10;&#125; );&#10;dispatch_group_enter(group);&#10;dispatch_async( queue, ^&#123;&#10;    NSLog( @&#34;task 2 --- %@&#34;, [NSThread currentThread] );&#10;    dispatch_group_leave(group);&#10;&#125; );&#10;dispatch_group_notify( group, queue, ^&#123;&#10;    NSLog( @&#34;all task done %@&#34;, [NSThread currentThread] );&#10;&#125; );</span><br></pre></td></tr></table></figure>
<h3 id="信号量">信号量</h3><p>信号量可以理解为一个特殊的变量.程序对它的访问都是原子性的,我们通过PV操作来修改信号量.<br>使用代码简单说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t sem = &#9;dispatch_semaphore_create(0);&#10;[networkManager requestWithDelay:5 completion:^&#123;&#10;    dispatch_semaphore_signal(sem);//+1&#10;&#125;];&#10;dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);//-1&#10;NSLog(@&#34;five sectonds&#34;);</span><br></pre></td></tr></table></figure>
<p>信号量创建的时候, 可以给他指定一个值.<code>dispatch_semaphore_signal(sem)</code>对信号进行<code>+1</code>操作.<code>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)</code>对信号进行<code>-1</code>操作.当进行<code>-1</code>时,如果发现信号结果会小于0,那么线程进入阻塞状态.只有当信号<code>&gt;=0</code>才能通过.</p>
<p>那么上面的代码段就容易明白了: 一直等到一个异步的网络请求结束,才继续执行<code>NSLog(@&quot;five sectonds&quot;);</code>,也是就其他的逻辑</p>
<h3 id="Barrier">Barrier</h3><p>相比上面两种方式,Barrier知道的人相对少一些.但是Barrier用起来相对上面两种更加简单.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&#34;cc.imguiqing&#34;, DISPATCH_QUEUE_CONCURRENT);&#10;dispatch_async(queue, ^&#123;&#10;    NSLog(@&#34;task 1 on %@&#34;,[NSThread currentThread]);&#10;&#125;);&#10;dispatch_async(queue, ^&#123;&#10;    NSLog(@&#34;task 2 on %@&#34;,[NSThread currentThread]);&#10;&#125;);&#10;dispatch_barrier_async(queue, ^&#123;&#10;    NSLog(@&#34;barrier ==========&#34;);&#10;&#125;);&#10;dispatch_async(queue, ^&#123;&#10;    NSLog(@&#34;task 3 on %@&#34;,[NSThread currentThread]);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码,<code>task 1</code>和<code>task 2</code>会并发执行,然后执行<code>barrier</code>,最后是<code>task 3</code>,用图来说明:<br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/20160924147468717647516.jpg?imageView2/0/format/jpg" alt="20160924147468717647516.jpg"></p>
<p>这个 barrier就相当于一个栅栏,将不同的任务区分开来.从代码中也不难看出,这个barrier函数不需要依赖其它的变量,没有侵入性.所以非常好用.和Group也是非常好搭配.例如下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&#34;cc.imguiqing&#34;, DISPATCH_QUEUE_CONCURRENT);&#10;dispatch_group_t group = dispatch_group_create();&#10;dispatch_group_async(group, queue, ^&#123;&#10;    for (int i = 0 ; i &#60; 500000000; i++) &#123;&#10;    &#125;&#10;    NSLog(@&#34;task 1 on %@&#34;,[NSThread currentThread]);&#10;&#125;);&#10;dispatch_barrier_async(queue, ^&#123;&#10;    NSLog(@&#34;======&#34;);&#10;&#125;);&#10;dispatch_group_async(group, queue, ^&#123;&#10;    for (int i = 0 ; i &#60; 500000000; i++) &#123;&#10;    &#125;&#10;    NSLog(@&#34;task 2 on %@&#34;,[NSThread currentThread]);&#10;&#125;);&#10;dispatch_barrier_async(queue, ^&#123;&#10;    NSLog(@&#34;======&#34;);&#10;&#125;);&#10;dispatch_group_async(group, queue, ^&#123;&#10;    NSLog(@&#34;task 3 on %@&#34;,[NSThread currentThread]);&#10;&#125;);&#10;dispatch_group_notify(group, queue, ^&#123;&#10;    NSLog(@&#34;all task done&#34;);&#10;&#125;);&#10;dispatch_group_wait(group, DISPATCH_TIME_FOREVER);&#10;NSLog(@&#34;since all done , I move on&#34;);</span><br></pre></td></tr></table></figure>
<p>能保证 <code>task 1 2 3</code>顺序执行,同时,由于使用了Group,也能知道执行结束的时机. 但是仅仅是为了说明问题,如果要顺序执行,那么还是使用GCD中同步队列更加合适.</p>
<p><strong>注意点: 这个barrier函数只能用于并发队列,且不能是<code>global queue</code>.</strong></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-23T06:48:47.000Z"><a href="/2016/09/23/Xcode&环境配置/Xcode-8-必要配置/">2016-09-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/23/Xcode&环境配置/Xcode-8-必要配置/">Xcode 8 适配</a></h1>
  

    </header>
    <div class="entry">
      
        <p>相信很多小伙伴都升级了Xcode 8 ,但是发现很多恶心的地方.下面是自己这几天的积累,解决了一部分问题.希望能帮到大家.</p>
<h2 id="注释快捷键失效">注释快捷键失效</h2><p>我们常用的<code>cmd+/</code>失效了了.</p>
<h2 id="解决方案">解决方案</h2><p>终端输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/libexec/xpccachectl</span><br></pre></td></tr></table></figure></p>
<p>然后重启mac</p>
<h2 id="去掉多余打印">去掉多余打印</h2><p>当你开开心心的想去控制台看Log的时候,发现这样:<br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/2016092374983截图 2016-09-23 14时52分35秒.jpg" alt="2016092374983截图 2016-09-23 14时52分35秒.jpg"></p>
<h2 id="解决方法">解决方法</h2><p>到<code>Target</code>中添加如下键值对:<br><code>OS_ACTIVITY_MODE disable</code><br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/20160923147461373922375.jpg?imageView2/0/format/jpg" alt="20160923147461373922375.jpg"></p>
<h2 id="插件失效">插件失效</h2><p>每次升级,都会面临插件失效的情况. 以前比较简单的可以通过修改插件plist的方法来完成修复.<br>1.打开终端，输入以下代码获取到<code>DVTPlugInCompatibilityUUID</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</span><br></pre></td></tr></table></figure></p>
<p>2.然后输入如下命令 【最后一项是获取到的DVTPlugInCompatibilityUUID】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add 9F75337B-21B4-4ADC-B558-F9CADF7073A7</span><br></pre></td></tr></table></figure></p>
<p><a href="http://blog.csdn.net/u014536527/article/details/45022747" target="_blank" rel="external">来源网址</a><br>但是Xcode 8 却不行了,甚至明确说支持Xcode8的插件也不正常工作.这是因为Xcode8要求<code>code sign</code></p>
<h2 id="解决方法-1">解决方法</h2><p>因为我一直很依赖<code>xvim</code>这个插件,所以一直关注等着更新.今天意外发现有个适配Xcode8的说明:</p>
<p>1.打开<code>Keychain Access</code>,在左边栏中选择<code>login</code>这个条目<br>2.选择<code>Create a Certificate</code><br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/20160923147461457298237.jpg?imageView2/0/format/jpg" alt="20160923147461457298237.jpg"><br>3.输入名字,然后选择<code>Code Signing</code>这个类型<br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/20160923147461461158577.jpg?imageView2/0/format/jpg" alt="20160923147461461158577.jpg"><br>4.退出Xode,然后终端中输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo codesign -f -s XcodeSigner /Applications/Xcode.app</span><br></pre></td></tr></table></figure></p>
<p>具体Xcode路径看自己放哪.<br>5.然后可以依靠旧的方法去使用,或者去获取最新版本.</p>
<p><a href="https://github.com/XVimProject/XVim/blob/master/INSTALL_Xcode8.md" target="_blank" rel="external">来源网址</a></p>
<h2 id="切换Swift版本">切换Swift版本</h2><p>目前Xcode8中支持Swift3.0 ,但是不幸的是,很多三方库还不支持. 我们可以通过配置,切换为Swift的2.3版本.</p>
<h2 id="修改配置">修改配置</h2><p>配置如下图,设置为NO表示使用 Swift 3.0. YES表示使用Swift2.3<br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/20160923147461514664286.jpg?imageView2/0/format/jpg" alt="20160923147461514664286.jpg"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-18T06:19:06.000Z"><a href="/2016/08/18/环境、配置相关/一份自己满意的ClangFormat配置/">2016-08-18</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/18/环境、配置相关/一份自己满意的ClangFormat配置/">一份自己满意的ClangFormat配置</a></h1>
  

    </header>
    <div class="entry">
      
        <p>对于一个团队来说,有共同的代码格式规范是非常重要的.但是,却不能保证每个细节,使用代码格式化工具可以极大的提高效率.下面是自己积累出来的一份配置,每一行都有注释,可以自己比对:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#22522;&#20110;&#37027;&#20010;&#37197;&#32622;&#25991;&#20214;&#10;BasedOnStyle: LLVM&#10;#&#25351;&#38024;&#30340;*&#30340;&#25384;&#30528;&#21738;&#36793;&#10;PointerAlignment: Right&#10;#&#32553;&#36827;&#23485;&#24230;&#10;IndentWidth: 4&#10;# &#36830;&#32493;&#30340;&#31354;&#34892;&#20445;&#30041;&#20960;&#34892;&#10;MaxEmptyLinesToKeep: 1&#10;# &#22312; @property &#21518;&#38754;&#28155;&#21152;&#31354;&#26684;, \@property (readonly) &#32780;&#19981;&#26159; \@property(readonly).&#10;ObjCSpaceAfterProperty: true&#10;# OC block&#21518;&#38754;&#30340;&#32553;&#36827;&#10;ObjCBlockIndentWidth: 4&#10;# &#26159;&#21542;&#20801;&#35768;&#30701;&#26041;&#27861;&#21333;&#34892;&#10;AllowShortFunctionsOnASingleLine: true&#10;# &#26159;&#21542;&#20801;&#35768;&#30701;if&#21333;&#34892; If true, if (a) return; &#21487;&#20197;&#25918;&#21040;&#21516;&#19968;&#34892;&#10;AllowShortIfStatementsOnASingleLine: true&#10;#&#27880;&#37322;&#23545;&#40784;&#10;AlignTrailingComments: true&#10;# &#25442;&#34892;&#30340;&#26102;&#20505;&#23545;&#40784;&#25805;&#20316;&#31526;&#10;#AlignOperands: true&#10;# &#20013;&#25324;&#21495;&#20004;&#36793;&#31354;&#26684; [] &#10;SpacesInSquareBrackets: true&#10;# &#23567;&#25324;&#21495;&#20004;&#36793;&#28155;&#21152;&#31354;&#26684;&#10;SpacesInParentheses : true&#10;#&#22810;&#34892;&#22768;&#26126;&#35821;&#21477;&#25353;&#29031;=&#23545;&#40784;&#10;AlignConsecutiveDeclarations: true&#10;#&#36830;&#32493;&#30340;&#36171;&#20540;&#35821;&#21477;&#20197; = &#20026;&#20013;&#24515;&#23545;&#40784;&#10;AlignConsecutiveAssignments: true&#10;#&#31561;&#21495;&#20004;&#36793;&#30340;&#31354;&#26684;&#10;SpaceBeforeAssignmentOperators: true&#10;# &#23481;&#22120;&#31867;&#30340;&#31354;&#26684; &#20363;&#22914; OC&#30340;&#23383;&#20856;&#10;SpacesInContainerLiterals: true&#10;#&#32553;&#36827;&#10;IndentWrappedFunctionNames: true&#10;#&#22312;block&#20174;&#31354;&#34892;&#24320;&#22987;&#10;KeepEmptyLinesAtTheStartOfBlocks: true&#10;#&#22312;&#26500;&#36896;&#20989;&#25968;&#21021;&#22987;&#21270;&#26102;&#25353;&#36887;&#21495;&#26029;&#34892;&#65292;&#24182;&#20197;&#20882;&#21495;&#23545;&#40784;&#10;BreakConstructorInitializersBeforeComma: true&#10;#&#20989;&#25968;&#21442;&#25968;&#25442;&#34892;&#10;AllowAllParametersOfDeclarationOnNextLine: true&#10;#&#25324;&#21495;&#21518;&#28155;&#21152;&#31354;&#26684;&#10;SpaceAfterCStyleCast: true&#10;#tab&#38190;&#30424;&#30340;&#23485;&#24230;&#10;TabWidth: 4&#10;UseTab: Never</span><br></pre></td></tr></table></figure></p>
<h2 id="使用方法">使用方法</h2><ol>
<li>安装Clang-Format Xcode插件, <a href="https://github.com/travisjeffery/ClangFormat-Xcode" target="_blank" rel="external">地址</a></li>
<li>在用户根目录下创建 <code>.clang-format</code>文件,将上面配置拷贝进去</li>
<li>在Xocde中的选中以下菜单即可:<br>  <img src="http://7xv9rf.com1.z0.glb.clouddn.com/82417QQ20160818-1@2x.png" alt="82417QQ20160818-1@2x.png"></li>
<li>可以设置在保存文件的时候自动格式化,也可以自己配置<br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/67391QQ20160818-2@2x.png" alt="67391QQ20160818-2@2x.png"></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-03T09:05:25.000Z"><a href="/2016/08/03/其他技术/Vim实践Tips-六/">2016-08-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/03/其他技术/Vim实践Tips-六/">Vim实践Tips(六)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_27_遇见Vim的命令行">Tip 27 遇见Vim的命令行</h2><p>当我们按下<code>:</code>,Vim就切换到了底行模式.这个模式和shell的命令行有些类似.我们只要输入点命令,然后按下<code>&lt;CR&gt;</code>就能执行.使用<code>&lt;Esc&gt;</code>可以从底行模式切换到命令行模式.</p>
<p>由于一些历史原因,我们执行的命令叫做 <code>Ex Commands</code> .当我们按下<code>/</code>之后,或者使用<code>&lt;C-r&gt;=</code>访问表达式寄存器的时候,也都会进入底行模式.这章中提到的一些小技巧也都适用于不同的情况,但是在这个章节,我们先讨论<code>Ex commands</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  &#21629;&#20196;                     &#25928;&#26524;&#10;:[range]delete[x]          &#21024;&#38500;&#29305;&#23450;&#30340;&#34892;(&#25918;&#21040;&#23492;&#23384;&#22120;x&#20013;)&#10;:[range]yank[x]            &#22797;&#21046;&#29305;&#23450;&#30340;&#34892;(&#25918;&#21040;&#23492;&#23384;&#22120;x&#20013;)&#10;:[line]put[x]              &#25226;&#23492;&#23384;&#22120;x&#20013;&#30340;&#20869;&#23481;&#25918;&#21040;&#29305;&#23450;&#30340;&#34892;&#21518;&#38754;&#10;:[range]copy&#123;address&#125;      &#22797;&#21046;&#29305;&#23450;&#30340;&#34892;&#21040;&#36890;&#36807;&#22320;&#22336;&#25351;&#23450;&#30340;&#34892;&#30340;&#19979;&#38754;&#10;:[range]move&#123;address&#125;      &#31227;&#21160;&#29305;&#23450;&#30340;&#34892;&#21040;&#36890;&#36807;&#22320;&#22336;&#25351;&#23450;&#30340;&#34892;&#30340;&#19979;&#38754;&#10;:[range]join               &#36830;&#25509;&#25351;&#23450;&#30340;&#34892;&#10;:[range]normal &#123;commands&#125;  &#23545;&#29305;&#23450;&#30340;&#33539;&#22260;&#25191;&#34892;&#21629;&#20196;&#27169;&#24335;&#19979;&#30340;&#21629;&#20196;&#10;:[range]substitute/&#123;pattern&#125;&#10;/&#123;string&#125;/&#123;flags&#125;&#10;                           &#22312;&#29305;&#23450;&#30340;&#34892;&#37324;&#38754;,&#25226;&#31526;&#21512;&#26465;&#20214;&#30340;&#21305;&#37197;&#20351;&#29992;&#23383;&#31526;&#20018;&#26367;&#25442;&#25481;.&#10;:[range]global/&#123;pattern&#125;/[cmd] &#22312;&#25152;&#26377;&#21305;&#37197;&#21040;pattern&#30340;&#34892;&#20013;,&#25191;&#34892;Ex&#21629;&#20196;</span><br></pre></td></tr></table></figure>
<p>我们可以Ex命令读写文件(<code>:read</code>和<code>:write</code>),或者使用<code>:tabnew</code>命令创建Tab页,或者使用<code>:split</code>命令创建窗口.</p>
<h2 id="Tip_28_在一到多个连续行中执行命令">Tip 28 在一到多个连续行中执行命令</h2><p>许多Ex命令都可以接受一个{range},我们可以通过行号,标记,或者是一个Pattern来提供范围.<br>假设有下面一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;html&#62;&#10;  &#60;head&#62;&#60;title&#62;Practical Vim&#60;/title&#62;&#60;/head&#62;&#10;  &#60;body&#62;&#60;h1&#62;Practical Vim&#60;/h1&#62;&#60;/body&#62;&#10;&#60;/html&#62;</span><br></pre></td></tr></table></figure></p>
<p>为了说明,我们使用<code>:print</code>命令,这个命令可以简单的通过这个命令将特定的行打印到Vim的底行之下.<br>这个命令没有什么特定的功能.但是可以用来做说明.当然,你也可以通过<code>:delete</code>,<code>:join</code>,<code>:substitude</code>,<code>:normal</code>这几个命令来测试.通过测试,你就可以知道怎么使用Ex命令了.</p>
<h3 id="使用行号作为地址">使用行号作为地址</h3><p>如果我们输入一个仅由数字组成的Ex命令.Vim就会把这个命令当做地址,然后将光标移动到那一行.所以,我们就能通过下面的这个命令跳转到文件顶部:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1&#10;:print</span><br></pre></td></tr></table></figure></p>
<p>你也可以使用<code>:p</code>来打印,这个是<code>:print</code>的缩写形式.你也可以将两个命令合并到一起.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3p</span><br></pre></td></tr></table></figure></p>
<p>这个命令移动到第3行,然后打印该行的内容.我们只是通过<code>:p</code>命令来说明问题,下面你可以试试这个命令.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3d</span><br></pre></td></tr></table></figure></p>
<p>这个命令跳转到第3行,然后执行删除命令.它相当于在命令模式下执行:<code>3Gdd</code>.这个命令比命令行模式下的要快点.</p>
<h3 id="通过地址指定一个范围">通过地址指定一个范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:2,5p</span><br></pre></td></tr></table></figure>
<p>这个命令可以打印从第2行到第5行,并且最后光标停留在第5行.通常来说,范围可以表现为这个形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#123;start&#125;,&#123;end&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意,这个<code>start</code>和<code>end</code>都是地址,目前我们知道的地址是行号.在后面的我们将见到通过匹配和标记指定的地址.</p>
<p><code>.</code>可以用来表达为当前行,所以,我们可以通过下面的命令打印从当前行到文件末尾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:2&#10;:.,$p</span><br></pre></td></tr></table></figure></p>
<p><code>%</code>这个符号也有特别的意义,它代表了当前文件中的所有行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%p</span><br></pre></td></tr></table></figure></p>
<p>它相当于<code>:1,$p</code>这个命令.</p>
<h3 id="通过在可视化模式下的选择指定范围">通过在可视化模式下的选择指定范围</h3><p>首先通过命令<code>2G</code>跳转到第2行,然后<code>VG</code>可以选择从2行到文件结尾.此时,我们按下<code>:</code>.这时候,底行上出现了<code>:&#39;&lt;,&#39;&gt;</code>,看起来有点怪怪的,但是你可以简单的认为,它就代表了可视化模式的选区.然后,我们就能指定Ex命令.例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#39;&#60;,&#39;&#62;p</span><br></pre></td></tr></table></figure></p>
<h3 id="通过匹配指定范围">通过匹配指定范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/&#60;html&#62;/,/&#60;\/html&#62;/p</span><br></pre></td></tr></table></figure>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;html&#62;&#10;  &#60;head&#62;&#60;title&#62;Practical Vim&#60;/title&#62;&#60;/head&#62;&#10;  &#60;body&#62;&#60;h1&#62;Practical Vim&#60;/h1&#62;&#60;/body&#62;&#10;&#60;/html&#62;</span><br></pre></td></tr></table></figure></p>
<p>看起来有点复杂,但是,它还是遵循了<code>:{start},{end}</code>的形式.这个<code>start</code>和刚刚的<code>/&lt;html&gt;/</code>相对应.而<code>end</code>和<code>/&lt;\/html&gt;/</code>相对应.</p>
<p>在这个例子中,我们可以通过<code>:2,5</code>指定范围,这个方式更简洁.而通过标签形式的方式,可以直接匹配标签,不论中间有多少行.</p>
<h3 id="通过偏移来指定地址">通过偏移来指定地址</h3><p>假设我们有需求:<code>打印所有的&lt;html&gt;标签内的内容,但是不打印包含&lt;html&gt;的行.</code><br>我们可以指定偏移:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/&#60;html&#62;/+1,/&#60;\/html&#62;/-1p</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;head&#62;&#60;title&#62;Practical Vim&#60;/title&#62;&#60;/head&#62;&#10;&#60;body&#62;&#60;h1&#62;Practical Vim&#60;/h1&#62;&#60;/body&#62;</span><br></pre></td></tr></table></figure></p>
<p>这个语法的一般形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;address&#125;+n</span><br></pre></td></tr></table></figure></p>
<p>如果<code>n</code>省略,那么它默认是1.这个<code>address</code>可以是<code>行号</code>或者是<code>标记</code>或者是<code>模式匹配</code><br>那么我们可以实现,从当前行打印后面3行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.,.+3p</span><br></pre></td></tr></table></figure></p>
<h3 id="讨论">讨论</h3><p>指定范围的语法非常灵活.我们可以混合使用<code>行号</code> <code>标记</code> <code>模式匹配</code>,也可以通过应用偏移来修改范围.<br>下面的表格可以作为一个参考:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#31526;&#21495;      &#20195;&#34920;&#30340;&#22320;&#22336;&#10;1         &#25991;&#20214;&#30340;&#31532;&#19968;&#34892;&#10;$         &#25991;&#20214;&#30340;&#26368;&#21518;&#19968;&#34892;&#10;.         &#20809;&#26631;&#25152;&#22312;&#34892;&#10;&#39;m        &#26631;&#35760;m&#25152;&#22312;&#30340;&#34892;&#10;&#39;&#60;        &#21487;&#35270;&#21270;&#36873;&#21306;&#30340;&#24320;&#22987;&#10;&#39;&#62;        &#21487;&#35270;&#21270;&#36873;&#21306;&#30340;&#32467;&#23614;&#10;%         &#25991;&#20214;&#25152;&#26377;&#34892; ( :1,$ &#30340;&#24555;&#25463;&#26041;&#24335;)&#10;0         &#31532;0&#34892;</span><br></pre></td></tr></table></figure></p>
<p>第0行并不真实存在,但是在特定的情况下,这个地址还是很有用的.例如,在<code>:copy {address}</code>和<code>:move {address}</code>中,我们想复制或者移动从文件开头的范围.在后面的两个Tip中,我们将看到具体的例子.</p>
<p>当我们指定一个<code>[range]</code>,它总是表示一些连续的行.我们也能通过模式匹配应用Ex命令到一系列非连续的行,通过<code>:global</code>这个命令就能做到.</p>
<h2 id="Tip_29_通过t和m复制和移动行">Tip 29 通过t和m复制和移动行</h2><p><code>:copy</code>命令(快捷方式是<code>:t</code>)让我们可以复制1到多行,而<code>:move</code>命令可以移动1到多行.</p>
<p>为了说明,我们使用下面的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shopping list&#10;    Hardware Store&#10;        Buy new hammer&#10;    Beauty Parlor&#10;        Buy nail polish remover&#10;        Buy nails</span><br></pre></td></tr></table></figure></p>
<h3 id="通过:t命令复制行">通过:t命令复制行</h3><p>我们的购物清单还不完整.假设我们也需要在<code>Hardware Store</code>买<code>nails</code>.为了修正这个清单,我们重用文件的最后一行.我们可以简单的使用<code>:copy</code>命令完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shopping list&#10;    Hardware Store&#10;        Buy nails&#10;        Buy new hammer&#10;    Beauty Parlor&#10;        Buy nail polish remover&#10;        Buy nails</span><br></pre></td></tr></table></figure>
<p>上述命令是通过<code>:160copy.</code>完成的(在我编写这个文档的时候,Buy nails 是第160行`)</p>
<p>copy命令的一般格式是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]copy &#123;address&#125;</span><br></pre></td></tr></table></figure></p>
<p>在我们的例子中,<code>[range]</code>是<code>160</code>行.<code>{address}</code>在这个例子中是<code>.</code>,代表了当前行.所以这个<code>:160copy.</code>的意义是:<code>复制160行,并且放置到当前行的下面</code>.</p>
<p>我们也可以简写<code>:copy</code>成<code>:co</code>,也可以更简洁的写成<code>:t</code>.为了辅助记忆,你可以理解<code>t</code>为:<code>copy To</code>.下面的表格中列举了一些<code>:t</code>的用法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#21629;&#20196;             &#25928;&#26524;&#10;:6t.            &#22797;&#21046;&#31532;6&#34892;&#21040;&#24403;&#21069;&#34892;&#30340;&#19979;&#38754;&#10;:t6             &#22797;&#21046;&#24403;&#21069;&#34892;&#21040;&#31532;6&#34892;&#19979;&#38754;&#10;:t.             &#22797;&#21046;&#24403;&#21069;&#34892;(&#30456;&#24403;&#20110;&#21629;&#20196;&#27169;&#24335;&#19979;&#30340;yyp)&#10;:t$             &#22797;&#21046;&#24403;&#21069;&#34892;&#21040;&#25991;&#20214;&#32467;&#23614;&#10;:&#39;&#60;,&#39;&#62;t0        &#22797;&#21046;&#21487;&#35270;&#21270;&#36873;&#21306;&#21040;&#25991;&#20214;&#24320;&#22836;</span><br></pre></td></tr></table></figure></p>
<p>注意: <code>:t.</code>复制当前行.作为选择,我们也可以通过命令模式下的<code>yyp</code>实现同样的效果.一个值得注意的区别就是<code>yyp</code>使用寄存器,而<code>:t.</code>不这样.有时候,为了避免覆盖默认寄存器的内容,我使用<code>:t.</code>复制当前行.</p>
<p>在这个例子中,我们使用<code>yyp</code>的变体复制我们想要的行,但是,它需要一些额外的移动.我们需要先跳转到到我们想复制的行<code>6G</code>,复制<code>yy</code>,回到我们开始的地方<code>&lt;C-o&gt;</code>,然后<code>p</code>粘贴.所以,在这种比较远的复制操作,<code>:t</code>这种命令更高效.</p>
<h3 id="通过:m命令移动行">通过:m命令移动行</h3><p>语法是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]move &#123;address&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以简写成<code>:m</code><br>如果已经选择好了分区.我们可以直接运行命令<code>:&#39;&lt;,&#39;&gt;m$</code>,作为选择,我们也可以使用<code>dGp</code>命令.这个命令可以分解为:<code>d</code>删除,同时复制到寄存器,<code>G</code>跳转到文件结尾,<code>p</code>粘贴内容.</p>
<p>重复上个Ex命令: <code>@:</code></p>
<h2 id="Tip_30_在一个范围上使用命令模式的命令">Tip 30 在一个范围上使用命令模式的命令</h2><p>在Tip 2 中,我们在每行的后面追加一个分号,当时我们使用的<code>.</code>命令做的重复.当时只有几行,那么做可以,但是如果有2000行需要追加呢? 显然,用<code>j.</code>的方式就不靠谱了.</p>
<p>使用<code>normal</code>命令可以对一个范围使用命令模式下的命令.</p>
<p>我们使用下面的代码来说明问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1&#10;var bar = &#39;a&#39;&#10;var baz = &#39;z&#39;&#10;var foobar = foo + bar&#10;var foobarbaz = foo + bar + baz</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>A;&lt;Esc&gt;</code> 跳转到行结尾,输入<code>;</code>,退出插入模式</li>
<li><code>jVG</code> 选中除了第一行的的后面所有行</li>
<li><code>&#39;&lt;,&#39;&gt;normal.</code> normal执行命令模式,<code>.</code>重复</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#10;var bar = &#39;a&#39;;&#10;var baz = &#39;z&#39;;&#10;var foobar = foo + bar;&#10;var foobarbaz = foo + bar + baz;</span><br></pre></td></tr></table></figure>
<p>使用了上面的步骤,不管是5行还是5000行,都能正常工作.<br>其实不仅仅是<code>.</code>这个命令,使用了<code>normal</code>这个标记之后,我们可以执行任何命令模式下命令.</p>
<p>在这个例子中,我们可以通过一个命令完成操作.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%normal A;</span><br></pre></td></tr></table></figure></p>
<p><code>%</code>这个命令表示整个文件范围的行.所以上面的命令的意思是:<code>在文件的每一行后面都追加一个;</code>,而且Vim会在完成之后,自动切换到命令模式</p>
<p>既然可以通过<code>:normal</code>这个命令使用所有的命令模式命令.那么下面这个命令也很同意理解.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%normal i//</span><br></pre></td></tr></table></figure>
<p>在所有行的开始加入<code>//</code>.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-03T09:03:58.000Z"><a href="/2016/08/03/其他技术/Vim实践Tips-五/">2016-08-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/03/其他技术/Vim实践Tips-五/">Vim实践Tips(五)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_20_体验可视化模式">Tip 20 体验可视化模式</h2><p>在可视化模式下,很多命令的作用和它们在命令模式时相同.我们仍旧可以使用<code>hjkl</code>来移动光标.使用<code>f{char}</code>跳转到当前行的某个字符.然后使用<code>;</code>重复跳转,或者使用<code>,</code>反向跳转.我们甚至可以使用查找命令(包括<code>n</code>和<code>N</code>)跳转到匹配的地方.在可视化模式下,移动光标,将改变选择的范围.</p>
<p>虽然大多数命令一样,但是也有一些细微的差别,例如<code>c</code>这个命令.在命令模式下.我们使用<code>c{motion}</code>删除内容并进入插入模式.而在可视化模式下,在选中了部分内容时,只需要一个<code>c</code>就能进入插入模式,删除的内容是高亮部分的内容.这时候,这个<code>c</code>的作用更直观了.</p>
<p>下面看一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">March is a month</span><br></pre></td></tr></table></figure>
<p>如果要把<code>March</code>改为<code>April</code>,假设我们已经把光标放在了<code>March</code>这个单词上的任意位置了.那么可以通过<code>viw</code>选择整个单词.这时候,我们不能直接输入<code>April</code>,因为<code>A</code>会触发Vim命令.然后只会输入剩下的<code>pril</code>.所以,我们使用<code>c</code>这个命令,删除当前选择并进入插入模式.然后输入<code>April</code>.</p>
<h3 id="遇见选择模式">遇见选择模式</h3><p>在一般的编辑器中,当我们选中想要删除的文字时候,只要输入点内容,就能覆盖原来的文本,但是可视化模式没有遵循这个惯例.而选择模式是这样的.</p>
<p>我们可以通过<code>&lt;C-g&gt;</code>切换可视化模式和选择模式.唯一可以看到的区别就是在屏幕的底部,可视化模式是<code>VISUAL</code>而选择模式是<code>SELECT</code>.当在选择模式下输入任意可打印的字符时候,将替换,并自动进入插入模式.当然,这个功能也能通过在可视化模式下,按<code>c</code>来实现.Vim做这个东西的作用,应该为了更符合用户的习惯.</p>
<h2 id="Tip21_定义可视化选区">Tip21 定义可视化选区</h2><p><strong>可视化模式有三个不同的子模式,他们用来处理不同的可视化模式.</strong></p>
<p>在字符可视化模式(character-wise Visual mode),我们可以以字符为单位选取内容.它可以是一个字符,也可以是多行.它适合于对独立的单词或者段落.<br>在行可视化模式(line-wise Visual mode),处理的单位是行<br>在块可视化模式(block-wise Visual mode),我们可以选择柱形区域</p>
<p>这里只是粗略一说,后面有更详细的内容.</p>
<h3 id="进入可视化模式">进入可视化模式</h3><p>使用<code>v</code>键,可以进入可视化模式.按<code>v</code>键,可以从命令模式,进入字符可视化模式.通过<code>V</code>(Shift-v),可以进入行可视化模式.通过<code>&lt;C-v&gt;</code>可以进入块可视化模式.<br>下面是简单的一个列举:</p>
<p>命令        作用<br>v           进入字符可视化模式<br>V           进入行可视化模式</p>
<p><c-v>       进入块可视化模式<br>gv          重新选择最后一次的选区</c-v></p>
<p><code>gv</code>是个很好用的快捷命令.无论是什么可视化模式,<code>gv</code>都能应对自如.唯一可能有点问题的是:你已经删除了最后一次选区的内容.</p>
<h3 id="在可视化模式中切换">在可视化模式中切换</h3><p>下面是命令参考表<br>命令          作用</p>
<p><esc>         切换到命令模式</esc></p>
<p><c-[>         切换到命令模式<br>v             在命令模式和字符可视化模式切换<br>V             在命令模式和行可视化模式切换</c-[></p>
<p><c-v>         在命令模式和字符块视化模式切换<br>o             把光标在选区的两端切换.</c-v></p>
<h3 id="切换选区的可变端">切换选区的可变端</h3><p>默认选择选区的时候,一端是固定的,另一端是可以通过各种移动命令进行移动的.可以通过<code>o</code>这个命令切换移动端.</p>
<p>补充小知识:</p>
<p><code>e</code>移动到下个单词的结尾.</p>
<h2 id="Tip_22_重复行可视化模式命令">Tip 22 重复行可视化模式命令</h2><p>当我们在可视化模式下执行一个命令之后,我们就会进入命令模式.在可视化模式下选中的文字将取消选中.那么如果我们想对刚刚选中的文字重新执行一个可视化模式的命令该怎么办?</p>
<p>假设我们有下面一段python:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):&#10;  a, b = 0, 1&#10;  while a &#60; n:&#10;print a,&#10;a, b = b, a+b&#10;fib(42)</span><br></pre></td></tr></table></figure>
<h3 id="准备工作">准备工作</h3><p>为了让<code>&lt;</code>和<code>&gt;</code>这两个命令正常工作,我们应该做下面的设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth=4 softtabstop=4 expandtab</span><br></pre></td></tr></table></figure></p>
<h3 id="缩进一次,然后重复">缩进一次,然后重复</h3><p>对于刚刚的python代码,缩进有问题,我们应该在可视化模式下选择.然后使用<code>&gt;</code>这个命令缩进.但是缩进要超过两次.而执行一次刚刚的命令之后,我们就会进入命令模式.</p>
<p>有个解决方案是通过<code>gv</code>命令,然后再次执行缩进命令.但是如果你对Vim已经有了感觉,那你就应该知道这个方式是不好的.</p>
<p>当我们需要重复,<code>.</code>这个命令是一个非常好的选择.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):&#10;  a, b = 0, 1&#10;  while a &#60; n:&#10;    print a,&#10;    a, b = b, a+b&#10;fib(42)</span><br></pre></td></tr></table></figure>
<p>上面是通过 <code>Vj</code>选中两行,然后<code>&gt;.</code>完成的</p>
<p>如果你喜欢计算,那么你可能更喜欢<code>2&gt;</code>这个命令.但是我更喜欢使用<code>.</code>这个命令.因为这个命令可以给我可视化的反馈.我也能享受到自己键盘的反馈的乐趣.之前我们也讨论过计数和重复的取舍.你可以重新看看.</p>
<h2 id="Tip_23_在可能的时候,在可视化模式下,使用操作符">Tip 23 在可能的时候,在可视化模式下,使用操作符</h2><p>可视化模式更直观,但是它有个缺点:<code>.</code>这个命令不能完全发挥作用.我们可以通过命令模式下的命令来搞定这个缺点.</p>
<p>假设我们有下面一段文字.我们想把下面链接设置为大写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;a href=&#34;#&#34;&#62;one&#60;/a&#62;&#10;&#60;a href=&#34;#&#34;&#62;two&#60;/a&#62;&#10;&#60;a href=&#34;#&#34;&#62;three&#60;/a&#62;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过<code>vit</code>命令选中标签内部的文字,它理解为:可视化选中标签之间的文字.<code>it</code>命令是一种特别的<code>{motion}</code>命令.我们将在<code>Tip 51</code>进行更深入讨论.</p>
<h3 id="使用可视化操作符号">使用可视化操作符号</h3><p>在可视化模式下,我们选择一段文字,然后对它进行操作.在这个案例下,我们可以使用<code>U</code>命令来让选中的文字变成大写.<br>完成了第一行之后,如果想对第二行,第三行进行操作.应该怎么办呢?<code>.</code>命令可以吗?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;a href=&#34;#&#34;&#62;ONE&#60;/a&#62;   &#34;vit&#10;&#60;a href=&#34;#&#34;&#62;TWO&#60;/a&#62;   &#34;j.&#10;&#60;a href=&#34;#&#34;&#62;THRee&#60;/a&#62; &#34;j.</span><br></pre></td></tr></table></figure>
<p>可以看到,<code>.</code>命令仅仅重复了三个字符.造成了最后一行的样子.这并不是我们想要的结果.</p>
<h3 id="使用命令模式下的操作符">使用命令模式下的操作符</h3><p><code>U</code>这个可视化模式的操作符对应了一个命令模式下的版本:<code>gU{motion}</code>,但是在语义上有很大不同.<br>在可视化模式命令<code>U</code>的案例中,我们做了两件事:</p>
<ol>
<li><code>vit</code>选中文本</li>
<li><code>U</code>操作文本变成大写<br>在命令模式的案例中,我们弄了一个命令,这个命令由:<code>gU</code>操作和<code>it</code>作为<code>{motion}</code>.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;a href=&#34;#&#34;&#62;ONE&#60;/a&#62; &#34;gUit&#10;&#60;a href=&#34;#&#34;&#62;TWO&#60;/a&#62; &#34;j.&#10;&#60;a href=&#34;#&#34;&#62;THREE&#60;/a&#62; &#34;j.</span><br></pre></td></tr></table></figure>
<p>确实,可视化模式有局限性.但是它也很有用处.因为并不是所有编辑工作都需要重复.所以可视化模式是非常适合单次的编辑.</p>
<h2 id="Tip_24_在块可视化模式下编辑表格化数据">Tip 24 在块可视化模式下编辑表格化数据</h2><p>所有编辑器都可以以行为单位编辑数据.在Vim中,块可视化模式,提供给我们以列为单位编辑数据.</p>
<p>假设有下面的文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter       Page&#10;Normal mode     15&#10;Insert mode     31&#10;Visual mode     44</span><br></pre></td></tr></table></figure>
<p>我们要加点东西,让上面的文字看起来更像表格.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter     | Page&#10;==================&#10;Normal mode |   15&#10;Insert mode |   31&#10;Visual mode |   44</span><br></pre></td></tr></table></figure>
<p>上面的实现步骤是:</p>
<ol>
<li><code>&lt;C-v&gt;3j</code>进入块可视化模式,并向下选择3行</li>
<li><code>r|</code>将选中范围替换为 <code>|</code></li>
<li>同理,复制一行,然后替换为<code>=</code></li>
</ol>
<h2 id="Tip_25_改变多列文本">Tip 25 改变多列文本</h2><p>假设有下面一段css代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li.one   a&#123; background-image: url(&#39;/images/sprite.png&#39;); &#125;&#10;li.two   a&#123; background-image: url(&#39;/images/sprite.png&#39;); &#125;&#10;li.three a&#123; background-image: url(&#39;/images/sprite.png&#39;); &#125;</span><br></pre></td></tr></table></figure></p>
<p>假设<code>sprite.png</code>  已经从<code>images</code>文件夹移动到了<code>components</code>文件夹.我们需要修改三行来改变目录.这时候,我们就能使用块可视化模式了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li.one   a&#123; background-image: url(&#39;/components/sprite.png&#39;); &#125;&#10;li.two   a&#123; background-image: url(&#39;/components/sprite.png&#39;); &#125;&#10;li.three a&#123; background-image: url(&#39;/components/sprite.png&#39;); &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>光标定位到images这个单词的开头.</li>
<li><code>&lt;C-v&gt;jje</code>选中三列的images</li>
<li><code>c</code>删除单词,并进入插入模式, 输入<code>components</code>,然后<code>&lt;Esc&gt;</code>.</li>
</ol>
<p>唯一一个可能造成疑惑的是,当第三步输入单词之后,只改变了第一行.但是,当按了<code>&lt;Esc&gt;</code>之后,三行都改变了.<br>确实Vim的这个功能有点不太人性化.但是,最终结果没有什么区别.习惯就好了</p>
<h2 id="Tip_26_在参差不齐的块选区后面追加内容">Tip 26 在参差不齐的块选区后面追加内容</h2><p>假设有下面一段js代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1&#10;var bar = &#39;a&#39;&#10;var foobar = foo + bar</span><br></pre></td></tr></table></figure></p>
<p>这三行不是一样长的,假设我们想为每一行的后面添加一个<code>,</code> 在<code>Tip2</code>我们通过<code>.</code>完成了这个操作.其实通过块可视化区域也能完成这个任务.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#10;var bar = &#39;a&#39;;&#10;var foobar = foo + bar;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>&lt;C-v&gt;jj$</code>选中全部</li>
<li><code>A;</code>移动到结尾,进入插入模式,并输入</li>
<li><code>&lt;Esc&gt;</code>完成</li>
</ol>
<p>细心可以看出,这个操作和Tip 25差不多意思.<br>主要是通过<code>$</code>改变了矩形的结尾.</p>
<h3 id="Vim关于_i_和_a_的惯例">Vim关于 i 和 a 的惯例</h3><p>Vim有很多从命令模式切换到插入模式的按键.<code>i</code>和<code>a</code>都能完成这个操作.<code>i</code>在光标前进入插入模式,<code>a</code>在光标后进入插入模式.<code>I</code>和<code>A</code>功能类似,是在行开头和行结尾进入插入模式.</p>
<p>在块可视化模式中,<code>A</code>和<code>I</code>的功能和在命令模式下类似.那么<code>a</code>和<code>i</code>呢?</p>
<p>在可视化模式和操作符悬停模式下,<code>a</code>和<code>i</code>有不同的意义.这个在Tip 51会有更深入的讨论.现在记得,使用<code>A</code>和<code>I</code>替代</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-22T08:20:01.000Z"><a href="/2016/07/22/其他技术/Vim实践Tips-四/">2016-07-22</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/22/其他技术/Vim实践Tips-四/">Vim实践Tips(四)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_13_在插入模式下做修改">Tip 13 在插入模式下做修改</h2><p>如果我们在插入模式下输入错误,没有必要先切换模式然后做修改.除了退格键,我们还有一些插入模式下的命令可以用.</p>
<p>凭借触感打字不仅仅是不看键盘.而是凭借感觉输入.当输入错误的时候,甚至他们不用看到屏幕上的错误就知道自己输入错误了.因为他们指头已经知道自己刚刚按错地方了.</p>
<p>当输入的错误在单词结尾的时候,退格键是有效的纠正方式,但是当错误出现在单词开头的时候呢?</p>
<p>出色的打字员推荐这样一个方式: 当出现错误的时候,删除整个单词,然后重新输入.如果你一分钟能输入<code>60</code>个单词,那么重新输入总会比你单个删除字符更快.当然,如果你打字慢,就可以当成一个练习打字速度的练习.多输入正确的单词,有利于你养成输入的感觉.</p>
<p>当然,你也可以切换到命令模式.把光标跳转到单词开头,修改错误,然后<code>A</code>跳转到句子结尾.这个行为肯定是呀看大于1秒了.重要的是,这个不会提高你对输入的感觉</p>
<p>在插入模式下,就像你预料到的,它删除光标前的字符.下面的快捷键也是挺好的:</p>
<ul>
<li><code>&lt;C-h&gt;</code> 删除前面的一个字符,等于退格键</li>
<li><code>&lt;C-w&gt;</code> 删除前面的一个单词</li>
<li><code>&lt;C-u&gt;</code> 删除到本行开始</li>
</ul>
<p>上面的命令不是插入模式特有,甚至不是Vim特有的,你也可以在Bash Shell中使用它们.</p>
<h2 id="Tip14_回到命令模式">Tip14 回到命令模式</h2><p>插入模式是特定用于文本输入的模式.命令模式才是才是我们花费时间最多的模式,它的名字是<code>normal mode</code>,这个名字说明了一切.所以,会在这两者之前切换就很重要了.</p>
<p>经典的返回命令模式的方式是按<code>&lt;Esc&gt;</code>键,但是对于大多数键盘,这个键有点远.所以,作为备选方案,你可以按<code>Ctrl+[</code>,这个组合件和<code>&lt;Esc&gt;</code>等价.</p>
<ul>
<li><code>&lt;Esc&gt;</code> 切换到命令模式</li>
<li><code>&lt;C-[&gt;</code> 切换到命令模</li>
<li><code>&lt;C-o&gt;</code> 在插入和命令模式下切换</li>
</ul>
<h3 id="遇见插入命令模式">遇见插入命令模式</h3><p>插入命令模式是命令模式的一个特别版本.我们可以出发一个单独命令,之后我们就会进入插入模式.在插入模式中,我们可以通过<code>&lt;C-o&gt;</code>切换到命令模式.</p>
<p>我们会通过<code>zz</code>命令将当前行滚动到屏幕中间.而我经常做的是在插入模式下<code>&lt;C-o&gt;zz</code>,这样会把当前行滚动到屏幕中间,并且可以继续输入.</p>
<h2 id="Tip_15_在不离开插入模式下前提下,从寄存器粘贴">Tip 15 在不离开插入模式下前提下,从寄存器粘贴</h2><p>Vim的复制粘贴命令多数情况下是在命令模式下执行的.但是,有时候我们想在插入模式进行.</p>
<h3 id="映射CapsLock键-">映射<code>CapsLock</code>键.</h3><p>对于Vim的使用者来说,<code>CapsLock</code>键简直就是个威胁.例如本来<code>j</code>是移动.可是当<code>CapsLock</code>之后,它成为了<code>J</code>是联合两行.很多Vimer都把<code>CapsLock</code>映射成了其他键位.例如<code>&lt;Esc&gt;</code>或者<code>Ctrl</code>.我推荐你对它进行映射.</p>
<p>下面一段文字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Practical Vim, by Drew Neil&#10;Read Drew Neil&#39;s</span><br></pre></td></tr></table></figure></p>
<p>我们想通过插入本书书名的方式完成第二行.本书的名字已经在第一行了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Practical Vim, by Drew Neil  &#34; yt,&#10;Read Drew Neil&#39;s Practical Vim            &#34;&#25353;&#38190;&#39034;&#24207;jA &#60;C-r&#62;0.&#60;ESc&#62;</span><br></pre></td></tr></table></figure>
<p><code>yt,</code>复制<code>,</code>之前的单词到寄存器中<br><code>&lt;C-r&gt;0</code> 粘贴寄存器中的内容到当前光标我再的位置.</p>
<p>通用的格式是<code>&lt;C-r&gt;{register}</code>这个<code>register</code>是我们想要插入的寄存器.</p>
<p><code>&lt;C-r&gt;{register}</code> 这个命令对于少数的字符来说,是比较好的.但是如果粘贴大量的文本,你就会感觉到了延迟.因为这个命令从寄存器中粘贴,相当于一个一个的字符进行输入.如果<code>textwidth</code>或者<code>autoindent</code>选项开启了.那么你可能会得到一些不想要的断行或者额外的缩进.</p>
<p><code>&lt;C-r&gt;&lt;C-p&gt;{register}</code>命令更智能一些.它真实的插入文字,并且能够修正缩进问题.所以,如果要从寄存器中粘贴多行文本.我推荐你使用这个命令.</p>
<h2 id="Tip16_在输入处进行计算">Tip16 在输入处进行计算</h2><p>表达式寄存器允许我们执行计算并插入到我们的文档中.</p>
<p>多数Vim的寄存器既可以包含字符组成的字符串,也可以包含一整行文字.我们通过删除或者复制命令设置寄存器的内容.</p>
<p>表达式寄存器有所不同.它可以评估一段Vim脚本代码,然后返回结果.所以,我们可以把它当做一个计算器.它的结果可以和其它的文本寄存器一样使用.</p>
<p>在插入模式下输入<code>&lt;C-r&gt;=</code>,这样,在底行下会有提示.然后就能直接输入计算表达式了.当计算完成.<code>&lt;CR&gt;</code>一下,表达式结果就能直接插入到文档中了.</p>
<p>假设有下面的文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 chairs, each costing $35, totals $</span><br></pre></td></tr></table></figure>
<p>使用寄存器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 chairs, each costing $35, totals $210   &#34;A&#60;C-r&#62;6*35&#60;CR&#62;</span><br></pre></td></tr></table></figure></p>
<h2 id="Tip17_通过字符编码插入字符">Tip17 通过字符编码插入字符</h2><p><strong>Vim可以通过字符编码插入任意字符,通过这个特性,我们可以输入键盘上找不到的字符</strong></p>
<p>在插入模式下,输入<code>&lt;C-v&gt;{code}</code>即可,code是字符的编码.Vim要求code是三位数.所以,如果我们要输入<code>A</code>这个字符,它的字符编码是<code>65</code>,那么我们需要输入<code>&lt;C-v&gt;065</code>.</p>
<p>但是如果我们想要插入大于三位的字符编码怎么办呢?我们可以告诉Vim,要使用十六进制输入<code>&lt;C-v&gt;u{1234}</code>.例如,我们要插入一个倒着的问号.(字符码是<code>00bf</code>) 那么我们输入<code>&lt;C-v&gt;u00bf</code></p>
<p>使用<code>ga</code>命令可以查看文档中字符的编码.命令模式下将光标停留在想要查看的字符上,然后<code>ga</code>,文档的底部将会显示它的信息,包括字符编码,十六进制和十进制表示.</p>
<p>另外一种场景,如果<code>&lt;C-v</code>命令后面跟了非数字键,那么它插入那个键的文字表示,例如我按下<code>&lt;C-v&gt;退格键</code>,那么输入的将是<code>&lt;BS&gt;</code></p>
<h2 id="Tip18_通过连字插入字符-">Tip18 通过连字插入字符.</h2><p><strong>通过字符编码插入字符虽好,但是字符编码难记.通过连字插入会简单一些</strong></p>
<p>在插入模式下,输入<code>&lt;C-k&gt;{char1}{char2}</code>即可</p>
<p>连字通常是有一定的意义的.例如常见的<code>1/2</code>,<code>1/3</code>,我们可以输入<code>&lt;C-k&gt;12</code>,<code>&lt;C-k&gt;13</code>得到.倒置的问号可以通过<code>&lt;C-k&gt;?I</code>得到.</p>
<p>更多的连字可以通过<code>:digraphs</code>查看.</p>
<h2 id="使用替换模式覆盖文字">使用替换模式覆盖文字</h2><p>有下面一段文字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typing in Insert mode extends the line. But in Replace mode&#10;the line length doesn&#39;t change.</span><br></pre></td></tr></table></figure>
<p>我们想把两句话合并成一句话.意味着:</p>
<ol>
<li>将<code>.</code>换成<code>,</code></li>
<li>把<code>B</code>改成<code>b</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typing in Insert mode extends the line, but in Replace mode&#10;the line length doesn&#39;t change.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们使用<code>f.</code>定位光标到<code>.</code>的位置.然后<code>R</code>进入替换模式.然后输入<code>, b</code>替换原来的字符.完成替换之后,我们可以按<code>&lt;Esc&gt;</code>返回命令模式.</p>
<h3 id="使用可视化替换模式">使用可视化替换模式</h3><p>一些字符会给替换模式带来麻烦,例如<code>&lt;Tab&gt;</code>产生的缩进.如果要替换,需要输入很多字符(根据你对tab的设置),这时候,使用<code>gR</code>命令是更好的选择.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-21T09:43:06.000Z"><a href="/2016/07/21/其他技术/Vim实践Tips-三/">2016-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/21/其他技术/Vim实践Tips-三/">Vim实践Tips(三)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_10_使用计数做一些简单的计算">Tip 10 使用计数做一些简单的计算</h2><p>大多数命令模式下的指令能够和计数搭配使用.我们可以利用这个特性做一些简单的运算.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this character is 5</span><br></pre></td></tr></table></figure>
<p><code>&lt;C-a&gt;</code> 增加计数 (Ctrl+a)<br><code>&lt;C-x&gt;</code> 减少计数 (Ctrl+x)<br>他们可以可数字搭配使用,例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this character is 16 &#34; 10&#60;C-a&#62;</span><br></pre></td></tr></table></figure>
<p>这个<c-a> 如果是在数字字符上,那么就会给他增加数字.如果没有在数字上,那么它会在这行中查找数字,并且跳转到数字上.如果没有那么就不会做任何操作.</c-a></p>
<p>例如下面有一段 css 代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.blog, .news &#123; background-image: url(/sprite.png); &#125;&#10;.blog &#123; background-position: 0px 0px &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们要复制最后一行,然后做一些改变:</p>
<ol>
<li>把单词 <code>blog</code> 换成 <code>news</code></li>
<li>把 <code>0px</code> 换成 <code>-180px</code></li>
</ol>
<p>实现1,可以使用 <code>yyp</code> 然后使用 <code>cw</code> 修改单词.<br>那么2怎么实现呢?</p>
<p>第一种方式是: <code>f0</code>, 然后 <code>i</code> 进入插入模式,输入<code>-18</code>,然后<code>&lt;Esc&gt;</code><br>但是我们的光标不在数字上,那么需要额外的跳转.而 <code>&lt;C-x&gt;</code> 可以自动给我们找到数字.<br>所以,直接 <code>180&lt;C-x&gt;</code> 更快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.blog &#123; background-position: -180px 0px &#125; &#34;180&#60;C-x&#62;</span><br></pre></td></tr></table></figure>
<h2 id="Tip_11_如果可以重复,就别计数">Tip 11 如果可以重复,就别计数</h2><p>我们可以通过提供个数字来减少完成特定任务所需要的按键.但是这不代表我们就该这么做.还是应该思考下到底该重复还是该计数.</p>
<p>假设我们有下面的文字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delete more than one word</span><br></pre></td></tr></table></figure>
<p><code>d2w</code>  和 <code>2dw</code> 都能完成任务.</p>
<ul>
<li><code>d2w</code> 是<code>d</code>, 然后加上<code>2w</code> 的 <code>motion</code> ,理解为: 删除两个单词</li>
<li><code>2dw</code>是2次执行 <code>dw</code> ,理解为: 删除一个单词,执行两次</li>
</ul>
<p>现在让我们想想一个替换方案: <code>dw.</code> 删除一个单词,然后重复之.</p>
<h3 id="讨论几种方式-">讨论几种方式.</h3><p>其实<code>d2w</code>和<code>2dw</code> 没有区别,如果执行之后,按 <code>u</code> ,都会恢复两个单词.如果按<code>dot</code>,将重复删除后两个单词.<br>如果我们要删除下一个单词(总共三个)那我们就需要先<code>u</code>(恢复两个单词),然后<code>d3w</code>.这还是比较麻烦的.<br><code>dw.</code> 按<code>u</code>,会恢复一个单词,如果删除下个单词,只需要重新按<code>dot</code>即可.<br>在这种情况下,重复的优势更明显.</p>
<p>如果我要删除6个单词呢? 我可以 <code>d6w</code> 或者<code>6dw</code>.或者 <code>dw.....</code> ,当然,前者有更少的按键.但是有个问题在这:我们需要数一下单词的数量,而且如果错误了,<code>u</code>会恢复<code>6</code>个单词.而<code>dw.....</code>如果出现错误,<code>u</code>一下,只是恢复一个单词.我们可以更好的控制这个过程.</p>
<p>记住我们的”咒语”: 操作,重复,撤销. </p>
<h3 id="必要时使用计数">必要时使用计数</h3><p>下面的文字,如果我要把 <code>a couple of</code> 换成 <code>some more.</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I have a couple of questions.&#10;I have some more questions. &#34;&#25353;&#38190;&#20381;&#27425;&#26159; c3wsome more</span><br></pre></td></tr></table></figure></p>
<p>在这个场景下,使用dot命令没有什么意义.即使重复了,最后还要按<code>i</code>进入插入模式.这样太笨拙了,所以我还是愿意使用计数.</p>
<p>计数还有个好处,就是能够有个条理清楚的恢复操作.比如我<code>d3w</code>,<code>u</code>就会恢复3个单词</p>
<h1 id="Tip_12_征服结合命令">Tip 12 征服结合命令</h1><p>Vim的强大源于操作符和移动命令的结合.</p>
<h3 id="操作符+移动=操作">操作符+移动=操作</h3><p><code>d{motion}</code> 可以使用<code>dl</code>删除一个字符,<code>daw</code>删除整个单词,<code>dap</code>删除整段.<br><code>c{motion}</code> 和 <code>y{motion}</code>和上面类似</p>
<p>操作符和移动的结合,可以认为是一种语法.第一条规则很简单:一个动作由一个操作符和一个移动组成.学习新的操作符就像学习Vim的词汇表.只要我们遵循简单的语法,随着词汇量增加,我们就能表达更多想法.</p>
<p>假设我们已经知道了通过 daw 删除一整个单词.然后,我们学到了 <code>gU</code>,这也是一个操作符.所以,我们就能通过gUaw把当前单词转换成大写.</p>
<p>再假设我们知道了<code>ap</code>(一整段motion},然后我们就能合成新的操作:<br><code>dap</code> 删除一整段 <code>gUap</code> 让一整段大写.</p>
<p><code>Vim</code>  的语法还有个规则:如果一个操作符被重复输入,那么<code>motion</code>就等于当前行.例如:<br>-<code>dd</code>   删除当前行<br>-<code>&gt;&gt;</code>  缩进当前行<br>-<code>gUgU</code> 或者 <code>gUU</code> 大写当前行 g是后面操作符的一个前缀</p>
<p>Vim的操作符命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25805;&#20316;&#31526;        &#25928;&#26524;&#10;c             Change &#25913;&#21464;&#10;d             Delete &#21024;&#38500;&#10;y             Yank into register &#22797;&#21046;&#21040;&#23492;&#23384;&#22120;&#10;g~            Swap case &#20999;&#25442;&#22823;&#23567;&#20889;&#10;gu            make lowercase &#23567;&#20889;&#10;gU            make upppercase &#22823;&#20889;&#10;&#62;             shift right &#21491;&#31227;&#10;&#60;             shift left &#24038;&#31227;&#10;=             autoindent &#33258;&#21160;&#32553;&#36827;&#10;!             Filter &#123;motion&#125; lines through an external program</span><br></pre></td></tr></table></figure>
<h3 id="拓展Vim整合的力量">拓展Vim整合的力量</h3><p>Vim标准的操作符相对来说比较少,但是我们可以定义新的.</p>
<h3 id="使用现有的操作符自定义移动">使用现有的操作符自定义移动</h3><p>Vim标准的移动命令已经很全面,但是我们还可以增加新的移动和文本对象.</p>
<h3 id="待决模式">待决模式</h3><p>除了明显的插入,命令和底行模式.Vim还有些容易被忽略的模式.待决模式( Operator-Pending mode )就是其中的一个.我们每天都大量使用它,但是每次都持续一小段时间.例如<code>dw</code>,这个模式仅仅持续了你按下<code>d</code>到按下<code>w</code>这中间的这个时间.</p>
<p>如果我们把Vim看做是一个有限状态机.那么待决模式就是仅接受移动命令的状态.当一个操作符被触发的时候,这个状态被激活,在输入移动命令之前,Vim不会做任何操作.当待决模式被激活后,我们可以通过<esc>就可以中断,返回命令模式.</esc></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-19T09:40:15.000Z"><a href="/2016/07/19/其他技术/Vim实践Tips(二)/">2016-07-19</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/19/其他技术/Vim实践Tips(二)/">Vim实践Tips(二)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_5_手动查找和替换">Tip 5 手动查找和替换</h2><p>下面每一行中都有 <code>content</code> 这个单词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;...We&#39;re waiting for content before the site can go live...&#10;&#10;...If you are content with this, let&#39;s go ahead with it...&#10;&#10;...We&#39;ll launch as soon as we have the content...</span><br></pre></td></tr></table></figure>
<p>如果我们想把所有的 <code>content</code> 替换成 <code>copy</code>, 那么可以很简单的想到替换命令.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;:%s/content/copy/g</span><br></pre></td></tr></table></figure>
<p> 但是有时候我们并不想全局替换掉.</p>
<h3 id="懒惰点:不做输入的查找">懒惰点:不做输入的查找</h3><p> 你也许已经猜到<code>.</code>是我最喜欢的单键<code>Vim</code>命令.第二喜欢的是 <code>*</code>,它可以搜索处于光标下面的单词.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;...We&#39;re waiting for copy before the site can go live...&#10;&#10;...If you are copy with this, let&#39;s go ahead with it...&#10;&#10;...We&#39;ll launch as soon as we have the content...</span><br></pre></td></tr></table></figure>
<p> 首先将光标置于 <code>content</code> 上面,然后用<code>*</code>命令去查找它,这时候将发生两个事情:</p>
<ol>
<li><p>光标将跳转到下个匹配处(即下个 <code>content</code> 单词) </p>
</li>
<li><p>所有出现匹配项的地方将高亮显示 (如果没有,使用 <code>:set hls</code> .</p>
</li>
</ol>
<p>上面两件事情发生之后,我们就可以使用 <code>n</code> 命令跳转到下一个.这时候,使用 <code>*nn</code> 可以循环所有匹配,然后光标转到我们开始进行搜索的地方</p>
<h3 id="让更改变得可重复">让更改变得可重复</h3><p>当我们的光标置于 <code>content</code> 的开始位置的时候,我们准备去更改它.这包含两个步骤:</p>
<ol>
<li><p>删除单词 <code>content</code> </p>
</li>
<li><p>输入修改的内容. <code>cw</code> 删除到单词结尾命令,并且进入插入模式.</p>
</li>
</ol>
<p>然后我们输入 <code>copy</code> 这个单词. Vim 将记录我们的键盘点击,直到我们离开插入模式,所以, <code>cwcopy&lt;Esc&gt;</code> 将会被记录为一个单个命令.通过使用<code>.</code>就可以重复上面的操作.</p>
<h2 id="Tip6_Dot公式">Tip6 Dot公式</h2><p>在 Tip2中,我们试着将每个句子后面加<code>;</code> 最后,我们通过 <code>j.</code> 进行重复操作.</p>
<p>在 Tip3中,我们将每个<code>+</code>前后添加空格.  最后,我们通过 <code>;.</code> 进行重复操作</p>
<p>在 Tip5中,我们将 <code>content</code> 替换成 <code>copy</code>,最后,我们通过 <code>n.</code> 进行重复操作.</p>
<h3 id="理想的状态:_一个按键负责移动,一个按键负责执行操作-">理想的状态: 一个按键负责移动,一个按键负责执行操作.</h3><p> 在上面所有的操作中 . 重复最后的更改.这不是他们全部的共同点,我们都还用了一个键去移动光标.这已经是一个不能再好的情况了.我们在将来的编辑中,可以反复看到这个编辑模式.为了方便,我们把这个模式成为 Dot公式 (Dot Formula)</p>
<h2 id="Tip7_拿开你的笔刷">Tip7 拿开你的笔刷</h2><p><code>Normal Mode</code> (命令模式) 可以类比为一个画家,把笔刷离开画布.这时候,他可以休息,可以构思.同理,程序员也可以在 <code>Normal Mode</code> 中进行思考,组织自己的思路.当我们要改变的时候,也不用非得进入插入模式.在 <code>Normal Mode</code>中,我们可以格式化我们的代码,复制,或者移动他们.</p>
<h2 id="Tip8_强化你的撤销">Tip8 强化你的撤销</h2><p>在其他编辑器中,通过在输入一些东西之后进行撤销,可以撤销我们最后输入的单词或者字符.然后在 Vim 中,我们设置可以调整撤销命令的粒度.</p>
<p><code>u</code> 这个命令可以触发撤销命令.它可以撤销包括Normal,Visual还有 Command-Line 模式的更改.当然,也包括在插入模式下的文本输入或者删除.所以我们可以说: <code>i{ 插入一些更改}&lt; Esc&gt;</code>  构成了一个改变. 然后一次<code>u</code> 就可以撤销这个改变.</p>
<p>另外,插入模式中,如果使用了上下左右箭头,那么就相当于在 NormalMode下使用了 <code>hjkl</code>.区别就是我们不用离开插入模式,但是这些操作,会被记录到点公式 (Dot Fomula)中.</p>
<h2 id="Tip9_创建可重复的改变">Tip9 创建可重复的改变</h2><p>vim将重复操作进行了优化,为了利用这个特性.我们需要留心怎么创建可重复的改变</p>
<p>在 Vim 中,做一件事通常有很多方式.但是衡量”好”的方式的机制就是:更少的键盘敲击.</p>
<p>假设我们的光标在 <code>h</code> 这个字母上,我们想要删除单词 <code>nigh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh</span><br></pre></td></tr></table></figure>
<h3 id="1-_向后删除">1. 向后删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh &#34;&#24320;&#22987;&#10;&#10;The end is h &#34;db  &#20174;&#20809;&#26631;&#20301;&#32622;&#21024;&#38500;&#21333;&#35789;&#30340;&#21069;&#38754;&#37096;&#20998;&#10;&#10;The end is  &#34;x &#21024;&#38500;&#24403;&#21069;&#20809;&#26631;&#30340;&#23383;&#31526;</span><br></pre></td></tr></table></figure>
<h3 id="2-_向前删除">2. 向前删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh   &#34;&#24320;&#22987;&#10;&#10;The end is nigh   &#34;b  &#21521;&#21518;&#31227;&#21160;&#20809;&#26631;&#19968;&#20010;&#21333;&#35789;&#10;&#10;The end is        &#34;dw &#21521;&#21069;&#21024;&#38500;&#19968;&#20010;&#21333;&#35789;</span><br></pre></td></tr></table></figure>
<h3 id="3-_删除整个单词">3. 删除整个单词</h3><p>上面两个解决方案都牵涉到了一些准备工作,例如移动.其实,利用<code>aw</code> 命令可以更精准高效的完成我们的需求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end ais nigh   &#34;&#24320;&#22987;&#10;&#10;The end is &#34;daw</span><br></pre></td></tr></table></figure>
<h3 id="4-_哪一个是最可重复的">4. 哪一个是最可重复的</h3><p>上面我们使用了三种方式进行删除一个单词.每种方式中,我们都是按了三个键,那么那种方式是更好的呢?</p>
<p>记住, Vim 优化了重复.那么检验好坏的标准就是重复.下面使用dot 命令来检验三种方式,通过测试发现:</p>
<ul>
<li><p>第一种方式: <code>.</code> 等价于 <code>x</code> (<code>db</code> 是改变操作. <code>x</code> 也是改变操作)</p>
</li>
<li><p>第二种方式: <code>.</code> 等价于 <code>dw</code> (<code>b</code> 是纯移动, <code>dw</code> 是改变操作)</p>
</li>
<li><p>第三种方式: <code>.</code> 等价于 <code>daw</code> (<code>daw</code>是改变操作)</p>
</li>
</ul>
<p>看起来<code>2</code> <code>3</code> 都是挺有用的,但是有个细节 <code>2</code>删除一个单词,但是不会删除对应的空格,表象上来看就是不会移动光标到下个单词上,那么这时候, <code>.</code>这个命令就没什么意义. <code>3</code> 会把要删除的单词附带空格删除,同时光标停留在 <code>is</code> 的结尾.那么<code>.</code>这个操作就能继续删除一个单词. (我强烈建议自己动手试试看)</p>
<p>﻿</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->




<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/React-Native/">React Native</a><small>2</small></li>
  
    <li><a href="/categories/ReactiveCocoa/">ReactiveCocoa</a><small>3</small></li>
  
    <li><a href="/categories/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/categories/Swift进阶/">Swift进阶</a><small>4</small></li>
  
    <li><a href="/categories/UI相关/">UI相关</a><small>1</small></li>
  
    <li><a href="/categories/Xcode-环境配置/">Xcode&amp;环境配置</a><small>1</small></li>
  
    <li><a href="/categories/iOS-Tips/">iOS Tips</a><small>17</small></li>
  
    <li><a href="/categories/主页维护记录/">主页维护记录</a><small>4</small></li>
  
    <li><a href="/categories/其他技术/">其他技术</a><small>8</small></li>
  
    <li><a href="/categories/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/categories/坑/">坑</a><small>1</small></li>
  
    <li><a href="/categories/开发环境相关/">开发环境相关</a><small>5</small></li>
  
    <li><a href="/categories/悟/">悟</a><small>1</small></li>
  
    <li><a href="/categories/环境、配置相关/">环境、配置相关</a><small>6</small></li>
  
    <li><a href="/categories/研究随笔/">研究随笔</a><small>2</small></li>
  
    <li><a href="/categories/视频相关/">视频相关</a><small>1</small></li>
  
    <li><a href="/categories/重构、模式、架构/">重构、模式、架构</a><small>10</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Clang-Format/">Clang Format</a><small>1</small></li>
  
    <li><a href="/tags/React-Native/">React Native</a><small>1</small></li>
  
    <li><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a><small>3</small></li>
  
    <li><a href="/tags/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/tags/Swift-进阶/">Swift 进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶/">Swift进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶-variable-with-a-setter-must-also-have-a-getter/">Swift进阶 variable with a setter must also have a getter</a><small>1</small></li>
  
    <li><a href="/tags/UI相关/">UI相关</a><small>1</small></li>
  
    <li><a href="/tags/Xcode-环境配置/">Xcode&amp;环境配置</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Tips/">iOS Tips</a><small>5</small></li>
  
    <li><a href="/tags/主页维护记录/">主页维护记录</a><small>2</small></li>
  
    <li><a href="/tags/其他技术/">其他技术</a><small>4</small></li>
  
    <li><a href="/tags/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/tags/开发环境相关/">开发环境相关</a><small>3</small></li>
  
    <li><a href="/tags/悟/">悟</a><small>1</small></li>
  
    <li><a href="/tags/测试小样/">测试小样</a><small>1</small></li>
  
    <li><a href="/tags/环境、配置相关/">环境、配置相关</a><small>3</small></li>
  
    <li><a href="/tags/研究随笔/">研究随笔</a><small>2</small></li>
  
    <li><a href="/tags/视频相关/">视频相关</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
    <li><a href="/tags/重构、模式、架构/">重构、模式、架构</a><small>5</small></li>
  
    <li><a href="/tags/问题解决和思考/">问题解决和思考</a><small>4</small></li>
  
    <li><a href="/tags/高效OC编程/">高效OC编程</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 桂庆
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>