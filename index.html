<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kenny 肉桂的主页</title>
  <meta name="author" content="桂庆">
  
  <meta name="description" content="Kenny 肉桂的主页 记录自己的进步">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Kenny 肉桂的主页"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kenny 肉桂的主页" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Kenny 肉桂的主页</a></h1>
  <h2><a href="/">记录自己的进步</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-21T09:43:06.000Z"><a href="/2016/07/21/Vim/Vim实践Tips-三/">2016-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/21/Vim/Vim实践Tips-三/">Vim实践Tips(三)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_10_使用计数做一些简单的计算">Tip 10 使用计数做一些简单的计算</h2><p>大多数命令模式下的指令能够和计数搭配使用.我们可以利用这个特性做一些简单的运算.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this character is 5</span><br></pre></td></tr></table></figure>
<p><code>&lt;C-a&gt;</code> 增加计数 (Ctrl+a)<br><code>&lt;C-x&gt;</code> 减少计数 (Ctrl+x)<br>他们可以可数字搭配使用,例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this character is 16 &#34; 10&#60;C-a&#62;</span><br></pre></td></tr></table></figure>
<p>这个<c-a> 如果是在数字字符上,那么就会给他增加数字.如果没有在数字上,那么它会在这行中查找数字,并且跳转到数字上.如果没有那么就不会做任何操作.</c-a></p>
<p>例如下面有一段 css 代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.blog, .news &#123; background-image: url(/sprite.png); &#125;&#10;.blog &#123; background-position: 0px 0px &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们要复制最后一行,然后做一些改变:</p>
<ol>
<li>把单词 <code>blog</code> 换成 <code>news</code></li>
<li>把 <code>0px</code> 换成 <code>-180px</code></li>
</ol>
<p>实现1,可以使用 <code>yyp</code> 然后使用 <code>cw</code> 修改单词.<br>那么2怎么实现呢?</p>
<p>第一种方式是: <code>f0</code>, 然后 <code>i</code> 进入插入模式,输入<code>-18</code>,然后<code>&lt;Esc&gt;</code><br>但是我们的光标不在数字上,那么需要额外的跳转.而 <code>&lt;C-x&gt;</code> 可以自动给我们找到数字.<br>所以,直接 <code>180&lt;C-x&gt;</code> 更快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.blog &#123; background-position: -180px 0px &#125; &#34;180&#60;C-x&#62;</span><br></pre></td></tr></table></figure>
<h2 id="Tip_11_如果可以重复,就别计数">Tip 11 如果可以重复,就别计数</h2><p>我们可以通过提供个数字来减少完成特定任务所需要的按键.但是这不代表我们就该这么做.还是应该思考下到底该重复还是该计数.</p>
<p>假设我们有下面的文字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delete more than one word</span><br></pre></td></tr></table></figure>
<p><code>d2w</code>  和 <code>2dw</code> 都能完成任务.</p>
<ul>
<li><code>d2w</code> 是<code>d</code>, 然后加上<code>2w</code> 的 <code>motion</code> ,理解为: 删除两个单词</li>
<li><code>2dw</code>是2次执行 <code>dw</code> ,理解为: 删除一个单词,执行两次</li>
</ul>
<p>现在让我们想想一个替换方案: <code>dw.</code> 删除一个单词,然后重复之.</p>
<h3 id="讨论几种方式-">讨论几种方式.</h3><p>其实<code>d2w</code>和<code>2dw</code> 没有区别,如果执行之后,按 <code>u</code> ,都会恢复两个单词.如果按<code>dot</code>,将重复删除后两个单词.<br>如果我们要删除下一个单词(总共三个)那我们就需要先<code>u</code>(恢复两个单词),然后<code>d3w</code>.这还是比较麻烦的.<br><code>dw.</code> 按<code>u</code>,会恢复一个单词,如果删除下个单词,只需要重新按<code>dot</code>即可.<br>在这种情况下,重复的优势更明显.</p>
<p>如果我要删除6个单词呢? 我可以 <code>d6w</code> 或者<code>6dw</code>.或者 <code>dw.....</code> ,当然,前者有更少的按键.但是有个问题在这:我们需要数一下单词的数量,而且如果错误了,<code>u</code>会恢复<code>6</code>个单词.而<code>dw.....</code>如果出现错误,<code>u</code>一下,只是恢复一个单词.我们可以更好的控制这个过程.</p>
<p>记住我们的”咒语”: 操作,重复,撤销. </p>
<h3 id="必要时使用计数">必要时使用计数</h3><p>下面的文字,如果我要把 <code>a couple of</code> 换成 <code>some more.</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I have a couple of questions.&#10;I have some more questions. &#34;&#25353;&#38190;&#20381;&#27425;&#26159; c3wsome more</span><br></pre></td></tr></table></figure></p>
<p>在这个场景下,使用dot命令没有什么意义.即使重复了,最后还要按<code>i</code>进入插入模式.这样太笨拙了,所以我还是愿意使用计数.</p>
<p>计数还有个好处,就是能够有个条理清楚的恢复操作.比如我<code>d3w</code>,<code>u</code>就会恢复3个单词</p>
<h1 id="Tip_12_征服结合命令">Tip 12 征服结合命令</h1><p>Vim的强大源于操作符和移动命令的结合.</p>
<h3 id="操作符+移动=操作">操作符+移动=操作</h3><p><code>d{motion}</code> 可以使用<code>dl</code>删除一个字符,<code>daw</code>删除整个单词,<code>dap</code>删除整段.<br><code>c{motion}</code> 和 <code>y{motion}</code>和上面类似</p>
<p>操作符和移动的结合,可以认为是一种语法.第一条规则很简单:一个动作由一个操作符和一个移动组成.学习新的操作符就像学习Vim的词汇表.只要我们遵循简单的语法,随着词汇量增加,我们就能表达更多想法.</p>
<p>假设我们已经知道了通过 daw 删除一整个单词.然后,我们学到了 <code>gU</code>,这也是一个操作符.所以,我们就能通过gUaw把当前单词转换成大写.</p>
<p>再假设我们知道了<code>ap</code>(一整段motion},然后我们就能合成新的操作:<br><code>dap</code> 删除一整段 <code>gUap</code> 让一整段大写.</p>
<p><code>Vim</code>  的语法还有个规则:如果一个操作符被重复输入,那么<code>motion</code>就等于当前行.例如:<br>-<code>dd</code>   删除当前行<br>-<code>&gt;&gt;</code>  缩进当前行<br>-<code>gUgU</code> 或者 <code>gUU</code> 大写当前行 g是后面操作符的一个前缀</p>
<p>Vim的操作符命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25805;&#20316;&#31526;        &#25928;&#26524;&#10;c             Change &#25913;&#21464;&#10;d             Delete &#21024;&#38500;&#10;y             Yank into register &#22797;&#21046;&#21040;&#23492;&#23384;&#22120;&#10;g~            Swap case &#20999;&#25442;&#22823;&#23567;&#20889;&#10;gu            make lowercase &#23567;&#20889;&#10;gU            make upppercase &#22823;&#20889;&#10;&#62;             shift right &#21491;&#31227;&#10;&#60;             shift left &#24038;&#31227;&#10;=             autoindent &#33258;&#21160;&#32553;&#36827;&#10;!             Filter &#123;motion&#125; lines through an external program</span><br></pre></td></tr></table></figure>
<h3 id="拓展Vim整合的力量">拓展Vim整合的力量</h3><p>Vim标准的操作符相对来说比较少,但是我们可以定义新的.</p>
<h3 id="使用现有的操作符自定义移动">使用现有的操作符自定义移动</h3><p>Vim标准的移动命令已经很全面,但是我们还可以增加新的移动和文本对象.</p>
<h3 id="待决模式">待决模式</h3><p>除了明显的插入,命令和底行模式.Vim还有些容易被忽略的模式.待决模式( Operator-Pending mode )就是其中的一个.我们每天都大量使用它,但是每次都持续一小段时间.例如<code>dw</code>,这个模式仅仅持续了你按下<code>d</code>到按下<code>w</code>这中间的这个时间.</p>
<p>如果我们把Vim看做是一个有限状态机.那么待决模式就是仅接受移动命令的状态.当一个操作符被触发的时候,这个状态被激活,在输入移动命令之前,Vim不会做任何操作.当待决模式被激活后,我们可以通过<esc>就可以中断,返回命令模式.</esc></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-19T09:40:15.000Z"><a href="/2016/07/19/Vim/Vim实践Tips(二)/">2016-07-19</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/19/Vim/Vim实践Tips(二)/">Vim实践Tips(二)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_5_手动查找和替换">Tip 5 手动查找和替换</h2><p>下面每一行中都有 <code>content</code> 这个单词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;...We&#39;re waiting for content before the site can go live...&#10;&#10;...If you are content with this, let&#39;s go ahead with it...&#10;&#10;...We&#39;ll launch as soon as we have the content...</span><br></pre></td></tr></table></figure>
<p>如果我们想把所有的 <code>content</code> 替换成 <code>copy</code>, 那么可以很简单的想到替换命令.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;:%s/content/copy/g</span><br></pre></td></tr></table></figure>
<p> 但是有时候我们并不想全局替换掉.</p>
<h3 id="懒惰点:不做输入的查找">懒惰点:不做输入的查找</h3><p> 你也许已经猜到<code>.</code>是我最喜欢的单键<code>Vim</code>命令.第二喜欢的是 <code>*</code>,它可以搜索处于光标下面的单词.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;...We&#39;re waiting for copy before the site can go live...&#10;&#10;...If you are copy with this, let&#39;s go ahead with it...&#10;&#10;...We&#39;ll launch as soon as we have the content...</span><br></pre></td></tr></table></figure>
<p> 首先将光标置于 <code>content</code> 上面,然后用<code>*</code>命令去查找它,这时候将发生两个事情:</p>
<ol>
<li><p>光标将跳转到下个匹配处(即下个 <code>content</code> 单词) </p>
</li>
<li><p>所有出现匹配项的地方将高亮显示 (如果没有,使用 <code>:set hls</code> .</p>
</li>
</ol>
<p>上面两件事情发生之后,我们就可以使用 <code>n</code> 命令跳转到下一个.这时候,使用 <code>*nn</code> 可以循环所有匹配,然后光标转到我们开始进行搜索的地方</p>
<h3 id="让更改变得可重复">让更改变得可重复</h3><p>当我们的光标置于 <code>content</code> 的开始位置的时候,我们准备去更改它.这包含两个步骤:</p>
<ol>
<li><p>删除单词 <code>content</code> </p>
</li>
<li><p>输入修改的内容. <code>cw</code> 删除到单词结尾命令,并且进入插入模式.</p>
</li>
</ol>
<p>然后我们输入 <code>copy</code> 这个单词. Vim 将记录我们的键盘点击,直到我们离开插入模式,所以, <code>cwcopy&lt;Esc&gt;</code> 将会被记录为一个单个命令.通过使用<code>.</code>就可以重复上面的操作.</p>
<h2 id="Tip6_Dot公式">Tip6 Dot公式</h2><p>在 Tip2中,我们试着将每个句子后面加<code>;</code> 最后,我们通过 <code>j.</code> 进行重复操作.</p>
<p>在 Tip3中,我们将每个<code>+</code>前后添加空格.  最后,我们通过 <code>;.</code> 进行重复操作</p>
<p>在 Tip5中,我们将 <code>content</code> 替换成 <code>copy</code>,最后,我们通过 <code>n.</code> 进行重复操作.</p>
<h3 id="理想的状态:_一个按键负责移动,一个按键负责执行操作-">理想的状态: 一个按键负责移动,一个按键负责执行操作.</h3><p> 在上面所有的操作中 . 重复最后的更改.这不是他们全部的共同点,我们都还用了一个键去移动光标.这已经是一个不能再好的情况了.我们在将来的编辑中,可以反复看到这个编辑模式.为了方便,我们把这个模式成为 Dot公式 (Dot Formula)</p>
<h2 id="Tip7_拿开你的笔刷">Tip7 拿开你的笔刷</h2><p><code>Normal Mode</code> (命令模式) 可以类比为一个画家,把笔刷离开画布.这时候,他可以休息,可以构思.同理,程序员也可以在 <code>Normal Mode</code> 中进行思考,组织自己的思路.当我们要改变的时候,也不用非得进入插入模式.在 <code>Normal Mode</code>中,我们可以格式化我们的代码,复制,或者移动他们.</p>
<h2 id="Tip8_强化你的撤销">Tip8 强化你的撤销</h2><p>在其他编辑器中,通过在输入一些东西之后进行撤销,可以撤销我们最后输入的单词或者字符.然后在 Vim 中,我们设置可以调整撤销命令的粒度.</p>
<p><code>u</code> 这个命令可以触发撤销命令.它可以撤销包括Normal,Visual还有 Command-Line 模式的更改.当然,也包括在插入模式下的文本输入或者删除.所以我们可以说: <code>i{ 插入一些更改}&lt; Esc&gt;</code>  构成了一个改变. 然后一次<code>u</code> 就可以撤销这个改变.</p>
<p>另外,插入模式中,如果使用了上下左右箭头,那么就相当于在 NormalMode下使用了 <code>hjkl</code>.区别就是我们不用离开插入模式,但是这些操作,会被记录到点公式 (Dot Fomula)中.</p>
<h2 id="Tip9_创建可重复的改变">Tip9 创建可重复的改变</h2><p>vim将重复操作进行了优化,为了利用这个特性.我们需要留心怎么创建可重复的改变</p>
<p>在 Vim 中,做一件事通常有很多方式.但是衡量”好”的方式的机制就是:更少的键盘敲击.</p>
<p>假设我们的光标在 <code>h</code> 这个字母上,我们想要删除单词 <code>nigh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh</span><br></pre></td></tr></table></figure>
<h3 id="1-_向后删除">1. 向后删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh &#34;&#24320;&#22987;&#10;&#10;The end is h &#34;db  &#20174;&#20809;&#26631;&#20301;&#32622;&#21024;&#38500;&#21333;&#35789;&#30340;&#21069;&#38754;&#37096;&#20998;&#10;&#10;The end is  &#34;x &#21024;&#38500;&#24403;&#21069;&#20809;&#26631;&#30340;&#23383;&#31526;</span><br></pre></td></tr></table></figure>
<h3 id="2-_向前删除">2. 向前删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh   &#34;&#24320;&#22987;&#10;&#10;The end is nigh   &#34;b  &#21521;&#21518;&#31227;&#21160;&#20809;&#26631;&#19968;&#20010;&#21333;&#35789;&#10;&#10;The end is        &#34;dw &#21521;&#21069;&#21024;&#38500;&#19968;&#20010;&#21333;&#35789;</span><br></pre></td></tr></table></figure>
<h3 id="3-_删除整个单词">3. 删除整个单词</h3><p>上面两个解决方案都牵涉到了一些准备工作,例如移动.其实,利用<code>aw</code> 命令可以更精准高效的完成我们的需求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end ais nigh   &#34;&#24320;&#22987;&#10;&#10;The end is &#34;daw</span><br></pre></td></tr></table></figure>
<h3 id="4-_哪一个是最可重复的">4. 哪一个是最可重复的</h3><p>上面我们使用了三种方式进行删除一个单词.每种方式中,我们都是按了三个键,那么那种方式是更好的呢?</p>
<p>记住, Vim 优化了重复.那么检验好坏的标准就是重复.下面使用dot 命令来检验三种方式,通过测试发现:</p>
<ul>
<li><p>第一种方式: <code>.</code> 等价于 <code>x</code> (<code>db</code> 是改变操作. <code>x</code> 也是改变操作)</p>
</li>
<li><p>第二种方式: <code>.</code> 等价于 <code>dw</code> (<code>b</code> 是纯移动, <code>dw</code> 是改变操作)</p>
</li>
<li><p>第三种方式: <code>.</code> 等价于 <code>daw</code> (<code>daw</code>是改变操作)</p>
</li>
</ul>
<p>看起来<code>2</code> <code>3</code> 都是挺有用的,但是有个细节 <code>2</code>删除一个单词,但是不会删除对应的空格,表象上来看就是不会移动光标到下个单词上,那么这时候, <code>.</code>这个命令就没什么意义. <code>3</code> 会把要删除的单词附带空格删除,同时光标停留在 <code>is</code> 的结尾.那么<code>.</code>这个操作就能继续删除一个单词. (我强烈建议自己动手试试看)</p>
<p>﻿</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-18T07:12:36.000Z"><a href="/2016/07/18/Vim/Vim实践Tips(一)/">2016-07-18</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/18/Vim/Vim实践Tips(一)/">Vim实践Tips(一)</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="Tip_1_dot_命令">Tip 1 dot 命令</h1><p>说明: . dot 重复上个命令的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line one&#10;&#10;line two&#10;&#10;line three &#10;&#10;line four</span><br></pre></td></tr></table></figure>
<p><code>x</code> :删除当前光标下的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> one &#34; x . . .  x &#21024;&#38500;, . &#37325;&#22797;&#10;&#10;line two&#10;&#10;line three &#10;&#10;line four</span><br></pre></td></tr></table></figure>
<p>如图:<br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/1xdotdot.gif" alt="dot 命令的使用"></p>
<h2 id="几个小提示:">几个小提示:</h2><h3 id=":set_nu_显示行号_:set_nonu_关闭行号显示">:set nu 显示行号 :set nonu 关闭行号显示</h3><p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/2setnu.gif" alt="显示和关闭行号"></p>
<h3 id=":3,5_co_8_将9到12行的内容输出到8行">:3,5 co 8 将9到12行的内容输出到8行</h3><p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/003line_copy.gif" alt="输出范围到领一行"></p>
<h3 id=":3,5_de_删除3到5行的内容">:3,5 de 删除3到5行的内容</h3><p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/004delete.gif" alt="删除范围"></p>
<p><code>&gt;G</code> 增加从当前行到文件末尾所有行的缩进.同理,使用 . 可以重复增加缩进</p>
<p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/005_intent.gif" alt="重复缩进"></p>
<p>还可以利用 j. 做成下面的布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line one&#10;&#10;&#9;line two&#10;&#10;&#9;&#9;line three &#10;&#10;&#9;&#9;&#9;line four</span><br></pre></td></tr></table></figure>
<p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/007_jdot.gif" alt="梯形缩进"></p>
<h1 id="Tip_2_不要重复">Tip 2 不要重复</h1><p>例如,我们想要在下面所有的行后面加一个分号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1&#10;&#10;var bar = &#39;bar&#39;&#10;&#10;var foobar = foo + bar</span><br></pre></td></tr></table></figure>
<p>使用 <code>$</code> 移动到行末尾,<code>a</code>追加然后输入<code>;</code> ,然后按<code>&lt;Esc&gt;</code>返回命令模式.这算完成了第一行</p>
<p>如果对下面两行也应用这个,就应该: <code>j$.</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#10;&#10;var bar = &#39;bar&#39;; &#34;j$.&#10;&#10;var foobar = foo + bar; &#34;j$.</span><br></pre></td></tr></table></figure>
<p>虽然这样也能完成,但是还是差点意思.还是有提升空间的.</p>
<h3 id="减少无关的移动">减少无关的移动</h3><p><code>a</code> 是在当前光标位置后面追加,并自动切换到插入模式</p>
<p><code>A</code> 是在当前行末进行追加,并自动切换到插入模式 相当于 <code>$a</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#9;&#34; A;&#60;Esc&#62;&#10;&#10;var bar = &#39;bar&#39;; &#34; j.&#10;&#10;var foobar = foo + bar; &#34; j.</span><br></pre></td></tr></table></figure>
<p><code>d</code> 删除，不能单独用，得跟后续操作符，比如 <code>dd</code> 是删除一整行，<code>d$</code> 是删除直到行的末尾</p>
<p><code>x</code> 删除当前光标下的单个字符</p>
<p><code>c</code> 跟 <code>d</code> 类次，但是删除完成后会进入插入模式</p>
<p><code>c</code> 和 <code>d</code> 都要加入<code>motion</code> <code>motion</code>类似是 <code>w</code> <code>b</code> 等这些</p>
<p><code>23,35 co 66</code> 复制</p>
<p><code>23,35 m 66</code> 剪切</p>
<p><code>23,35 de</code> 删除</p>
<p>几个一个顶俩的快捷键</p>
<p><code>C c$</code> 删除到行末尾,并进入插入模式</p>
<p><code>s cl</code> 替换当前字符: c加motion,l 一个字符</p>
<p><code>S ^C</code> 删除整个行 ^移动到行首,C删除整行</p>
<p><code>I ^i</code> 到行首进行插入</p>
<p><code>A $a</code> 到行尾进行插入</p>
<p><code>o A&lt;CR&gt;</code> 进入下一行,并进入插入模式 <cr>是回车的意思</cr></p>
<p><code>O ko</code> 进入上一行,然后插入</p>
<h2 id="Tip_3_退一步,进三步">Tip 3 退一步,进三步</h2><figure class="highlight"><figcaption><span>foo = "method("+argument1+","+argument2+")";```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#19978;&#38754;&#30340;&#20195;&#30721;&#30475;&#30528;&#19981;&#22826;&#33298;&#26381;,&#22240;&#20026;&#22312;&#25105;&#20204;&#21360;&#35937;&#20013;,&#21152;&#21495;&#20004;&#36793;&#24212;&#35813;&#26377;&#31354;&#26684;.&#37027;&#20040;&#25105;&#20204;&#26469;&#30475;&#24590;&#20040;&#20197;Vim&#30340;&#26041;&#24335;&#23436;&#25104;&#36825;&#20010;&#20219;&#21153;:&#10;&#10;`f+` &#26597;&#25214;&#26368;&#36817;&#30340;`+` , `s` &#26367;&#25442;`+` &#20026; `&#31354;&#26684;+&#31354;&#26684;`&#10;&#10;```var foo = &#34;method(&#34; + argument1+&#34;,&#34;+argument2+&#34;)&#34;;</span><br></pre></td></tr></table></figure>
<p>对于后面的,我们当然可以使用 <code>f+</code> 然后 <code>.</code> 重复替换,完成任务.</p>
<p>但是这里有个新的操作符 <code>;</code> 这个 <code>;</code> 可以重复执行最近的查找操作.<code>f+</code>就是一个查找操作.所以,对于后面的<code>+</code> ,我们可以通过 <code>;.</code> 依次完成替换.</p>
<h2 id="Tip4_操作,重复,撤销">Tip4 操作,重复,撤销</h2><p>通过以上的几个tip,我们学会了,先操作,然后另其重复执行,借此完成一些重复任务.</p>
<p>但是有时候,我们可能在反复的重复操作中,按多了.例如 tip2 中的 j.j.j. 很可能顺序按错了. 如果出现错误,那么我们就可以在出错的时候按 u 来撤销操作.又或者,Tip3中的;按多了(意味着移动的太过了)那么可以使用,来跳回去.</p>
<p>通过以上的描述,能看出来,不同的误操作,对应着不同的撤销方式.下面是个参考表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#24847;&#22270;&#9;&#9;&#9;&#9;&#25805;&#20316;&#9;&#9;&#9;&#9;&#37325;&#22797;&#9;&#9;&#25764;&#38144;&#10;&#10;&#25913;&#21464;&#28857;&#19996;&#35199;&#9;&#9;&#9;&#123;edit&#125;&#9;&#9;&#9;.&#9;&#9;u&#10;&#10;&#34892;&#20869;&#26597;&#25214;&#19979;&#20010;&#23383;&#31526;&#9;f&#123;char&#125;/t&#123;char&#125;&#9;&#9;;&#9;&#9;,&#10;&#10;&#34892;&#20869;&#26597;&#25214;&#21069;&#19968;&#20010;&#23383;&#31526;&#9;F&#123;char&#125;/T&#123;char&#125;&#9;&#9;;&#9;&#9;,&#10;&#10;&#22312;&#25991;&#26723;&#20869;&#26597;&#25214;&#19979;&#20010;&#21305;&#37197;&#9;/pattern&#60;CR&#62; &#9;&#9;n&#9;&#9;N&#10;&#10;&#22312;&#25991;&#26723;&#20869;&#26597;&#25214;&#21069;&#20010;&#21305;&#37197;&#9;?pattern&#60;CR&#62;&#9;&#9;n&#9;&#9;N&#10;&#10;&#25191;&#34892;&#26367;&#25442;&#9;&#9;:s/target/replacement&#9;&#38;&#9;&#9;u&#10;&#10;&#25191;&#34892;&#19968;&#31995;&#21015;&#25913;&#21464;&#9;&#9;qx&#123;changes&#125;q&#9;&#9;@x&#9;&#9;  u</span><br></pre></td></tr></table></figure>
<p><code>f</code> 和 <code>t</code> 的区别是 <code>f</code> 停留光标在查找字符,<code>t</code>光标停留在查找字符之前</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-14T07:25:06.000Z"><a href="/2016/07/14/视频相关/视频裁剪/">2016-07-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/14/视频相关/视频裁剪/">视频裁剪</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="AVAsset">AVAsset</h3><p>AVAsset是一个表现音视频媒体的抽象类.AVAsset对象给我们开发提供了媒体文件的访问接口.<br>这个 AVAsset 可以通过文件创建,也可以是来自用户相册目录的.如果获得了一个视频文件的 AVAsset,我们就可以从中获取静态图片,转换格式,或者是裁剪内容.</p>
<p>通过以下代码,获得特定位置的视频文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString * videoPath = @&#34;a video file path&#34;;&#10;AVAsset *anAsset = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:videoPath] options:nil];</span><br></pre></td></tr></table></figure>
<p>其中 options 是一个字典,这个字典只有一个 key-value:<br><code>AVURLAssetPreferPreciseDurationAndTimingKey</code> value 是 <code>YES</code> 或者 <code>NO</code></p>
<p>这个是设置时间精确度的,如果设置为 YES, 那么会造成很大的开销,但是可以保证操作的精度,对于我的裁剪操作,不用设置.因为我的业务中,裁剪范围是用户滑块操作的,本来精度就要求不高.<br>传递 nil 和 传递 NO, 两者等效.<br>特别的,当进行视频合成操作的时候,需要设置这个字典,并将 value 设置为 <code>YES</code>,因为如果精度不够,可能造成音视频不同步等问题.</p>
<h3 id="AVAssetExportSession">AVAssetExportSession</h3><p>AVAssetExportSession 是一个控制 Asset 异步导出的对象.可以实现裁剪视频,转换格式等需求. 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportSession_ = [[AVAssetExportSession alloc]&#10;                            initWithAsset:anAsset presetName:AVAssetExportPreset960x540]</span><br></pre></td></tr></table></figure>
<p>这个<code>presetName</code> 是系统提供的预设,有一些常用的视频分辨率和视频质量控制的选项.可以按住<code>command</code>自行查看.另外.如果预设的分辨率不能满足需求,我们还可以自定义任意分辨率,这个将在我以后的文章中进行说明.</p>
<p>然后就是配置<code>AVAssetExportSession</code>,下面分别配置了<code>导出路径</code>,<code>导出文件格式</code>,<code>截取范围</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportSession_.outputURL = tempVideoURL;&#10;exportSession_.outputFileType = AVFileTypeMPEG4;&#10;exportSession_.timeRange = [self videoTimeRange:anAsset];</span><br></pre></td></tr></table></figure>
<p>需要说明的是这个截取范围的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(CMTimeRange)videoTimeRange:(AVAsset*)anAsset&#123;&#10;    CMTime start = CMTimeMakeWithSeconds(self.videoRange.startTime, anAsset.duration.timescale);&#10;    CMTime duration = CMTimeMakeWithSeconds(self.videoRange.duration, anAsset.duration.timescale);&#10;    CMTimeRange range = CMTimeRangeMake(start, duration);&#10;    return range;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><code>CMTime</code> 是一个结构体对象,常用的两个值是: <code>value</code> 和 <code>timescale</code>. 两者的关系可以表示为: <code>value/timescale=seconds</code>.</p>
<p>在上面的方法中,我将来自滑块的值(秒为单位),转换成了<code>CMTime</code>然后构造了一个<code>CMTimeRange</code> 对象.</p>
<p>最后进行导出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exportSession_ exportAsynchronouslyWithCompletionHandler:^&#123;&#10;                switch (exportSession_.status) &#123;&#10;                   case AVAssetExportSessionStatusUnknown: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusWaiting: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusExporting: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusCompleted: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusFailed: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusCancelled: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;               &#125;&#10;           &#125;];</span><br></pre></td></tr></table></figure>
<p>可以对各种状态进行判断.进而采取不同的操作.通常关心的是<code>Failed</code> 和<code>Completed</code> ,前者给用户提示,后者进行后续操作.</p>
<p>到此,就完成了一段视频的裁剪操作.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-18T15:28:19.000Z"><a href="/2016/06/18/ReactiveCocoa/RACObserve-和-rac-textSignal-的搭配使用/">2016-06-18</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/18/ReactiveCocoa/RACObserve-和-rac-textSignal-的搭配使用/">RACObserve 和 rac_textSignal 的搭配使用</a></h1>
  

    </header>
    <div class="entry">
      
        <p>项目中有个小需求,文本框与按钮绑定.当文本框内容符合规则的时候,按钮才会可用.把判定条件修改一下,代码如下:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> RAC(self.loginButton,enabled)  = [self.textFiled.rac_textSignal  map:^id(NSString *value) &#123;&#10;    return @(value.length&#62;3);&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>但是如果在发送请求之后,通过代码清除了文本框的内容,按钮并不会改变状态. </p>
<p> 想到了, 应该是这个 <code>rac_textSignal</code> 出现问题了.<br> 看一下它的实现:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> - (RACSignal *)rac_textSignal &#123;&#10;&#9;@weakify(self);&#10;&#9;return [[[[[RACSignal&#10;&#9;&#9;defer:^&#123;&#10;&#9;&#9;&#9;@strongify(self);&#10;&#9;&#9;&#9;return [RACSignal return:self];&#10;&#9;&#9;&#125;]&#10;&#9;&#9;concat:[self rac_signalForControlEvents:UIControlEventAllEditingEvents]]&#10;&#9;&#9;map:^(UITextField *x) &#123;&#10;&#9;&#9;&#9;return x.text;&#10;&#9;&#9;&#125;]&#10;&#9;&#9;takeUntil:self.rac_willDeallocSignal]&#10;&#9;&#9;setNameWithFormat:@&#34;%@ -rac_textSignal&#34;, self.rac_description];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>几个关键词的解释:<br><code>defer</code> : 将代码的创建推迟到信号被订阅<br><code>concat</code>: 连接信号,第一个信号必须发送完成，第二个信号才会被激活<br><code>map</code> : 映射,将信号内容转换<br><code>takeUtil</code> :  signalA takeUntil:signalB 当signalB激活之后,停止signalA 的订阅</p>
<p>其实主要的是, 这个 <code>signal</code> 是监听的: <code>UIControlEventAllEditingEvents</code> . 那么也就是说对<code>setter</code> 方式不会触发信号 </p>
<p><code>RACObserve</code> 是一个常用的宏,我们都知道是监听属性值改变的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \&#10;&#9;(&#123; \&#10;&#9;&#9;_Pragma(&#34;clang diagnostic push&#34;) \&#10;&#9;&#9;_Pragma(&#34;clang diagnostic ignored \&#34;-Wreceiver-is-weak\&#34;&#34;) \&#10;&#9;&#9;__weak id target_ = (TARGET); \&#10;&#9;&#9;[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \&#10;&#9;&#9;_Pragma(&#34;clang diagnostic pop&#34;) \&#10;&#9;&#125;)</span><br></pre></td></tr></table></figure>
<p>主要代码是:<code>[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self];</code><br>然后这个<code>rac_valuesForKeyPath</code>的实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer &#123;&#10;&#9;return [[[self&#10;&#9;&#9;rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]&#10;&#9;&#9;map:^(RACTuple *value) &#123;&#10;&#9;&#9;&#9;// -map: because it doesn&#39;t require the block trampoline that -reduceEach: uses&#10;&#9;&#9;&#9;return value[0];&#10;&#9;&#9;&#125;]&#10;&#9;&#9;setNameWithFormat:@&#34;RACObserve(%@, %@)&#34;, self.rac_description, keyPath];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>主要代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]</span><br></pre></td></tr></table></figure>
<p>也就是这个是通过 <code>KVO</code> 实现的. 而 <code>KVO</code> 得实现是通过临时生成一个子类,并重写父类的 <code>setter</code> 方法.这个在官方文档中有说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key-Value Observing Implementation Details&#10;&#10;Automatic key-value observing is implemented using a technique called&#160;isa-swizzling.&#160;&#10;The&#160;isa&#160;pointer, as the name suggests, points to the object&#39;s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.&#160;&#10;When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.&#160;&#10;You should never rely on the&#160;isa&#160;pointer to determine class membership. Instead, you should use the&#160;class&#160;method to determine the class of an object instance.</span><br></pre></td></tr></table></figure>
<h3 id="最终实现">最终实现</h3><p>了解了两者的实现,就可以很容易实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.loginButton,enabled) =[ [RACObserve(self.textFiled, text)  merge:self.textFiled.rac_textSignal ] map:^id(NSString *value) &#123;&#10;     return @(value.length&#62;3);&#10;&#125;];</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-15T06:51:18.000Z"><a href="/2016/06/15/Swift/Swift3-新特性/">2016-06-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/15/Swift/Swift3-新特性/">Swift3 新特性 </a></h1>
  

    </header>
    <div class="entry">
      
        <p>看了一下刚出的 Session 406,简单记录一下关于 Swift3.0相比2.2的改动. 能力有限,若有谬误,欢迎指正 .</p>
<h3 id="简化的_API">简化的 API</h3><ul>
<li>优化将方法名切分,将操作中的动词提取,作为方法名.将其余部分作为参数名.</li>
<li>在不引起歧义的情况下,去掉了重复性的名词.</li>
</ul>
<p>Swift 2.2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var array:Array = [1,2]&#10;&#10;array.appendContentsOf([2,3,4])&#10;array.insert(1, atIndex: 0)&#10;&#10;var url = NSURL(string: &#34;randomLoacation&#34;)!&#10;&#10;if url.fileURL &#123;&#125;&#10;var x = url.URLByAppendingPathComponent(&#34;file.txt&#34;)</span><br></pre></td></tr></table></figure>
<p>Swift 3.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Swift.Array&#10;var array:Array = [1,2]&#10;&#10;array.append(contentsOf: [2,3,4])&#10;array.insert(1, at: 0) //index&#27809;&#26377;&#20160;&#20040;&#29305;&#23450;&#20449;&#24687;,&#21482;&#26159;&#37325;&#22797;&#10;&#10;//Foudation.NSURL&#10;var url = NSURL(string: &#34;randomLoacation&#34;)!&#10;if url.isFileURL &#123;&#125; //&#24847;&#24605;&#26356;&#26126;&#30830;&#10;var x = url.appendingPathComponent(&#34;file.txt&#34;)</span><br></pre></td></tr></table></figure>
<h3 id="一致的函数参数标签">一致的函数参数标签</h3><p>原来2.2中, 第一个参数标签可以省略.类似这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func myFunction(a: Int , b: Int , c: Int)&#123;&#10;&#10;&#125;&#10;&#10;myFunction(42, b: 57, c: 39)</span><br></pre></td></tr></table></figure>
<p>在 3.0 中,上面的用法会报错. 需要显式写出标签,类似这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func myFunction(a: Int , b: Int , c: Int)&#123;&#10;    &#10;&#125;&#10;&#10;myFunction(a: 10, b: 10, c: 10)</span><br></pre></td></tr></table></figure>
<p>当然,如果实在不想写,可以在声明的时候使用 <code>_</code> .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func myFunction(_ a: Int , b: Int , c: Int)&#123;&#10;    &#10;&#125;&#10;&#10;myFunction(10, b: 10, c: 10)</span><br></pre></td></tr></table></figure>
<h3 id="移动_Where_语句到函数声明的结尾">移动 Where 语句到函数声明的结尾</h3><p>在 Swift2.2中,泛型约束语句<code>Where</code>需要放到泛型的<code>&lt;&gt;</code>中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func anyCommon&#60;T: SequenceType, U: SequenceType&#10;    where T.Generator.Element : Equatable,&#10;    T.Generator.Element == U.Generator.Element&#62;(lhs: T, rhs: U) -&#62; Bool&#123;&#10;    print(&#34;here&#34;)&#10;    return true;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Swift3.0中,将其提取到声明之后:<br>代码是参考的 Session 中的代码,但是本人用 Xcode8.0的 Playground 报错.但是主旨不会错,就是将<code>Where</code>语句提取出来.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func anyCommons&#60;T: Sequence, U: Sequence&#62;(lhs: T, rhs: U) -&#62; Bool&#10;    where T.Element: Equatable,T.Element == U.Element&#10;&#123;&#10;    print(&#34;here&#34;)&#10;    return true;&#10;    &#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结果未使用警告的方法">结果未使用警告的方法</h3><p>对于一个没有使用的函数返回值(或者自定义的变量值),编译器都会给你一个警告.因为既然你认为有返回值, 而你却没有使用.这可能就是你忘记了.这种操作可能会造成你编码的 bug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func plusOne(_ a : Int) -&#62;Int&#123;&#10;         print(a)&#10;         return a+1&#10;     &#125;&#10;     &#10;     plusOne(3) //&#24471;&#21040;&#35686;&#21578; Result of call to &#39;plusOne&#39; is unused</span><br></pre></td></tr></table></figure>
<p>但是一些情况下.我们确实不需要用到这个返回值,而且仅仅是为了函数的一个副作用( side effect) 而去调用函数. 例如,上面代码中的<code>print(a)</code>.这就是我调用函数的目的.<br>为了消除警告,可以使用如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func plusOne(_ a : Int) -&#62;Int&#123;&#10;    print(a)&#10;    return a+1&#10;&#125;&#10;&#10;_ =  plusOne(3)</span><br></pre></td></tr></table></figure>
<p>或者使用标记 <code>@discardableResult</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult&#10;func plusOne(_ a : Int) -&#62;Int&#123;&#10;    print(a)&#10;    return a+1&#10;&#125;&#10;&#10;plusOne(3)</span><br></pre></td></tr></table></figure>
<h3 id="索引集合">索引集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let collection = [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;]&#10;&#10;var i = collection.startIndex</span><br></pre></td></tr></table></figure>
<p>在 Swift 2.2 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift 2 : var next = i.successor()</span><br></pre></td></tr></table></figure>
<p>在 Swift 3.0 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var next = collection.index(after: 2)</span><br></pre></td></tr></table></figure>
<h3 id="浮点型和数值型">浮点型和数值型</h3><ul>
<li>Float,Double,Float80 和 CGFloat统一使用新的浮点协议( Floating Point Protocol )</li>
<li>提供 IEEE-754 相关的属性和方法 (IEEE 754 标准是IEEE二进位浮点数算术标准（IEEE Standard for Floating-Point Arithmetic）的标准编号  ，等同于国际标准ISO/IEC/IEEE 60559[2])</li>
<li>允许在所有的浮点类型上使用算法泛型(水平有限,原文是:permits algrithms to be gerneric over all floating point types)</li>
</ul>
<p>用 PI 来举个例子:<br>Swift 2.2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let v = 2 * Float(M_PI)</span><br></pre></td></tr></table></figure>
<p>而在 Swift3.0中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let v = 2 * Float.pi</span><br></pre></td></tr></table></figure>
<p>如果第一个操作数是浮点数,还可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let anotherV = 2.0 * .pi / 180</span><br></pre></td></tr></table></figure>
<h3 id="隐式解包可选">隐式解包可选</h3><p>在 Swift2.2中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func f(value: Int!)&#123;&#10;    let x = value + 1 // x &#26159; Int &#31867;&#22411; - &#24378;&#21046;&#35299;&#21253;&#10;    let y = value     // y &#26159; Int!&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Swift 3.0 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func f(value: Int!)&#123;&#10;    let x = value + 1 // x &#26159; Int &#31867;&#22411; - &#24378;&#21046;&#35299;&#21253;&#10;    let y = value     // y &#26159; Int?&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体参考:<br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md" target="_blank" rel="external">SE-0054</a></p>
<h3 id="一些细节的增强">一些细节的增强</h3><ul>
<li>当前文件访问级别,新增的权限控制关键字 <code>fileprivate</code> <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md" target="_blank" rel="external">SE-0025</a></li>
<li><code>case</code>中的标签可以使用多种模式 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0043-declare-variables-in-case-labels-with-multiple-patterns.md" target="_blank" rel="external">SE-0043</a></li>
<li>泛型别名 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md" target="_blank" rel="external">SE-0048</a></li>
<li>引用Objective-C 的 key-paths <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md" target="_blank" rel="external">SE-0062</a></li>
<li>引用 Objective-C中属性的 getter 和 setter <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md" target="_blank" rel="external">SE-0064</a></li>
<li>协议和协议拓展的别名 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md" target="_blank" rel="external">SE-0092</a><h3 id="移除的功能">移除的功能</h3></li>
</ul>
<ol>
<li>函数柯里化<a href="http://www.cocoachina.com/ios/20141110/10166.html" target="_blank" rel="external">Currying介绍</a></li>
<li>函数参数中的 <code>var</code> <a href="http://www.swiftcafe.io/2016/05/05/swift3-var/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">详细介绍</a></li>
<li>去掉 <code>++</code> 和 <code>--</code> 操作符</li>
<li>C 风格的for循环</li>
<li>通过元组的形式传递函数参数列表 .<a href="http://www.paulrobinson.net/function-parameters-are-tuples-in-swift/" target="_blank" rel="external">详细介绍</a></li>
</ol>
<p>对第5条做一个说明:<br>在 swift 2.2 中,我们可以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let param = (20,&#34;kenny&#34;,&#34;male&#34;)&#10;&#10;func personInfo(age: Int ,_ name: String ,_ gender: String)&#123;&#10;&#10;&#125;&#10;&#10;personInfo(param)&#10;&#10;//&#20063;&#21487;&#20197;&#19981;&#30465;&#30053;&#26631;&#31614;&#10;&#10;let param = (age:20, name:&#34;kenny&#34;, gender:&#34;male&#34;)&#10;&#10;func personInfo(age age: Int , name: String , gender: String)&#123;&#10;&#10;&#125;&#10;&#10;personInfo(param)</span><br></pre></td></tr></table></figure>
<p>这个语法在 Swift3.0中被去掉了.原因是这么传递,可能会和有一个元组类型参数的函数混淆.</p>
<p>参考 : WWDC 2016 Session 402 What’s new in Swift</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-14T02:18:56.000Z"><a href="/2016/06/14/Swift/在-Swift-中使用DEBUG标记/">2016-06-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/14/Swift/在-Swift-中使用DEBUG标记/">在 Swift 中使用DEBUG标记</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在 OC 中,我们经常会使用 <code>DEBUG</code> 标记来区分开发版本和发行版本,例如,控制调试信息的打印.</p>
<p>但是在使用 Swift 之后,我们发现<code>DEBUG</code> 不能正常工作.原因是 Swift 中没有<code>DEBUG</code>这个标记.例如下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func GUILog&#60;T&#62;(_ message: T, fileName: String = #function, methodName: String = #function, lineNumber: Int = #line) &#123;&#10;    #if DEBUG&#10;    print(&#34;\(methodName)[\(lineNumber)]:\(message)&#34;)&#10;    #endif&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>虽然并不会报错,但是始终不会有打印.</p>
<h3 id="解决方案">解决方案</h3><p>在 <code>Build Settings</code> 中搜索 <code>other swift flags</code><br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658688864325.jpg" alt=""><br>点击图中红色框内部(注意不是直接点击<code>+</code>),会出现一个这样的对话框.(可能已经有其他标记,如果你使用了 <code>cocoapods</code> 的话,不过不用在意),点击左下角的+ ,或者双击任意空白行,输入<code>-DDEBUG</code>.<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658689870706.jpg" alt=""><br>点击其它任意区域.结果如图<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658693876738.jpg" alt=""></p>
<p>现在,<code>DEBUG</code>就能正常工作了!<br>可以通过调整模式来进行测试:<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658692067377.jpg" alt=""></p>
<p>把图中的地方改成<code>Release</code>,即可进行测试.</p>
<h3 id="Tips">Tips</h3><p>这个编译标记可以随便定义,并不是只能是<code>DEBUG</code>,只要标记能够对应,即可正常工作.编译器只是会看,在<code>Debug</code>模式下,有哪些标记.(或者在 <code>Release</code> 模式下有哪些标记.)例如:<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658693876738.jpg" alt=""><br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func GUILog&#60;T&#62;(_ message: T, fileName: String = #function, methodName: String = #function, lineNumber: Int = #line) &#123;&#10;    #if DEFAULT&#10;    print(&#34;\(methodName)[\(lineNumber)]:\(message)&#34;)&#10;    #endif&#10;&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-13T05:59:26.000Z"><a href="/2016/05/13/Swift/从-variable-with-a-setter-must-also-have-a-getter-引发的思考/">2016-05-13</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/13/Swift/从-variable-with-a-setter-must-also-have-a-getter-引发的思考/">从 variable with a setter must also have a getter 引发的思考</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天一哥们在群里问:”为什么我不能只重写 setter ,还要多写个 getter ?”<br>我一听也是懵了,后来在 playgroud 里面写,果然得到了一个错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;&#10;    &#10;    var labelText:String&#10;        &#123;&#10;        set(newValue)&#123;&#10;            self.labelText = newValue&#10;        &#125;&#10;   &#10;    &#125;&#10;    &#10;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Variable With a setter must also have a getter</code></p>
<p>后来,查找 stackflow, 找到了答案:</p>
<p>一旦你给一个属性添加了 <code>getter</code> 或者 <code>setter</code> ,这个属性将变成 <code>计算属性</code>.</p>
<p>后来,我在<code>The Swift Programming Language 2.2</code> 的 Properties 一章中,找到这样一段描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#8220;In addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.&#8221;</span><br></pre></td></tr></table></figure>
<p>除了存储属性之外,类,结构体和枚举还可以定义计算属性,计算属性 <strong>不存储值</strong> ,它们提供一个 <code>getter</code> 和一个 <strong>可选的</strong> <code>setter</code>,借此来读取和<strong>间接地</strong>设置<strong>其他属性和值</strong>.</p>
<p>我在文档中没有找到更多的说明,下面来说说我自己的思考:</p>
<ol>
<li><p>计算属性不存储值,那么也就是说,只能我显式地告诉程序,这个值是怎么来的.所以,需要有一个 <code>getter</code> ,它是必须的,否则这个属性就不是计算属性.而是存储属性.</p>
</li>
<li><p><code>setter</code>是可选的,可以不写 (不写 <code>setter</code> 不写 <code>getter</code>,那么这个属性还是存储属性).但是一旦写了<code>setter</code>(这个属性变成了计算属性),那么<code>getter</code>也是必须的</p>
</li>
</ol>
<h3 id="willSet_和_didSet">willSet 和 didSet</h3><p>刚刚说明了关于计算属性的一些特点,但是问题来了,我们经常有拦截<code>setter</code>来做一些自定义处理的需求. 在 OC 中,这个很简单,重写 <code>setter</code>方法就好了,但是, Swift 中, 添加<code>setter</code>会让属性变味.</p>
<p>Swift 的设计者肯定也是考虑到了这一点,所以提供了 <code>willSet</code> 和 <code>didSet</code>这两个属性观察方法.用法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;&#10;    &#10;    var labelText:String = &#34;great&#34;&#10;        &#123;&#10;        willSet&#123;&#10;            print(&#34;labeltext will change!&#34;)&#10;            &#10;        &#125;&#10;        didSet&#123;&#10;            print(&#34;labeltext did change!&#34;)&#10;//            labelText = &#34;defalut&#34;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labeltext will change!&#10;labeltext did change!&#10;11</span><br></pre></td></tr></table></figure>
<p>这样,我们可以过滤值,可以自己处理一些事情,也不会误把存储属性转换成计算属性.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-12T07:05:37.000Z"><a href="/2016/05/12/开发环境相关/手把手教你创建自己的Cocoapods库/">2016-05-12</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/12/开发环境相关/手把手教你创建自己的Cocoapods库/">手把手教你创建自己的Cocoapods库</a></h1>
  

    </header>
    <div class="entry">
      
        <p>如果您能看这篇文章,相信您已经了解并喜欢上了 Cocoapods, 下面我们一步一步的创建一个属于自己的 Cocoapods 库.</p>
<h2 id="创建">创建</h2><p>通过下面命令,可以使用一个创建向导简历 Cocoapods 库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create GUICodeSnippet</span><br></pre></td></tr></table></figure></p>
<p>然后终端会进行引导,依次选择即可. 回车键确认默认选择.</p>
<p>问题依次是:</p>
<ol>
<li><p>语言 </p>
</li>
<li><p>创建demo工程( 极力推荐创建)</p>
</li>
<li><p>选择测试框架 (可选择默认,如果非常确定没有需要,可以选择None)</p>
</li>
<li><p>View-based Testing  (官方推荐使用 <code>FBSnapShotTestCase</code>)</p>
</li>
<li><p>OC类前缀 (如果语言选择非OC,不会有这项)</p>
</li>
</ol>
<p>打开工程,会发现有一个 GUICodeSnippet 和一个 Pods, 在<br><code>Pods-&gt;Development Pods-&gt;GUICodeSnippet-&gt;Pod-&gt;Classes</code>中,有一个<code>ReplaceMe.m</code></p>
<p>你需要将这个文件替换成自己的代码文件.</p>
<h2 id="源码验证">源码验证</h2><p>进入 Example 目录 , 执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure></p>
<p>然后 Xcode 打开 xcworkspace 文件 ,去跑一下项目,如果没有错误,证明添加的代码没有问题,可以继续进行</p>
<h2 id="准备工作">准备工作</h2><h3 id="配置_podspec_文件">配置 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#10;# Be sure to run `pod lib lint GUICodeSnippet.podspec&#39; to ensure this is a&#10;# valid spec before submitting.&#10;#&#10;# Any lines starting with a # are optional, but their use is encouraged&#10;# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html&#10;#&#10;&#10;Pod::Spec.new do |s|&#10;  s.name             = &#34;GUICodeSnippet&#34;&#10;  s.version          = &#34;0.1.8&#34;&#10;  s.summary          = &#34;code segment of kennyGui&#34;&#10;&#10;# This description is used to generate tags and improve search results.&#10;#   * Think: What does it do? Why did you write it? What is the focus?&#10;#   * Try to keep it short, snappy and to the point.&#10;#   * Write the description between the DESC delimiters below.&#10;#   * Finally, don&#39;t worry about the indent, CocoaPods strips it!  &#10;  s.description      = &#60;&#60;-DESC&#10;                      code segment of kenny ,and in most situation ,is for private use only&#10;                       DESC&#10;&#10;  s.homepage         = &#34;https://git.oschina.net/kennygui/GUICodeSnippet&#34;&#10;  # s.screenshots     = &#34;www.example.com/screenshots_1&#34;, &#34;www.example.com/screenshots_2&#34;&#10;  s.license          = &#39;MIT&#39;&#10;  s.author           = &#123; &#34;katsurake&#34; =&#62; &#34;katsurake@foxmail.com&#34; &#125;&#10;  s.source           = &#123; :git =&#62; &#34;https://git.oschina.net/kennygui/GUICodeSnippet.git&#34;, :tag =&#62; s.version.to_s &#125;&#10;  # s.social_media_url = &#39;https://twitter.com/&#60;TWITTER_USERNAME&#62;&#39;&#10;&#10;  s.platform     = :ios, &#39;7.0&#39;&#10;  s.requires_arc = true&#10;&#10;  s.source_files = &#39;Pod/Classes/*.h&#39;&#10;  s.resource_bundles = &#123;&#10;    &#39;GUICodeSnippet&#39; =&#62; [&#39;Pod/Assets/*.png&#39;]&#10;  &#125;&#10;&#10;  s.public_header_files = &#39;Pod/Classes/*.h&#39;&#10;  s.frameworks = &#39;UIKit&#39;, &#39;MapKit&#39;&#10;  s.dependency &#39;AFNetworking&#39;, &#39;~&#62; 2.3&#39;&#10;  s.dependency &#39;CocoaLumberjack&#39;, &#39;~&#62; 2.2.0&#39;&#10;  s.dependency &#39;MBProgressHUD&#39;, &#39;~&#62; 0.9.2&#39;&#10;  s.dependency &#39;Masonry&#39;, &#39;~&#62; 0.6.4&#39;&#10;  s.dependency &#39;ReactiveCocoa&#39;, &#39;~&#62; 2.5&#39;&#10;  s.dependency &#39;YapDatabase&#39;, &#39;~&#62; 2.8.3&#39;&#10;  s.dependency &#39;DTCoreText&#39;, &#39;~&#62; 1.6.17&#39;&#10;  s.dependency &#39;MJExtension&#39;, &#39;~&#62; 3.0.10&#39;&#10;  end</span><br></pre></td></tr></table></figure>
<p>创建完毕之后,随手使用<br><code>pod lib lint</code><br>命令验证是否编写正确,如果没有正确,根据提示修改即可.</p>
<p>几个好用的命令:</p>
 <figure class="highlight"><figcaption><span>完整打印详情,可以帮助我们调试,用法 ` pod lib lint --verbose`</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> &#10; &#10; ```--allow-warnings``` &#24573;&#30053;&#35686;&#21578;,&#30001;&#20110;&#19968;&#20123;&#19977;&#26041;&#20195;&#30721;&#26377;&#35686;&#21578;,&#25152;&#20197;&#36896;&#25104;&#22987;&#32456;&#26080;&#27861;&#36890;&#36807;,&#21487;&#20197;&#29992;&#36825;&#20010;&#26041;&#27861;&#24573;&#30053;&#35686;&#21578;,&#29992;&#27861;&#21516;&#19978;&#10; &#10;&#10;&#10;### &#21019;&#24314;&#20195;&#30721;&#20179;&#24211;&#10; &#22312;github &#25110;&#32773;&#20854;&#20182;&#25176;&#31649;&#24179;&#21488;&#24314;&#31435;&#19968;&#20010;&#31354;&#39033;&#30446;,&#26368;&#22909;&#39033;&#30446;&#21517;&#31216;&#21644;&#26412;&#22320;&#30340;&#19968;&#33268;</span><br></pre></td></tr></table></figure>
<p>git add .<br>git commit -m “Initial Commit”<br>git remote add origin <a href="https://github.com/kennyGui/GUICodeSnippet.git" target="_blank" rel="external">https://github.com/kennyGui/GUICodeSnippet.git</a><br>git push -u origin master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#20854;&#23454;&#25105;&#26356;&#21916;&#27426;&#30340;&#26041;&#24335;&#26159;, Clone &#31354;&#39033;&#30446;,&#28982;&#21518;&#26367;&#25442;&#20195;&#30721;&#30340; .git &#25991;&#20214;&#22841;,&#36825;&#26679;&#26356;&#26292;&#21147;,&#20855;&#20307;&#24590;&#20040;&#36873;&#25321;,&#30475;&#20010;&#20154;&#21916;&#22909;.&#10;&#10;### &#25171; tag</span><br></pre></td></tr></table></figure></p>
<p>git tag -a 0.1.0 -m “初始版本”</p>
<p>通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作：<br>git push origin 0.1.2 # 将v0.1.2标签提交到git服务器<br>或者<br>git push origin –tags # 将本地所有标签一次性提交到git服务器<br>验证标签成功<br>git tag #查看标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;## &#25512;&#36865;&#25551;&#36848;&#25991;&#20214;&#10;&#20351;&#29992;&#36825;&#20010;&#21629;&#20196;&#25512;&#36865;&#33258;&#24049;&#30340;&#24211;&#30340;&#20449;&#24687;&#21040;&#23448;&#26041;&#30340; Master &#24211;&#10;&#10;```pod trunk push GUICodeSnippet.podspec</span><br></pre></td></tr></table></figure></p>
<p>但是如果你是第一次使用的话,需要注册 Session<br>使用如下命令注册自己的邮箱(注意替换成自己的邮箱)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register orta@cocoapods.org &#39;Orta Therox&#39; --description=&#39;macbook air&#39;</span><br></pre></td></tr></table></figure>
<p>稍后, 邮箱会收到邮件, 点击链接即可</p>
<figure class="highlight"><figcaption><span>trunk push BlinkingLabel.podspec ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#30001;&#20110;&#32593;&#32476;&#21407;&#22240;(&#20320;&#25026;&#24471;),&#21487;&#33021;&#20250;&#25512;&#36865;&#22833;&#36133;,&#22810;&#23581;&#35797;&#20960;&#27425;&#21363;&#21487;.&#10;&#10;## &#39564;&#35777;&#10;&#10;&#21487;&#20197;&#35753;&#21516;&#20107;&#25110;&#32773;&#26379;&#21451;&#20351;&#29992;</span><br></pre></td></tr></table></figure>
<p>pod search GUICodeSnippet<br><code>``
这个命令进行测试,但是,如果是第一次,应该是找不到的.
需要使用</code>pod setup`更新一下本地的 Maser 库信息</p>
<h2 id="结语">结语</h2><p>好了,现在,你就可以将自己的代码共享给小伙伴使用啦.</p>
<p>现在 pod 里面的 Class 都是放在一个文件夹下的,没有办法实现子文件夹,(即使工程里面有多个文件夹,但是弄好 cocoapods 之后,也是都放到一个文件夹下面了)</p>
<p>这需要我们的 spec 里面配置 subspec ,这个知识点会在下一篇文章中说</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-12T03:06:35.000Z"><a href="/2016/05/12/开发环境相关/升级-Chisel-遇到的问题和解决记录/">2016-05-12</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/12/开发环境相关/升级-Chisel-遇到的问题和解决记录/">升级 Chisel 遇到的问题和解决记录</a></h1>
  

    </header>
    <div class="entry">
      
        <p>升级了 Xcode7.3后，发现 Chisel 突然不好使了，于是再度打开<a href="https://github.com/facebook/chisel" target="_blank" rel="external">主页</a>，想升级一下应该能解决问题. </p>
<p>安装官方说明，需要首先升级 homebrew ，其实知道 ，这一步不是必须的。但是为了后面不出现问题,还是顺手一并升级吧!</p>
<p>然后,开始了问题之旅:</p>
<p>使用 <code>brew update</code>,结果得到了以下提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: unable to unlink CONTRIBUTING.md: Permission denied&#10;warning: unable to unlink SUPPORTERS.md: Permission denied&#10;fatal: cannot create directory at &#39;.github&#39;: Permission denied</span><br></pre></td></tr></table></figure>
<p>不难看出,是权限问题,修改权限</p>
<p><code>sudo chmod -R 777 /usr/local</code></p>
<p>相关知识：<br>可以不必修改为 777 的, 关于权限的更多,感兴趣的可以自行 google<br>r表示读权限，4 , w表示写权限，2 , x表示执行权限， 1</p>
<p>可是修改之后,仍然不好用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in `require&#39;: cannot load such file -- mach (LoadError)</span><br></pre></td></tr></table></figure></p>
<p>一不做,二不休,干脆尝试重新安装 homebrew</p>
<p>在终端输入<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code><br>然后得到了下面的提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kenny@kenny:~|&#8658;  /usr/bin/ruby -e &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&#34;&#10;-e:77: warning: Insecure world writable dir /usr/local/bin in PATH, mode 040777&#10;It appears Homebrew is already installed. If your intent is to reinstall you&#10;should do the following before running this installer again:&#10;    ruby -e &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&#34;&#10;The current contents of /usr/local are bin Cellar CODEOFCONDUCT.md CONTRIBUTING.md etc include lib Library LICENSE.txt opt README.md sbin share SUPPORTERS.md var .git .gitignore</span><br></pre></td></tr></table></figure>
<p>提示的是 git 的错误<br>尝试 cd 到<code>/usr/local</code>目录下，<br><code>git status</code><br>果然有一堆修改内容,这些应该是之前各种操作没有成功完成,导致修改没有被妥善处理<br>然后：<br><code>git reset --hard</code></p>
<p><code>kenny@kenny:/usr/local|master⇒  git status
On branch master
nothing to commit, working directory clean</code></p>
<p>可能还需要执行：<br><code>git clean -df</code></p>
<p>第一个是放弃已经 stage 的文件的更改<br>第二个是对没有 stage 的文件进行放弃</p>
<p>执行安装<br><figure class="highlight"><figcaption><span>brew install chisel</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: chisel-1.2.0 already installed&#10;To install this version, first `brew unlink chisel`</span><br></pre></td></tr></table></figure></p>
<p>卸载旧版<br><figure class="highlight"><figcaption><span>brew unlink chisel</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unlinking /usr/local/Cellar/chisel/1.2.0... 0 symlinks removed</span><br></pre></td></tr></table></figure></p>
<p>重新安装<br><figure class="highlight"><figcaption><span>brew install chisel</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==&#62; Downloading https://github.com/facebook/chisel/archive/1.4.0.tar.gz&#10;==&#62; Downloading from https://codeload.github.com/facebook/chisel/tar.gz/1.4.0</span><br></pre></td></tr></table></figure></p>
<p>可以看到,现在升级到了1.4了.</p>
<p>到 Xcode 中测试,发现也欢乐的好用了 !</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->




<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/categories/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/categories/Git/">Git</a><small>1</small></li>
  
    <li><a href="/categories/ReactiveCocoa/">ReactiveCocoa</a><small>3</small></li>
  
    <li><a href="/categories/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/categories/Swift进阶/">Swift进阶</a><small>4</small></li>
  
    <li><a href="/categories/Vim/">Vim</a><small>2</small></li>
  
    <li><a href="/categories/iOS-Tips/">iOS Tips</a><small>14</small></li>
  
    <li><a href="/categories/主页维护记录/">主页维护记录</a><small>4</small></li>
  
    <li><a href="/categories/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/categories/开发环境相关/">开发环境相关</a><small>5</small></li>
  
    <li><a href="/categories/悟/">悟</a><small>1</small></li>
  
    <li><a href="/categories/知识技巧总结/">知识技巧总结</a><small>1</small></li>
  
    <li><a href="/categories/算法专题/">算法专题</a><small>1</small></li>
  
    <li><a href="/categories/视频相关/">视频相关</a><small>1</small></li>
  
    <li><a href="/categories/辅助编程技能/">辅助编程技能</a><small>7</small></li>
  
    <li><a href="/categories/重构、模式、架构/">重构、模式、架构</a><small>10</small></li>
  
    <li><a href="/categories/高效OC编程/">高效OC编程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/tags/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/tags/Git-命令/">Git 命令</a><small>1</small></li>
  
    <li><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a><small>3</small></li>
  
    <li><a href="/tags/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/tags/Swift-进阶/">Swift 进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶/">Swift进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶-variable-with-a-setter-must-also-have-a-getter/">Swift进阶 variable with a setter must also have a getter</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Tips/">iOS Tips</a><small>3</small></li>
  
    <li><a href="/tags/主页维护记录/">主页维护记录</a><small>2</small></li>
  
    <li><a href="/tags/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/tags/小脚本大智慧/">小脚本大智慧</a><small>1</small></li>
  
    <li><a href="/tags/开发环境相关/">开发环境相关</a><small>3</small></li>
  
    <li><a href="/tags/悟/">悟</a><small>1</small></li>
  
    <li><a href="/tags/正则表达式/">正则表达式</a><small>2</small></li>
  
    <li><a href="/tags/测试小样/">测试小样</a><small>1</small></li>
  
    <li><a href="/tags/算法专题-字符串/">算法专题 字符串</a><small>1</small></li>
  
    <li><a href="/tags/视频相关/">视频相关</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
    <li><a href="/tags/辅助编程技能/">辅助编程技能</a><small>2</small></li>
  
    <li><a href="/tags/重构、模式、架构/">重构、模式、架构</a><small>5</small></li>
  
    <li><a href="/tags/问题解决和思考/">问题解决和思考</a><small>5</small></li>
  
    <li><a href="/tags/高效OC编程/">高效OC编程</a><small>4</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 桂庆
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>