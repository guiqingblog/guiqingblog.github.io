<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kenny 肉桂的主页</title>
  <meta name="author" content="桂庆">
  
  <meta name="description" content="Kenny 肉桂的主页 记录自己的进步">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Kenny 肉桂的主页"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kenny 肉桂的主页" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Kenny 肉桂的主页</a></h1>
  <h2><a href="/">记录自己的进步</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-03T09:05:25.000Z"><a href="/2016/08/03/Vim/Vim实践Tips-六/">2016-08-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/03/Vim/Vim实践Tips-六/">Vim实践Tips(六)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_27_遇见Vim的命令行">Tip 27 遇见Vim的命令行</h2><p>当我们按下<code>:</code>,Vim就切换到了底行模式.这个模式和shell的命令行有些类似.我们只要输入点命令,然后按下<code>&lt;CR&gt;</code>就能执行.使用<code>&lt;Esc&gt;</code>可以从底行模式切换到命令行模式.</p>
<p>由于一些历史原因,我们执行的命令叫做 <code>Ex Commands</code> .当我们按下<code>/</code>之后,或者使用<code>&lt;C-r&gt;=</code>访问表达式寄存器的时候,也都会进入底行模式.这章中提到的一些小技巧也都适用于不同的情况,但是在这个章节,我们先讨论<code>Ex commands</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  &#21629;&#20196;                     &#25928;&#26524;&#10;:[range]delete[x]          &#21024;&#38500;&#29305;&#23450;&#30340;&#34892;(&#25918;&#21040;&#23492;&#23384;&#22120;x&#20013;)&#10;:[range]yank[x]            &#22797;&#21046;&#29305;&#23450;&#30340;&#34892;(&#25918;&#21040;&#23492;&#23384;&#22120;x&#20013;)&#10;:[line]put[x]              &#25226;&#23492;&#23384;&#22120;x&#20013;&#30340;&#20869;&#23481;&#25918;&#21040;&#29305;&#23450;&#30340;&#34892;&#21518;&#38754;&#10;:[range]copy&#123;address&#125;      &#22797;&#21046;&#29305;&#23450;&#30340;&#34892;&#21040;&#36890;&#36807;&#22320;&#22336;&#25351;&#23450;&#30340;&#34892;&#30340;&#19979;&#38754;&#10;:[range]move&#123;address&#125;      &#31227;&#21160;&#29305;&#23450;&#30340;&#34892;&#21040;&#36890;&#36807;&#22320;&#22336;&#25351;&#23450;&#30340;&#34892;&#30340;&#19979;&#38754;&#10;:[range]join               &#36830;&#25509;&#25351;&#23450;&#30340;&#34892;&#10;:[range]normal &#123;commands&#125;  &#23545;&#29305;&#23450;&#30340;&#33539;&#22260;&#25191;&#34892;&#21629;&#20196;&#27169;&#24335;&#19979;&#30340;&#21629;&#20196;&#10;:[range]substitute/&#123;pattern&#125;&#10;/&#123;string&#125;/&#123;flags&#125;&#10;                           &#22312;&#29305;&#23450;&#30340;&#34892;&#37324;&#38754;,&#25226;&#31526;&#21512;&#26465;&#20214;&#30340;&#21305;&#37197;&#20351;&#29992;&#23383;&#31526;&#20018;&#26367;&#25442;&#25481;.&#10;:[range]global/&#123;pattern&#125;/[cmd] &#22312;&#25152;&#26377;&#21305;&#37197;&#21040;pattern&#30340;&#34892;&#20013;,&#25191;&#34892;Ex&#21629;&#20196;</span><br></pre></td></tr></table></figure>
<p>我们可以Ex命令读写文件(<code>:read</code>和<code>:write</code>),或者使用<code>:tabnew</code>命令创建Tab页,或者使用<code>:split</code>命令创建窗口.</p>
<h2 id="Tip_28_在一到多个连续行中执行命令">Tip 28 在一到多个连续行中执行命令</h2><p>许多Ex命令都可以接受一个{range},我们可以通过行号,标记,或者是一个Pattern来提供范围.<br>假设有下面一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;html&#62;&#10;  &#60;head&#62;&#60;title&#62;Practical Vim&#60;/title&#62;&#60;/head&#62;&#10;  &#60;body&#62;&#60;h1&#62;Practical Vim&#60;/h1&#62;&#60;/body&#62;&#10;&#60;/html&#62;</span><br></pre></td></tr></table></figure></p>
<p>为了说明,我们使用<code>:print</code>命令,这个命令可以简单的通过这个命令将特定的行打印到Vim的底行之下.<br>这个命令没有什么特定的功能.但是可以用来做说明.当然,你也可以通过<code>:delete</code>,<code>:join</code>,<code>:substitude</code>,<code>:normal</code>这几个命令来测试.通过测试,你就可以知道怎么使用Ex命令了.</p>
<h3 id="使用行号作为地址">使用行号作为地址</h3><p>如果我们输入一个仅由数字组成的Ex命令.Vim就会把这个命令当做地址,然后将光标移动到那一行.所以,我们就能通过下面的这个命令跳转到文件顶部:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1&#10;:print</span><br></pre></td></tr></table></figure></p>
<p>你也可以使用<code>:p</code>来打印,这个是<code>:print</code>的缩写形式.你也可以将两个命令合并到一起.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3p</span><br></pre></td></tr></table></figure></p>
<p>这个命令移动到第3行,然后打印该行的内容.我们只是通过<code>:p</code>命令来说明问题,下面你可以试试这个命令.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3d</span><br></pre></td></tr></table></figure></p>
<p>这个命令跳转到第3行,然后执行删除命令.它相当于在命令模式下执行:<code>3Gdd</code>.这个命令比命令行模式下的要快点.</p>
<h3 id="通过地址指定一个范围">通过地址指定一个范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:2,5p</span><br></pre></td></tr></table></figure>
<p>这个命令可以打印从第2行到第5行,并且最后光标停留在第5行.通常来说,范围可以表现为这个形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#123;start&#125;,&#123;end&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意,这个<code>start</code>和<code>end</code>都是地址,目前我们知道的地址是行号.在后面的我们将见到通过匹配和标记指定的地址.</p>
<p><code>.</code>可以用来表达为当前行,所以,我们可以通过下面的命令打印从当前行到文件末尾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:2&#10;:.,$p</span><br></pre></td></tr></table></figure></p>
<p><code>%</code>这个符号也有特别的意义,它代表了当前文件中的所有行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%p</span><br></pre></td></tr></table></figure></p>
<p>它相当于<code>:1,$p</code>这个命令.</p>
<h3 id="通过在可视化模式下的选择指定范围">通过在可视化模式下的选择指定范围</h3><p>首先通过命令<code>2G</code>跳转到第2行,然后<code>VG</code>可以选择从2行到文件结尾.此时,我们按下<code>:</code>.这时候,底行上出现了<code>:&#39;&lt;,&#39;&gt;</code>,看起来有点怪怪的,但是你可以简单的认为,它就代表了可视化模式的选区.然后,我们就能指定Ex命令.例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#39;&#60;,&#39;&#62;p</span><br></pre></td></tr></table></figure></p>
<h3 id="通过匹配指定范围">通过匹配指定范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/&#60;html&#62;/,/&#60;\/html&#62;/p</span><br></pre></td></tr></table></figure>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;html&#62;&#10;  &#60;head&#62;&#60;title&#62;Practical Vim&#60;/title&#62;&#60;/head&#62;&#10;  &#60;body&#62;&#60;h1&#62;Practical Vim&#60;/h1&#62;&#60;/body&#62;&#10;&#60;/html&#62;</span><br></pre></td></tr></table></figure></p>
<p>看起来有点复杂,但是,它还是遵循了<code>:{start},{end}</code>的形式.这个<code>start</code>和刚刚的<code>/&lt;html&gt;/</code>相对应.而<code>end</code>和<code>/&lt;\/html&gt;/</code>相对应.</p>
<p>在这个例子中,我们可以通过<code>:2,5</code>指定范围,这个方式更简洁.而通过标签形式的方式,可以直接匹配标签,不论中间有多少行.</p>
<h3 id="通过偏移来指定地址">通过偏移来指定地址</h3><p>假设我们有需求:<code>打印所有的&lt;html&gt;标签内的内容,但是不打印包含&lt;html&gt;的行.</code><br>我们可以指定偏移:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/&#60;html&#62;/+1,/&#60;\/html&#62;/-1p</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;head&#62;&#60;title&#62;Practical Vim&#60;/title&#62;&#60;/head&#62;&#10;&#60;body&#62;&#60;h1&#62;Practical Vim&#60;/h1&#62;&#60;/body&#62;</span><br></pre></td></tr></table></figure></p>
<p>这个语法的一般形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;address&#125;+n</span><br></pre></td></tr></table></figure></p>
<p>如果<code>n</code>省略,那么它默认是1.这个<code>address</code>可以是<code>行号</code>或者是<code>标记</code>或者是<code>模式匹配</code><br>那么我们可以实现,从当前行打印后面3行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.,.+3p</span><br></pre></td></tr></table></figure></p>
<h3 id="讨论">讨论</h3><p>指定范围的语法非常灵活.我们可以混合使用<code>行号</code> <code>标记</code> <code>模式匹配</code>,也可以通过应用偏移来修改范围.<br>下面的表格可以作为一个参考:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#31526;&#21495;      &#20195;&#34920;&#30340;&#22320;&#22336;&#10;1         &#25991;&#20214;&#30340;&#31532;&#19968;&#34892;&#10;$         &#25991;&#20214;&#30340;&#26368;&#21518;&#19968;&#34892;&#10;.         &#20809;&#26631;&#25152;&#22312;&#34892;&#10;&#39;m        &#26631;&#35760;m&#25152;&#22312;&#30340;&#34892;&#10;&#39;&#60;        &#21487;&#35270;&#21270;&#36873;&#21306;&#30340;&#24320;&#22987;&#10;&#39;&#62;        &#21487;&#35270;&#21270;&#36873;&#21306;&#30340;&#32467;&#23614;&#10;%         &#25991;&#20214;&#25152;&#26377;&#34892; ( :1,$ &#30340;&#24555;&#25463;&#26041;&#24335;)&#10;0         &#31532;0&#34892;</span><br></pre></td></tr></table></figure></p>
<p>第0行并不真实存在,但是在特定的情况下,这个地址还是很有用的.例如,在<code>:copy {address}</code>和<code>:move {address}</code>中,我们想复制或者移动从文件开头的范围.在后面的两个Tip中,我们将看到具体的例子.</p>
<p>当我们指定一个<code>[range]</code>,它总是表示一些连续的行.我们也能通过模式匹配应用Ex命令到一系列非连续的行,通过<code>:global</code>这个命令就能做到.</p>
<h2 id="Tip_29_通过t和m复制和移动行">Tip 29 通过t和m复制和移动行</h2><p><code>:copy</code>命令(快捷方式是<code>:t</code>)让我们可以复制1到多行,而<code>:move</code>命令可以移动1到多行.</p>
<p>为了说明,我们使用下面的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shopping list&#10;    Hardware Store&#10;        Buy new hammer&#10;    Beauty Parlor&#10;        Buy nail polish remover&#10;        Buy nails</span><br></pre></td></tr></table></figure></p>
<h3 id="通过:t命令复制行">通过:t命令复制行</h3><p>我们的购物清单还不完整.假设我们也需要在<code>Hardware Store</code>买<code>nails</code>.为了修正这个清单,我们重用文件的最后一行.我们可以简单的使用<code>:copy</code>命令完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shopping list&#10;    Hardware Store&#10;        Buy nails&#10;        Buy new hammer&#10;    Beauty Parlor&#10;        Buy nail polish remover&#10;        Buy nails</span><br></pre></td></tr></table></figure>
<p>上述命令是通过<code>:160copy.</code>完成的(在我编写这个文档的时候,Buy nails 是第160行`)</p>
<p>copy命令的一般格式是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]copy &#123;address&#125;</span><br></pre></td></tr></table></figure></p>
<p>在我们的例子中,<code>[range]</code>是<code>160</code>行.<code>{address}</code>在这个例子中是<code>.</code>,代表了当前行.所以这个<code>:160copy.</code>的意义是:<code>复制160行,并且放置到当前行的下面</code>.</p>
<p>我们也可以简写<code>:copy</code>成<code>:co</code>,也可以更简洁的写成<code>:t</code>.为了辅助记忆,你可以理解<code>t</code>为:<code>copy To</code>.下面的表格中列举了一些<code>:t</code>的用法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#21629;&#20196;             &#25928;&#26524;&#10;:6t.            &#22797;&#21046;&#31532;6&#34892;&#21040;&#24403;&#21069;&#34892;&#30340;&#19979;&#38754;&#10;:t6             &#22797;&#21046;&#24403;&#21069;&#34892;&#21040;&#31532;6&#34892;&#19979;&#38754;&#10;:t.             &#22797;&#21046;&#24403;&#21069;&#34892;(&#30456;&#24403;&#20110;&#21629;&#20196;&#27169;&#24335;&#19979;&#30340;yyp)&#10;:t$             &#22797;&#21046;&#24403;&#21069;&#34892;&#21040;&#25991;&#20214;&#32467;&#23614;&#10;:&#39;&#60;,&#39;&#62;t0        &#22797;&#21046;&#21487;&#35270;&#21270;&#36873;&#21306;&#21040;&#25991;&#20214;&#24320;&#22836;</span><br></pre></td></tr></table></figure></p>
<p>注意: <code>:t.</code>复制当前行.作为选择,我们也可以通过命令模式下的<code>yyp</code>实现同样的效果.一个值得注意的区别就是<code>yyp</code>使用寄存器,而<code>:t.</code>不这样.有时候,为了避免覆盖默认寄存器的内容,我使用<code>:t.</code>复制当前行.</p>
<p>在这个例子中,我们使用<code>yyp</code>的变体复制我们想要的行,但是,它需要一些额外的移动.我们需要先跳转到到我们想复制的行<code>6G</code>,复制<code>yy</code>,回到我们开始的地方<code>&lt;C-o&gt;</code>,然后<code>p</code>粘贴.所以,在这种比较远的复制操作,<code>:t</code>这种命令更高效.</p>
<h3 id="通过:m命令移动行">通过:m命令移动行</h3><p>语法是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]move &#123;address&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以简写成<code>:m</code><br>如果已经选择好了分区.我们可以直接运行命令<code>:&#39;&lt;,&#39;&gt;m$</code>,作为选择,我们也可以使用<code>dGp</code>命令.这个命令可以分解为:<code>d</code>删除,同时复制到寄存器,<code>G</code>跳转到文件结尾,<code>p</code>粘贴内容.</p>
<p>重复上个Ex命令: <code>@:</code></p>
<h2 id="Tip_30_在一个范围上使用命令模式的命令">Tip 30 在一个范围上使用命令模式的命令</h2><p>在Tip 2 中,我们在每行的后面追加一个分号,当时我们使用的<code>.</code>命令做的重复.当时只有几行,那么做可以,但是如果有2000行需要追加呢? 显然,用<code>j.</code>的方式就不靠谱了.</p>
<p>使用<code>normal</code>命令可以对一个范围使用命令模式下的命令.</p>
<p>我们使用下面的代码来说明问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1&#10;var bar = &#39;a&#39;&#10;var baz = &#39;z&#39;&#10;var foobar = foo + bar&#10;var foobarbaz = foo + bar + baz</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>A;&lt;Esc&gt;</code> 跳转到行结尾,输入<code>;</code>,退出插入模式</li>
<li><code>jVG</code> 选中除了第一行的的后面所有行</li>
<li><code>&#39;&lt;,&#39;&gt;normal.</code> normal执行命令模式,<code>.</code>重复</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#10;var bar = &#39;a&#39;;&#10;var baz = &#39;z&#39;;&#10;var foobar = foo + bar;&#10;var foobarbaz = foo + bar + baz;</span><br></pre></td></tr></table></figure>
<p>使用了上面的步骤,不管是5行还是5000行,都能正常工作.<br>其实不仅仅是<code>.</code>这个命令,使用了<code>normal</code>这个标记之后,我们可以执行任何命令模式下命令.</p>
<p>在这个例子中,我们可以通过一个命令完成操作.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%normal A;</span><br></pre></td></tr></table></figure></p>
<p><code>%</code>这个命令表示整个文件范围的行.所以上面的命令的意思是:<code>在文件的每一行后面都追加一个;</code>,而且Vim会在完成之后,自动切换到命令模式</p>
<p>既然可以通过<code>:normal</code>这个命令使用所有的命令模式命令.那么下面这个命令也很同意理解.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%normal i//</span><br></pre></td></tr></table></figure>
<p>在所有行的开始加入<code>//</code>.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-03T09:03:58.000Z"><a href="/2016/08/03/Vim/Vim实践Tips-五/">2016-08-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/03/Vim/Vim实践Tips-五/">Vim实践Tips(五)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_20_体验可视化模式">Tip 20 体验可视化模式</h2><p>在可视化模式下,很多命令的作用和它们在命令模式时相同.我们仍旧可以使用<code>hjkl</code>来移动光标.使用<code>f{char}</code>跳转到当前行的某个字符.然后使用<code>;</code>重复跳转,或者使用<code>,</code>反向跳转.我们甚至可以使用查找命令(包括<code>n</code>和<code>N</code>)跳转到匹配的地方.在可视化模式下,移动光标,将改变选择的范围.</p>
<p>虽然大多数命令一样,但是也有一些细微的差别,例如<code>c</code>这个命令.在命令模式下.我们使用<code>c{motion}</code>删除内容并进入插入模式.而在可视化模式下,在选中了部分内容时,只需要一个<code>c</code>就能进入插入模式,删除的内容是高亮部分的内容.这时候,这个<code>c</code>的作用更直观了.</p>
<p>下面看一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">March is a month</span><br></pre></td></tr></table></figure>
<p>如果要把<code>March</code>改为<code>April</code>,假设我们已经把光标放在了<code>March</code>这个单词上的任意位置了.那么可以通过<code>viw</code>选择整个单词.这时候,我们不能直接输入<code>April</code>,因为<code>A</code>会触发Vim命令.然后只会输入剩下的<code>pril</code>.所以,我们使用<code>c</code>这个命令,删除当前选择并进入插入模式.然后输入<code>April</code>.</p>
<h3 id="遇见选择模式">遇见选择模式</h3><p>在一般的编辑器中,当我们选中想要删除的文字时候,只要输入点内容,就能覆盖原来的文本,但是可视化模式没有遵循这个惯例.而选择模式是这样的.</p>
<p>我们可以通过<code>&lt;C-g&gt;</code>切换可视化模式和选择模式.唯一可以看到的区别就是在屏幕的底部,可视化模式是<code>VISUAL</code>而选择模式是<code>SELECT</code>.当在选择模式下输入任意可打印的字符时候,将替换,并自动进入插入模式.当然,这个功能也能通过在可视化模式下,按<code>c</code>来实现.Vim做这个东西的作用,应该为了更符合用户的习惯.</p>
<h2 id="Tip21_定义可视化选区">Tip21 定义可视化选区</h2><p><strong>可视化模式有三个不同的子模式,他们用来处理不同的可视化模式.</strong></p>
<p>在字符可视化模式(character-wise Visual mode),我们可以以字符为单位选取内容.它可以是一个字符,也可以是多行.它适合于对独立的单词或者段落.<br>在行可视化模式(line-wise Visual mode),处理的单位是行<br>在块可视化模式(block-wise Visual mode),我们可以选择柱形区域</p>
<p>这里只是粗略一说,后面有更详细的内容.</p>
<h3 id="进入可视化模式">进入可视化模式</h3><p>使用<code>v</code>键,可以进入可视化模式.按<code>v</code>键,可以从命令模式,进入字符可视化模式.通过<code>V</code>(Shift-v),可以进入行可视化模式.通过<code>&lt;C-v&gt;</code>可以进入块可视化模式.<br>下面是简单的一个列举:</p>
<p>命令        作用<br>v           进入字符可视化模式<br>V           进入行可视化模式</p>
<p><c-v>       进入块可视化模式<br>gv          重新选择最后一次的选区</c-v></p>
<p><code>gv</code>是个很好用的快捷命令.无论是什么可视化模式,<code>gv</code>都能应对自如.唯一可能有点问题的是:你已经删除了最后一次选区的内容.</p>
<h3 id="在可视化模式中切换">在可视化模式中切换</h3><p>下面是命令参考表<br>命令          作用</p>
<p><esc>         切换到命令模式</esc></p>
<p><c-[>         切换到命令模式<br>v             在命令模式和字符可视化模式切换<br>V             在命令模式和行可视化模式切换</c-[></p>
<p><c-v>         在命令模式和字符块视化模式切换<br>o             把光标在选区的两端切换.</c-v></p>
<h3 id="切换选区的可变端">切换选区的可变端</h3><p>默认选择选区的时候,一端是固定的,另一端是可以通过各种移动命令进行移动的.可以通过<code>o</code>这个命令切换移动端.</p>
<p>补充小知识:</p>
<p><code>e</code>移动到下个单词的结尾.</p>
<h2 id="Tip_22_重复行可视化模式命令">Tip 22 重复行可视化模式命令</h2><p>当我们在可视化模式下执行一个命令之后,我们就会进入命令模式.在可视化模式下选中的文字将取消选中.那么如果我们想对刚刚选中的文字重新执行一个可视化模式的命令该怎么办?</p>
<p>假设我们有下面一段python:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):&#10;  a, b = 0, 1&#10;  while a &#60; n:&#10;print a,&#10;a, b = b, a+b&#10;fib(42)</span><br></pre></td></tr></table></figure>
<h3 id="准备工作">准备工作</h3><p>为了让<code>&lt;</code>和<code>&gt;</code>这两个命令正常工作,我们应该做下面的设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth=4 softtabstop=4 expandtab</span><br></pre></td></tr></table></figure></p>
<h3 id="缩进一次,然后重复">缩进一次,然后重复</h3><p>对于刚刚的python代码,缩进有问题,我们应该在可视化模式下选择.然后使用<code>&gt;</code>这个命令缩进.但是缩进要超过两次.而执行一次刚刚的命令之后,我们就会进入命令模式.</p>
<p>有个解决方案是通过<code>gv</code>命令,然后再次执行缩进命令.但是如果你对Vim已经有了感觉,那你就应该知道这个方式是不好的.</p>
<p>当我们需要重复,<code>.</code>这个命令是一个非常好的选择.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):&#10;  a, b = 0, 1&#10;  while a &#60; n:&#10;    print a,&#10;    a, b = b, a+b&#10;fib(42)</span><br></pre></td></tr></table></figure>
<p>上面是通过 <code>Vj</code>选中两行,然后<code>&gt;.</code>完成的</p>
<p>如果你喜欢计算,那么你可能更喜欢<code>2&gt;</code>这个命令.但是我更喜欢使用<code>.</code>这个命令.因为这个命令可以给我可视化的反馈.我也能享受到自己键盘的反馈的乐趣.之前我们也讨论过计数和重复的取舍.你可以重新看看.</p>
<h2 id="Tip_23_在可能的时候,在可视化模式下,使用操作符">Tip 23 在可能的时候,在可视化模式下,使用操作符</h2><p>可视化模式更直观,但是它有个缺点:<code>.</code>这个命令不能完全发挥作用.我们可以通过命令模式下的命令来搞定这个缺点.</p>
<p>假设我们有下面一段文字.我们想把下面链接设置为大写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;a href=&#34;#&#34;&#62;one&#60;/a&#62;&#10;&#60;a href=&#34;#&#34;&#62;two&#60;/a&#62;&#10;&#60;a href=&#34;#&#34;&#62;three&#60;/a&#62;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过<code>vit</code>命令选中标签内部的文字,它理解为:可视化选中标签之间的文字.<code>it</code>命令是一种特别的<code>{motion}</code>命令.我们将在<code>Tip 51</code>进行更深入讨论.</p>
<h3 id="使用可视化操作符号">使用可视化操作符号</h3><p>在可视化模式下,我们选择一段文字,然后对它进行操作.在这个案例下,我们可以使用<code>U</code>命令来让选中的文字变成大写.<br>完成了第一行之后,如果想对第二行,第三行进行操作.应该怎么办呢?<code>.</code>命令可以吗?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;a href=&#34;#&#34;&#62;ONE&#60;/a&#62;   &#34;vit&#10;&#60;a href=&#34;#&#34;&#62;TWO&#60;/a&#62;   &#34;j.&#10;&#60;a href=&#34;#&#34;&#62;THRee&#60;/a&#62; &#34;j.</span><br></pre></td></tr></table></figure>
<p>可以看到,<code>.</code>命令仅仅重复了三个字符.造成了最后一行的样子.这并不是我们想要的结果.</p>
<h3 id="使用命令模式下的操作符">使用命令模式下的操作符</h3><p><code>U</code>这个可视化模式的操作符对应了一个命令模式下的版本:<code>gU{motion}</code>,但是在语义上有很大不同.<br>在可视化模式命令<code>U</code>的案例中,我们做了两件事:</p>
<ol>
<li><code>vit</code>选中文本</li>
<li><code>U</code>操作文本变成大写<br>在命令模式的案例中,我们弄了一个命令,这个命令由:<code>gU</code>操作和<code>it</code>作为<code>{motion}</code>.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;a href=&#34;#&#34;&#62;ONE&#60;/a&#62; &#34;gUit&#10;&#60;a href=&#34;#&#34;&#62;TWO&#60;/a&#62; &#34;j.&#10;&#60;a href=&#34;#&#34;&#62;THREE&#60;/a&#62; &#34;j.</span><br></pre></td></tr></table></figure>
<p>确实,可视化模式有局限性.但是它也很有用处.因为并不是所有编辑工作都需要重复.所以可视化模式是非常适合单次的编辑.</p>
<h2 id="Tip_24_在块可视化模式下编辑表格化数据">Tip 24 在块可视化模式下编辑表格化数据</h2><p>所有编辑器都可以以行为单位编辑数据.在Vim中,块可视化模式,提供给我们以列为单位编辑数据.</p>
<p>假设有下面的文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter       Page&#10;Normal mode     15&#10;Insert mode     31&#10;Visual mode     44</span><br></pre></td></tr></table></figure>
<p>我们要加点东西,让上面的文字看起来更像表格.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter     | Page&#10;==================&#10;Normal mode |   15&#10;Insert mode |   31&#10;Visual mode |   44</span><br></pre></td></tr></table></figure>
<p>上面的实现步骤是:</p>
<ol>
<li><code>&lt;C-v&gt;3j</code>进入块可视化模式,并向下选择3行</li>
<li><code>r|</code>将选中范围替换为 <code>|</code></li>
<li>同理,复制一行,然后替换为<code>=</code></li>
</ol>
<h2 id="Tip_25_改变多列文本">Tip 25 改变多列文本</h2><p>假设有下面一段css代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li.one   a&#123; background-image: url(&#39;/images/sprite.png&#39;); &#125;&#10;li.two   a&#123; background-image: url(&#39;/images/sprite.png&#39;); &#125;&#10;li.three a&#123; background-image: url(&#39;/images/sprite.png&#39;); &#125;</span><br></pre></td></tr></table></figure></p>
<p>假设<code>sprite.png</code>  已经从<code>images</code>文件夹移动到了<code>components</code>文件夹.我们需要修改三行来改变目录.这时候,我们就能使用块可视化模式了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li.one   a&#123; background-image: url(&#39;/components/sprite.png&#39;); &#125;&#10;li.two   a&#123; background-image: url(&#39;/components/sprite.png&#39;); &#125;&#10;li.three a&#123; background-image: url(&#39;/components/sprite.png&#39;); &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>光标定位到images这个单词的开头.</li>
<li><code>&lt;C-v&gt;jje</code>选中三列的images</li>
<li><code>c</code>删除单词,并进入插入模式, 输入<code>components</code>,然后<code>&lt;Esc&gt;</code>.</li>
</ol>
<p>唯一一个可能造成疑惑的是,当第三步输入单词之后,只改变了第一行.但是,当按了<code>&lt;Esc&gt;</code>之后,三行都改变了.<br>确实Vim的这个功能有点不太人性化.但是,最终结果没有什么区别.习惯就好了</p>
<h2 id="Tip_26_在参差不齐的块选区后面追加内容">Tip 26 在参差不齐的块选区后面追加内容</h2><p>假设有下面一段js代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1&#10;var bar = &#39;a&#39;&#10;var foobar = foo + bar</span><br></pre></td></tr></table></figure></p>
<p>这三行不是一样长的,假设我们想为每一行的后面添加一个<code>,</code> 在<code>Tip2</code>我们通过<code>.</code>完成了这个操作.其实通过块可视化区域也能完成这个任务.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#10;var bar = &#39;a&#39;;&#10;var foobar = foo + bar;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>&lt;C-v&gt;jj$</code>选中全部</li>
<li><code>A;</code>移动到结尾,进入插入模式,并输入</li>
<li><code>&lt;Esc&gt;</code>完成</li>
</ol>
<p>细心可以看出,这个操作和Tip 25差不多意思.<br>主要是通过<code>$</code>改变了矩形的结尾.</p>
<h3 id="Vim关于_i_和_a_的惯例">Vim关于 i 和 a 的惯例</h3><p>Vim有很多从命令模式切换到插入模式的按键.<code>i</code>和<code>a</code>都能完成这个操作.<code>i</code>在光标前进入插入模式,<code>a</code>在光标后进入插入模式.<code>I</code>和<code>A</code>功能类似,是在行开头和行结尾进入插入模式.</p>
<p>在块可视化模式中,<code>A</code>和<code>I</code>的功能和在命令模式下类似.那么<code>a</code>和<code>i</code>呢?</p>
<p>在可视化模式和操作符悬停模式下,<code>a</code>和<code>i</code>有不同的意义.这个在Tip 51会有更深入的讨论.现在记得,使用<code>A</code>和<code>I</code>替代</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-22T08:20:01.000Z"><a href="/2016/07/22/Vim/Vim实践Tips-四/">2016-07-22</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/22/Vim/Vim实践Tips-四/">Vim实践Tips(四)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_13_在插入模式下做修改">Tip 13 在插入模式下做修改</h2><p>如果我们在插入模式下输入错误,没有必要先切换模式然后做修改.除了退格键,我们还有一些插入模式下的命令可以用.</p>
<p>凭借触感打字不仅仅是不看键盘.而是凭借感觉输入.当输入错误的时候,甚至他们不用看到屏幕上的错误就知道自己输入错误了.因为他们指头已经知道自己刚刚按错地方了.</p>
<p>当输入的错误在单词结尾的时候,退格键是有效的纠正方式,但是当错误出现在单词开头的时候呢?</p>
<p>出色的打字员推荐这样一个方式: 当出现错误的时候,删除整个单词,然后重新输入.如果你一分钟能输入<code>60</code>个单词,那么重新输入总会比你单个删除字符更快.当然,如果你打字慢,就可以当成一个练习打字速度的练习.多输入正确的单词,有利于你养成输入的感觉.</p>
<p>当然,你也可以切换到命令模式.把光标跳转到单词开头,修改错误,然后<code>A</code>跳转到句子结尾.这个行为肯定是呀看大于1秒了.重要的是,这个不会提高你对输入的感觉</p>
<p>在插入模式下,就像你预料到的,它删除光标前的字符.下面的快捷键也是挺好的:</p>
<ul>
<li><code>&lt;C-h&gt;</code> 删除前面的一个字符,等于退格键</li>
<li><code>&lt;C-w&gt;</code> 删除前面的一个单词</li>
<li><code>&lt;C-u&gt;</code> 删除到本行开始</li>
</ul>
<p>上面的命令不是插入模式特有,甚至不是Vim特有的,你也可以在Bash Shell中使用它们.</p>
<h2 id="Tip14_回到命令模式">Tip14 回到命令模式</h2><p>插入模式是特定用于文本输入的模式.命令模式才是才是我们花费时间最多的模式,它的名字是<code>normal mode</code>,这个名字说明了一切.所以,会在这两者之前切换就很重要了.</p>
<p>经典的返回命令模式的方式是按<code>&lt;Esc&gt;</code>键,但是对于大多数键盘,这个键有点远.所以,作为备选方案,你可以按<code>Ctrl+[</code>,这个组合件和<code>&lt;Esc&gt;</code>等价.</p>
<ul>
<li><code>&lt;Esc&gt;</code> 切换到命令模式</li>
<li><code>&lt;C-[&gt;</code> 切换到命令模</li>
<li><code>&lt;C-o&gt;</code> 在插入和命令模式下切换</li>
</ul>
<h3 id="遇见插入命令模式">遇见插入命令模式</h3><p>插入命令模式是命令模式的一个特别版本.我们可以出发一个单独命令,之后我们就会进入插入模式.在插入模式中,我们可以通过<code>&lt;C-o&gt;</code>切换到命令模式.</p>
<p>我们会通过<code>zz</code>命令将当前行滚动到屏幕中间.而我经常做的是在插入模式下<code>&lt;C-o&gt;zz</code>,这样会把当前行滚动到屏幕中间,并且可以继续输入.</p>
<h2 id="Tip_15_在不离开插入模式下前提下,从寄存器粘贴">Tip 15 在不离开插入模式下前提下,从寄存器粘贴</h2><p>Vim的复制粘贴命令多数情况下是在命令模式下执行的.但是,有时候我们想在插入模式进行.</p>
<h3 id="映射CapsLock键-">映射<code>CapsLock</code>键.</h3><p>对于Vim的使用者来说,<code>CapsLock</code>键简直就是个威胁.例如本来<code>j</code>是移动.可是当<code>CapsLock</code>之后,它成为了<code>J</code>是联合两行.很多Vimer都把<code>CapsLock</code>映射成了其他键位.例如<code>&lt;Esc&gt;</code>或者<code>Ctrl</code>.我推荐你对它进行映射.</p>
<p>下面一段文字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Practical Vim, by Drew Neil&#10;Read Drew Neil&#39;s</span><br></pre></td></tr></table></figure></p>
<p>我们想通过插入本书书名的方式完成第二行.本书的名字已经在第一行了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Practical Vim, by Drew Neil  &#34; yt,&#10;Read Drew Neil&#39;s Practical Vim            &#34;&#25353;&#38190;&#39034;&#24207;jA &#60;C-r&#62;0.&#60;ESc&#62;</span><br></pre></td></tr></table></figure>
<p><code>yt,</code>复制<code>,</code>之前的单词到寄存器中<br><code>&lt;C-r&gt;0</code> 粘贴寄存器中的内容到当前光标我再的位置.</p>
<p>通用的格式是<code>&lt;C-r&gt;{register}</code>这个<code>register</code>是我们想要插入的寄存器.</p>
<p><code>&lt;C-r&gt;{register}</code> 这个命令对于少数的字符来说,是比较好的.但是如果粘贴大量的文本,你就会感觉到了延迟.因为这个命令从寄存器中粘贴,相当于一个一个的字符进行输入.如果<code>textwidth</code>或者<code>autoindent</code>选项开启了.那么你可能会得到一些不想要的断行或者额外的缩进.</p>
<p><code>&lt;C-r&gt;&lt;C-p&gt;{register}</code>命令更智能一些.它真实的插入文字,并且能够修正缩进问题.所以,如果要从寄存器中粘贴多行文本.我推荐你使用这个命令.</p>
<h2 id="Tip16_在输入处进行计算">Tip16 在输入处进行计算</h2><p>表达式寄存器允许我们执行计算并插入到我们的文档中.</p>
<p>多数Vim的寄存器既可以包含字符组成的字符串,也可以包含一整行文字.我们通过删除或者复制命令设置寄存器的内容.</p>
<p>表达式寄存器有所不同.它可以评估一段Vim脚本代码,然后返回结果.所以,我们可以把它当做一个计算器.它的结果可以和其它的文本寄存器一样使用.</p>
<p>在插入模式下输入<code>&lt;C-r&gt;=</code>,这样,在底行下会有提示.然后就能直接输入计算表达式了.当计算完成.<code>&lt;CR&gt;</code>一下,表达式结果就能直接插入到文档中了.</p>
<p>假设有下面的文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 chairs, each costing $35, totals $</span><br></pre></td></tr></table></figure>
<p>使用寄存器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 chairs, each costing $35, totals $210   &#34;A&#60;C-r&#62;6*35&#60;CR&#62;</span><br></pre></td></tr></table></figure></p>
<h2 id="Tip17_通过字符编码插入字符">Tip17 通过字符编码插入字符</h2><p><strong>Vim可以通过字符编码插入任意字符,通过这个特性,我们可以输入键盘上找不到的字符</strong></p>
<p>在插入模式下,输入<code>&lt;C-v&gt;{code}</code>即可,code是字符的编码.Vim要求code是三位数.所以,如果我们要输入<code>A</code>这个字符,它的字符编码是<code>65</code>,那么我们需要输入<code>&lt;C-v&gt;065</code>.</p>
<p>但是如果我们想要插入大于三位的字符编码怎么办呢?我们可以告诉Vim,要使用十六进制输入<code>&lt;C-v&gt;u{1234}</code>.例如,我们要插入一个倒着的问号.(字符码是<code>00bf</code>) 那么我们输入<code>&lt;C-v&gt;u00bf</code></p>
<p>使用<code>ga</code>命令可以查看文档中字符的编码.命令模式下将光标停留在想要查看的字符上,然后<code>ga</code>,文档的底部将会显示它的信息,包括字符编码,十六进制和十进制表示.</p>
<p>另外一种场景,如果<code>&lt;C-v</code>命令后面跟了非数字键,那么它插入那个键的文字表示,例如我按下<code>&lt;C-v&gt;退格键</code>,那么输入的将是<code>&lt;BS&gt;</code></p>
<h2 id="Tip18_通过连字插入字符-">Tip18 通过连字插入字符.</h2><p><strong>通过字符编码插入字符虽好,但是字符编码难记.通过连字插入会简单一些</strong></p>
<p>在插入模式下,输入<code>&lt;C-k&gt;{char1}{char2}</code>即可</p>
<p>连字通常是有一定的意义的.例如常见的<code>1/2</code>,<code>1/3</code>,我们可以输入<code>&lt;C-k&gt;12</code>,<code>&lt;C-k&gt;13</code>得到.倒置的问号可以通过<code>&lt;C-k&gt;?I</code>得到.</p>
<p>更多的连字可以通过<code>:digraphs</code>查看.</p>
<h2 id="使用替换模式覆盖文字">使用替换模式覆盖文字</h2><p>有下面一段文字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typing in Insert mode extends the line. But in Replace mode&#10;the line length doesn&#39;t change.</span><br></pre></td></tr></table></figure>
<p>我们想把两句话合并成一句话.意味着:</p>
<ol>
<li>将<code>.</code>换成<code>,</code></li>
<li>把<code>B</code>改成<code>b</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typing in Insert mode extends the line, but in Replace mode&#10;the line length doesn&#39;t change.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们使用<code>f.</code>定位光标到<code>.</code>的位置.然后<code>R</code>进入替换模式.然后输入<code>, b</code>替换原来的字符.完成替换之后,我们可以按<code>&lt;Esc&gt;</code>返回命令模式.</p>
<h3 id="使用可视化替换模式">使用可视化替换模式</h3><p>一些字符会给替换模式带来麻烦,例如<code>&lt;Tab&gt;</code>产生的缩进.如果要替换,需要输入很多字符(根据你对tab的设置),这时候,使用<code>gR</code>命令是更好的选择.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-21T09:43:06.000Z"><a href="/2016/07/21/Vim/Vim实践Tips-三/">2016-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/21/Vim/Vim实践Tips-三/">Vim实践Tips(三)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_10_使用计数做一些简单的计算">Tip 10 使用计数做一些简单的计算</h2><p>大多数命令模式下的指令能够和计数搭配使用.我们可以利用这个特性做一些简单的运算.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this character is 5</span><br></pre></td></tr></table></figure>
<p><code>&lt;C-a&gt;</code> 增加计数 (Ctrl+a)<br><code>&lt;C-x&gt;</code> 减少计数 (Ctrl+x)<br>他们可以可数字搭配使用,例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this character is 16 &#34; 10&#60;C-a&#62;</span><br></pre></td></tr></table></figure>
<p>这个<c-a> 如果是在数字字符上,那么就会给他增加数字.如果没有在数字上,那么它会在这行中查找数字,并且跳转到数字上.如果没有那么就不会做任何操作.</c-a></p>
<p>例如下面有一段 css 代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.blog, .news &#123; background-image: url(/sprite.png); &#125;&#10;.blog &#123; background-position: 0px 0px &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们要复制最后一行,然后做一些改变:</p>
<ol>
<li>把单词 <code>blog</code> 换成 <code>news</code></li>
<li>把 <code>0px</code> 换成 <code>-180px</code></li>
</ol>
<p>实现1,可以使用 <code>yyp</code> 然后使用 <code>cw</code> 修改单词.<br>那么2怎么实现呢?</p>
<p>第一种方式是: <code>f0</code>, 然后 <code>i</code> 进入插入模式,输入<code>-18</code>,然后<code>&lt;Esc&gt;</code><br>但是我们的光标不在数字上,那么需要额外的跳转.而 <code>&lt;C-x&gt;</code> 可以自动给我们找到数字.<br>所以,直接 <code>180&lt;C-x&gt;</code> 更快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.blog &#123; background-position: -180px 0px &#125; &#34;180&#60;C-x&#62;</span><br></pre></td></tr></table></figure>
<h2 id="Tip_11_如果可以重复,就别计数">Tip 11 如果可以重复,就别计数</h2><p>我们可以通过提供个数字来减少完成特定任务所需要的按键.但是这不代表我们就该这么做.还是应该思考下到底该重复还是该计数.</p>
<p>假设我们有下面的文字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delete more than one word</span><br></pre></td></tr></table></figure>
<p><code>d2w</code>  和 <code>2dw</code> 都能完成任务.</p>
<ul>
<li><code>d2w</code> 是<code>d</code>, 然后加上<code>2w</code> 的 <code>motion</code> ,理解为: 删除两个单词</li>
<li><code>2dw</code>是2次执行 <code>dw</code> ,理解为: 删除一个单词,执行两次</li>
</ul>
<p>现在让我们想想一个替换方案: <code>dw.</code> 删除一个单词,然后重复之.</p>
<h3 id="讨论几种方式-">讨论几种方式.</h3><p>其实<code>d2w</code>和<code>2dw</code> 没有区别,如果执行之后,按 <code>u</code> ,都会恢复两个单词.如果按<code>dot</code>,将重复删除后两个单词.<br>如果我们要删除下一个单词(总共三个)那我们就需要先<code>u</code>(恢复两个单词),然后<code>d3w</code>.这还是比较麻烦的.<br><code>dw.</code> 按<code>u</code>,会恢复一个单词,如果删除下个单词,只需要重新按<code>dot</code>即可.<br>在这种情况下,重复的优势更明显.</p>
<p>如果我要删除6个单词呢? 我可以 <code>d6w</code> 或者<code>6dw</code>.或者 <code>dw.....</code> ,当然,前者有更少的按键.但是有个问题在这:我们需要数一下单词的数量,而且如果错误了,<code>u</code>会恢复<code>6</code>个单词.而<code>dw.....</code>如果出现错误,<code>u</code>一下,只是恢复一个单词.我们可以更好的控制这个过程.</p>
<p>记住我们的”咒语”: 操作,重复,撤销. </p>
<h3 id="必要时使用计数">必要时使用计数</h3><p>下面的文字,如果我要把 <code>a couple of</code> 换成 <code>some more.</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I have a couple of questions.&#10;I have some more questions. &#34;&#25353;&#38190;&#20381;&#27425;&#26159; c3wsome more</span><br></pre></td></tr></table></figure></p>
<p>在这个场景下,使用dot命令没有什么意义.即使重复了,最后还要按<code>i</code>进入插入模式.这样太笨拙了,所以我还是愿意使用计数.</p>
<p>计数还有个好处,就是能够有个条理清楚的恢复操作.比如我<code>d3w</code>,<code>u</code>就会恢复3个单词</p>
<h1 id="Tip_12_征服结合命令">Tip 12 征服结合命令</h1><p>Vim的强大源于操作符和移动命令的结合.</p>
<h3 id="操作符+移动=操作">操作符+移动=操作</h3><p><code>d{motion}</code> 可以使用<code>dl</code>删除一个字符,<code>daw</code>删除整个单词,<code>dap</code>删除整段.<br><code>c{motion}</code> 和 <code>y{motion}</code>和上面类似</p>
<p>操作符和移动的结合,可以认为是一种语法.第一条规则很简单:一个动作由一个操作符和一个移动组成.学习新的操作符就像学习Vim的词汇表.只要我们遵循简单的语法,随着词汇量增加,我们就能表达更多想法.</p>
<p>假设我们已经知道了通过 daw 删除一整个单词.然后,我们学到了 <code>gU</code>,这也是一个操作符.所以,我们就能通过gUaw把当前单词转换成大写.</p>
<p>再假设我们知道了<code>ap</code>(一整段motion},然后我们就能合成新的操作:<br><code>dap</code> 删除一整段 <code>gUap</code> 让一整段大写.</p>
<p><code>Vim</code>  的语法还有个规则:如果一个操作符被重复输入,那么<code>motion</code>就等于当前行.例如:<br>-<code>dd</code>   删除当前行<br>-<code>&gt;&gt;</code>  缩进当前行<br>-<code>gUgU</code> 或者 <code>gUU</code> 大写当前行 g是后面操作符的一个前缀</p>
<p>Vim的操作符命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25805;&#20316;&#31526;        &#25928;&#26524;&#10;c             Change &#25913;&#21464;&#10;d             Delete &#21024;&#38500;&#10;y             Yank into register &#22797;&#21046;&#21040;&#23492;&#23384;&#22120;&#10;g~            Swap case &#20999;&#25442;&#22823;&#23567;&#20889;&#10;gu            make lowercase &#23567;&#20889;&#10;gU            make upppercase &#22823;&#20889;&#10;&#62;             shift right &#21491;&#31227;&#10;&#60;             shift left &#24038;&#31227;&#10;=             autoindent &#33258;&#21160;&#32553;&#36827;&#10;!             Filter &#123;motion&#125; lines through an external program</span><br></pre></td></tr></table></figure>
<h3 id="拓展Vim整合的力量">拓展Vim整合的力量</h3><p>Vim标准的操作符相对来说比较少,但是我们可以定义新的.</p>
<h3 id="使用现有的操作符自定义移动">使用现有的操作符自定义移动</h3><p>Vim标准的移动命令已经很全面,但是我们还可以增加新的移动和文本对象.</p>
<h3 id="待决模式">待决模式</h3><p>除了明显的插入,命令和底行模式.Vim还有些容易被忽略的模式.待决模式( Operator-Pending mode )就是其中的一个.我们每天都大量使用它,但是每次都持续一小段时间.例如<code>dw</code>,这个模式仅仅持续了你按下<code>d</code>到按下<code>w</code>这中间的这个时间.</p>
<p>如果我们把Vim看做是一个有限状态机.那么待决模式就是仅接受移动命令的状态.当一个操作符被触发的时候,这个状态被激活,在输入移动命令之前,Vim不会做任何操作.当待决模式被激活后,我们可以通过<esc>就可以中断,返回命令模式.</esc></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-19T09:40:15.000Z"><a href="/2016/07/19/Vim/Vim实践Tips(二)/">2016-07-19</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/19/Vim/Vim实践Tips(二)/">Vim实践Tips(二)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tip_5_手动查找和替换">Tip 5 手动查找和替换</h2><p>下面每一行中都有 <code>content</code> 这个单词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;...We&#39;re waiting for content before the site can go live...&#10;&#10;...If you are content with this, let&#39;s go ahead with it...&#10;&#10;...We&#39;ll launch as soon as we have the content...</span><br></pre></td></tr></table></figure>
<p>如果我们想把所有的 <code>content</code> 替换成 <code>copy</code>, 那么可以很简单的想到替换命令.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;:%s/content/copy/g</span><br></pre></td></tr></table></figure>
<p> 但是有时候我们并不想全局替换掉.</p>
<h3 id="懒惰点:不做输入的查找">懒惰点:不做输入的查找</h3><p> 你也许已经猜到<code>.</code>是我最喜欢的单键<code>Vim</code>命令.第二喜欢的是 <code>*</code>,它可以搜索处于光标下面的单词.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;...We&#39;re waiting for copy before the site can go live...&#10;&#10;...If you are copy with this, let&#39;s go ahead with it...&#10;&#10;...We&#39;ll launch as soon as we have the content...</span><br></pre></td></tr></table></figure>
<p> 首先将光标置于 <code>content</code> 上面,然后用<code>*</code>命令去查找它,这时候将发生两个事情:</p>
<ol>
<li><p>光标将跳转到下个匹配处(即下个 <code>content</code> 单词) </p>
</li>
<li><p>所有出现匹配项的地方将高亮显示 (如果没有,使用 <code>:set hls</code> .</p>
</li>
</ol>
<p>上面两件事情发生之后,我们就可以使用 <code>n</code> 命令跳转到下一个.这时候,使用 <code>*nn</code> 可以循环所有匹配,然后光标转到我们开始进行搜索的地方</p>
<h3 id="让更改变得可重复">让更改变得可重复</h3><p>当我们的光标置于 <code>content</code> 的开始位置的时候,我们准备去更改它.这包含两个步骤:</p>
<ol>
<li><p>删除单词 <code>content</code> </p>
</li>
<li><p>输入修改的内容. <code>cw</code> 删除到单词结尾命令,并且进入插入模式.</p>
</li>
</ol>
<p>然后我们输入 <code>copy</code> 这个单词. Vim 将记录我们的键盘点击,直到我们离开插入模式,所以, <code>cwcopy&lt;Esc&gt;</code> 将会被记录为一个单个命令.通过使用<code>.</code>就可以重复上面的操作.</p>
<h2 id="Tip6_Dot公式">Tip6 Dot公式</h2><p>在 Tip2中,我们试着将每个句子后面加<code>;</code> 最后,我们通过 <code>j.</code> 进行重复操作.</p>
<p>在 Tip3中,我们将每个<code>+</code>前后添加空格.  最后,我们通过 <code>;.</code> 进行重复操作</p>
<p>在 Tip5中,我们将 <code>content</code> 替换成 <code>copy</code>,最后,我们通过 <code>n.</code> 进行重复操作.</p>
<h3 id="理想的状态:_一个按键负责移动,一个按键负责执行操作-">理想的状态: 一个按键负责移动,一个按键负责执行操作.</h3><p> 在上面所有的操作中 . 重复最后的更改.这不是他们全部的共同点,我们都还用了一个键去移动光标.这已经是一个不能再好的情况了.我们在将来的编辑中,可以反复看到这个编辑模式.为了方便,我们把这个模式成为 Dot公式 (Dot Formula)</p>
<h2 id="Tip7_拿开你的笔刷">Tip7 拿开你的笔刷</h2><p><code>Normal Mode</code> (命令模式) 可以类比为一个画家,把笔刷离开画布.这时候,他可以休息,可以构思.同理,程序员也可以在 <code>Normal Mode</code> 中进行思考,组织自己的思路.当我们要改变的时候,也不用非得进入插入模式.在 <code>Normal Mode</code>中,我们可以格式化我们的代码,复制,或者移动他们.</p>
<h2 id="Tip8_强化你的撤销">Tip8 强化你的撤销</h2><p>在其他编辑器中,通过在输入一些东西之后进行撤销,可以撤销我们最后输入的单词或者字符.然后在 Vim 中,我们设置可以调整撤销命令的粒度.</p>
<p><code>u</code> 这个命令可以触发撤销命令.它可以撤销包括Normal,Visual还有 Command-Line 模式的更改.当然,也包括在插入模式下的文本输入或者删除.所以我们可以说: <code>i{ 插入一些更改}&lt; Esc&gt;</code>  构成了一个改变. 然后一次<code>u</code> 就可以撤销这个改变.</p>
<p>另外,插入模式中,如果使用了上下左右箭头,那么就相当于在 NormalMode下使用了 <code>hjkl</code>.区别就是我们不用离开插入模式,但是这些操作,会被记录到点公式 (Dot Fomula)中.</p>
<h2 id="Tip9_创建可重复的改变">Tip9 创建可重复的改变</h2><p>vim将重复操作进行了优化,为了利用这个特性.我们需要留心怎么创建可重复的改变</p>
<p>在 Vim 中,做一件事通常有很多方式.但是衡量”好”的方式的机制就是:更少的键盘敲击.</p>
<p>假设我们的光标在 <code>h</code> 这个字母上,我们想要删除单词 <code>nigh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh</span><br></pre></td></tr></table></figure>
<h3 id="1-_向后删除">1. 向后删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh &#34;&#24320;&#22987;&#10;&#10;The end is h &#34;db  &#20174;&#20809;&#26631;&#20301;&#32622;&#21024;&#38500;&#21333;&#35789;&#30340;&#21069;&#38754;&#37096;&#20998;&#10;&#10;The end is  &#34;x &#21024;&#38500;&#24403;&#21069;&#20809;&#26631;&#30340;&#23383;&#31526;</span><br></pre></td></tr></table></figure>
<h3 id="2-_向前删除">2. 向前删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end is nigh   &#34;&#24320;&#22987;&#10;&#10;The end is nigh   &#34;b  &#21521;&#21518;&#31227;&#21160;&#20809;&#26631;&#19968;&#20010;&#21333;&#35789;&#10;&#10;The end is        &#34;dw &#21521;&#21069;&#21024;&#38500;&#19968;&#20010;&#21333;&#35789;</span><br></pre></td></tr></table></figure>
<h3 id="3-_删除整个单词">3. 删除整个单词</h3><p>上面两个解决方案都牵涉到了一些准备工作,例如移动.其实,利用<code>aw</code> 命令可以更精准高效的完成我们的需求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;The end ais nigh   &#34;&#24320;&#22987;&#10;&#10;The end is &#34;daw</span><br></pre></td></tr></table></figure>
<h3 id="4-_哪一个是最可重复的">4. 哪一个是最可重复的</h3><p>上面我们使用了三种方式进行删除一个单词.每种方式中,我们都是按了三个键,那么那种方式是更好的呢?</p>
<p>记住, Vim 优化了重复.那么检验好坏的标准就是重复.下面使用dot 命令来检验三种方式,通过测试发现:</p>
<ul>
<li><p>第一种方式: <code>.</code> 等价于 <code>x</code> (<code>db</code> 是改变操作. <code>x</code> 也是改变操作)</p>
</li>
<li><p>第二种方式: <code>.</code> 等价于 <code>dw</code> (<code>b</code> 是纯移动, <code>dw</code> 是改变操作)</p>
</li>
<li><p>第三种方式: <code>.</code> 等价于 <code>daw</code> (<code>daw</code>是改变操作)</p>
</li>
</ul>
<p>看起来<code>2</code> <code>3</code> 都是挺有用的,但是有个细节 <code>2</code>删除一个单词,但是不会删除对应的空格,表象上来看就是不会移动光标到下个单词上,那么这时候, <code>.</code>这个命令就没什么意义. <code>3</code> 会把要删除的单词附带空格删除,同时光标停留在 <code>is</code> 的结尾.那么<code>.</code>这个操作就能继续删除一个单词. (我强烈建议自己动手试试看)</p>
<p>﻿</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-18T07:12:36.000Z"><a href="/2016/07/18/Vim/Vim实践Tips(一)/">2016-07-18</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/18/Vim/Vim实践Tips(一)/">Vim实践Tips(一)</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="Tip_1_dot_命令">Tip 1 dot 命令</h1><p>说明: . dot 重复上个命令的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line one&#10;&#10;line two&#10;&#10;line three &#10;&#10;line four</span><br></pre></td></tr></table></figure>
<p><code>x</code> :删除当前光标下的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> one &#34; x . . .  x &#21024;&#38500;, . &#37325;&#22797;&#10;&#10;line two&#10;&#10;line three &#10;&#10;line four</span><br></pre></td></tr></table></figure>
<p>如图:<br><img src="http://7xv9rf.com1.z0.glb.clouddn.com/1xdotdot.gif" alt="dot 命令的使用"></p>
<h2 id="几个小提示:">几个小提示:</h2><h3 id=":set_nu_显示行号_:set_nonu_关闭行号显示">:set nu 显示行号 :set nonu 关闭行号显示</h3><p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/2setnu.gif" alt="显示和关闭行号"></p>
<h3 id=":3,5_co_8_将9到12行的内容输出到8行">:3,5 co 8 将9到12行的内容输出到8行</h3><p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/003line_copy.gif" alt="输出范围到领一行"></p>
<h3 id=":3,5_de_删除3到5行的内容">:3,5 de 删除3到5行的内容</h3><p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/004delete.gif" alt="删除范围"></p>
<p><code>&gt;G</code> 增加从当前行到文件末尾所有行的缩进.同理,使用 . 可以重复增加缩进</p>
<p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/005_intent.gif" alt="重复缩进"></p>
<p>还可以利用 j. 做成下面的布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line one&#10;&#10;&#9;line two&#10;&#10;&#9;&#9;line three &#10;&#10;&#9;&#9;&#9;line four</span><br></pre></td></tr></table></figure>
<p><img src="http://7xv9rf.com1.z0.glb.clouddn.com/007_jdot.gif" alt="梯形缩进"></p>
<h1 id="Tip_2_不要重复">Tip 2 不要重复</h1><p>例如,我们想要在下面所有的行后面加一个分号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1&#10;&#10;var bar = &#39;bar&#39;&#10;&#10;var foobar = foo + bar</span><br></pre></td></tr></table></figure>
<p>使用 <code>$</code> 移动到行末尾,<code>a</code>追加然后输入<code>;</code> ,然后按<code>&lt;Esc&gt;</code>返回命令模式.这算完成了第一行</p>
<p>如果对下面两行也应用这个,就应该: <code>j$.</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#10;&#10;var bar = &#39;bar&#39;; &#34;j$.&#10;&#10;var foobar = foo + bar; &#34;j$.</span><br></pre></td></tr></table></figure>
<p>虽然这样也能完成,但是还是差点意思.还是有提升空间的.</p>
<h3 id="减少无关的移动">减少无关的移动</h3><p><code>a</code> 是在当前光标位置后面追加,并自动切换到插入模式</p>
<p><code>A</code> 是在当前行末进行追加,并自动切换到插入模式 相当于 <code>$a</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;&#9;&#34; A;&#60;Esc&#62;&#10;&#10;var bar = &#39;bar&#39;; &#34; j.&#10;&#10;var foobar = foo + bar; &#34; j.</span><br></pre></td></tr></table></figure>
<p><code>d</code> 删除，不能单独用，得跟后续操作符，比如 <code>dd</code> 是删除一整行，<code>d$</code> 是删除直到行的末尾</p>
<p><code>x</code> 删除当前光标下的单个字符</p>
<p><code>c</code> 跟 <code>d</code> 类次，但是删除完成后会进入插入模式</p>
<p><code>c</code> 和 <code>d</code> 都要加入<code>motion</code> <code>motion</code>类似是 <code>w</code> <code>b</code> 等这些</p>
<p><code>23,35 co 66</code> 复制</p>
<p><code>23,35 m 66</code> 剪切</p>
<p><code>23,35 de</code> 删除</p>
<p>几个一个顶俩的快捷键</p>
<p><code>C c$</code> 删除到行末尾,并进入插入模式</p>
<p><code>s cl</code> 替换当前字符: c加motion,l 一个字符</p>
<p><code>S ^C</code> 删除整个行 ^移动到行首,C删除整行</p>
<p><code>I ^i</code> 到行首进行插入</p>
<p><code>A $a</code> 到行尾进行插入</p>
<p><code>o A&lt;CR&gt;</code> 进入下一行,并进入插入模式 <cr>是回车的意思</cr></p>
<p><code>O ko</code> 进入上一行,然后插入</p>
<h2 id="Tip_3_退一步,进三步">Tip 3 退一步,进三步</h2><figure class="highlight"><figcaption><span>foo = "method("+argument1+","+argument2+")";```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#19978;&#38754;&#30340;&#20195;&#30721;&#30475;&#30528;&#19981;&#22826;&#33298;&#26381;,&#22240;&#20026;&#22312;&#25105;&#20204;&#21360;&#35937;&#20013;,&#21152;&#21495;&#20004;&#36793;&#24212;&#35813;&#26377;&#31354;&#26684;.&#37027;&#20040;&#25105;&#20204;&#26469;&#30475;&#24590;&#20040;&#20197;Vim&#30340;&#26041;&#24335;&#23436;&#25104;&#36825;&#20010;&#20219;&#21153;:&#10;&#10;`f+` &#26597;&#25214;&#26368;&#36817;&#30340;`+` , `s` &#26367;&#25442;`+` &#20026; `&#31354;&#26684;+&#31354;&#26684;`&#10;&#10;```var foo = &#34;method(&#34; + argument1+&#34;,&#34;+argument2+&#34;)&#34;;</span><br></pre></td></tr></table></figure>
<p>对于后面的,我们当然可以使用 <code>f+</code> 然后 <code>.</code> 重复替换,完成任务.</p>
<p>但是这里有个新的操作符 <code>;</code> 这个 <code>;</code> 可以重复执行最近的查找操作.<code>f+</code>就是一个查找操作.所以,对于后面的<code>+</code> ,我们可以通过 <code>;.</code> 依次完成替换.</p>
<h2 id="Tip4_操作,重复,撤销">Tip4 操作,重复,撤销</h2><p>通过以上的几个tip,我们学会了,先操作,然后另其重复执行,借此完成一些重复任务.</p>
<p>但是有时候,我们可能在反复的重复操作中,按多了.例如 tip2 中的 j.j.j. 很可能顺序按错了. 如果出现错误,那么我们就可以在出错的时候按 u 来撤销操作.又或者,Tip3中的;按多了(意味着移动的太过了)那么可以使用,来跳回去.</p>
<p>通过以上的描述,能看出来,不同的误操作,对应着不同的撤销方式.下面是个参考表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#24847;&#22270;&#9;&#9;&#9;&#9;&#25805;&#20316;&#9;&#9;&#9;&#9;&#37325;&#22797;&#9;&#9;&#25764;&#38144;&#10;&#10;&#25913;&#21464;&#28857;&#19996;&#35199;&#9;&#9;&#9;&#123;edit&#125;&#9;&#9;&#9;.&#9;&#9;u&#10;&#10;&#34892;&#20869;&#26597;&#25214;&#19979;&#20010;&#23383;&#31526;&#9;f&#123;char&#125;/t&#123;char&#125;&#9;&#9;;&#9;&#9;,&#10;&#10;&#34892;&#20869;&#26597;&#25214;&#21069;&#19968;&#20010;&#23383;&#31526;&#9;F&#123;char&#125;/T&#123;char&#125;&#9;&#9;;&#9;&#9;,&#10;&#10;&#22312;&#25991;&#26723;&#20869;&#26597;&#25214;&#19979;&#20010;&#21305;&#37197;&#9;/pattern&#60;CR&#62; &#9;&#9;n&#9;&#9;N&#10;&#10;&#22312;&#25991;&#26723;&#20869;&#26597;&#25214;&#21069;&#20010;&#21305;&#37197;&#9;?pattern&#60;CR&#62;&#9;&#9;n&#9;&#9;N&#10;&#10;&#25191;&#34892;&#26367;&#25442;&#9;&#9;:s/target/replacement&#9;&#38;&#9;&#9;u&#10;&#10;&#25191;&#34892;&#19968;&#31995;&#21015;&#25913;&#21464;&#9;&#9;qx&#123;changes&#125;q&#9;&#9;@x&#9;&#9;  u</span><br></pre></td></tr></table></figure>
<p><code>f</code> 和 <code>t</code> 的区别是 <code>f</code> 停留光标在查找字符,<code>t</code>光标停留在查找字符之前</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-14T07:25:06.000Z"><a href="/2016/07/14/视频相关/视频裁剪/">2016-07-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/14/视频相关/视频裁剪/">视频裁剪</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="AVAsset">AVAsset</h3><p>AVAsset是一个表现音视频媒体的抽象类.AVAsset对象给我们开发提供了媒体文件的访问接口.<br>这个 AVAsset 可以通过文件创建,也可以是来自用户相册目录的.如果获得了一个视频文件的 AVAsset,我们就可以从中获取静态图片,转换格式,或者是裁剪内容.</p>
<p>通过以下代码,获得特定位置的视频文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString * videoPath = @&#34;a video file path&#34;;&#10;AVAsset *anAsset = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:videoPath] options:nil];</span><br></pre></td></tr></table></figure>
<p>其中 options 是一个字典,这个字典只有一个 key-value:<br><code>AVURLAssetPreferPreciseDurationAndTimingKey</code> value 是 <code>YES</code> 或者 <code>NO</code></p>
<p>这个是设置时间精确度的,如果设置为 YES, 那么会造成很大的开销,但是可以保证操作的精度,对于我的裁剪操作,不用设置.因为我的业务中,裁剪范围是用户滑块操作的,本来精度就要求不高.<br>传递 nil 和 传递 NO, 两者等效.<br>特别的,当进行视频合成操作的时候,需要设置这个字典,并将 value 设置为 <code>YES</code>,因为如果精度不够,可能造成音视频不同步等问题.</p>
<h3 id="AVAssetExportSession">AVAssetExportSession</h3><p>AVAssetExportSession 是一个控制 Asset 异步导出的对象.可以实现裁剪视频,转换格式等需求. 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportSession_ = [[AVAssetExportSession alloc]&#10;                            initWithAsset:anAsset presetName:AVAssetExportPreset960x540]</span><br></pre></td></tr></table></figure>
<p>这个<code>presetName</code> 是系统提供的预设,有一些常用的视频分辨率和视频质量控制的选项.可以按住<code>command</code>自行查看.另外.如果预设的分辨率不能满足需求,我们还可以自定义任意分辨率,这个将在我以后的文章中进行说明.</p>
<p>然后就是配置<code>AVAssetExportSession</code>,下面分别配置了<code>导出路径</code>,<code>导出文件格式</code>,<code>截取范围</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportSession_.outputURL = tempVideoURL;&#10;exportSession_.outputFileType = AVFileTypeMPEG4;&#10;exportSession_.timeRange = [self videoTimeRange:anAsset];</span><br></pre></td></tr></table></figure>
<p>需要说明的是这个截取范围的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(CMTimeRange)videoTimeRange:(AVAsset*)anAsset&#123;&#10;    CMTime start = CMTimeMakeWithSeconds(self.videoRange.startTime, anAsset.duration.timescale);&#10;    CMTime duration = CMTimeMakeWithSeconds(self.videoRange.duration, anAsset.duration.timescale);&#10;    CMTimeRange range = CMTimeRangeMake(start, duration);&#10;    return range;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><code>CMTime</code> 是一个结构体对象,常用的两个值是: <code>value</code> 和 <code>timescale</code>. 两者的关系可以表示为: <code>value/timescale=seconds</code>.</p>
<p>在上面的方法中,我将来自滑块的值(秒为单位),转换成了<code>CMTime</code>然后构造了一个<code>CMTimeRange</code> 对象.</p>
<p>最后进行导出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exportSession_ exportAsynchronouslyWithCompletionHandler:^&#123;&#10;                switch (exportSession_.status) &#123;&#10;                   case AVAssetExportSessionStatusUnknown: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusWaiting: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusExporting: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusCompleted: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusFailed: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;                   case AVAssetExportSessionStatusCancelled: &#123;&#10;                       &#10;                       break;&#10;                   &#125;&#10;               &#125;&#10;           &#125;];</span><br></pre></td></tr></table></figure>
<p>可以对各种状态进行判断.进而采取不同的操作.通常关心的是<code>Failed</code> 和<code>Completed</code> ,前者给用户提示,后者进行后续操作.</p>
<p>到此,就完成了一段视频的裁剪操作.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-18T15:28:19.000Z"><a href="/2016/06/18/ReactiveCocoa/RACObserve-和-rac-textSignal-的搭配使用/">2016-06-18</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/18/ReactiveCocoa/RACObserve-和-rac-textSignal-的搭配使用/">RACObserve 和 rac_textSignal 的搭配使用</a></h1>
  

    </header>
    <div class="entry">
      
        <p>项目中有个小需求,文本框与按钮绑定.当文本框内容符合规则的时候,按钮才会可用.把判定条件修改一下,代码如下:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> RAC(self.loginButton,enabled)  = [self.textFiled.rac_textSignal  map:^id(NSString *value) &#123;&#10;    return @(value.length&#62;3);&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>但是如果在发送请求之后,通过代码清除了文本框的内容,按钮并不会改变状态. </p>
<p> 想到了, 应该是这个 <code>rac_textSignal</code> 出现问题了.<br> 看一下它的实现:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> - (RACSignal *)rac_textSignal &#123;&#10;&#9;@weakify(self);&#10;&#9;return [[[[[RACSignal&#10;&#9;&#9;defer:^&#123;&#10;&#9;&#9;&#9;@strongify(self);&#10;&#9;&#9;&#9;return [RACSignal return:self];&#10;&#9;&#9;&#125;]&#10;&#9;&#9;concat:[self rac_signalForControlEvents:UIControlEventAllEditingEvents]]&#10;&#9;&#9;map:^(UITextField *x) &#123;&#10;&#9;&#9;&#9;return x.text;&#10;&#9;&#9;&#125;]&#10;&#9;&#9;takeUntil:self.rac_willDeallocSignal]&#10;&#9;&#9;setNameWithFormat:@&#34;%@ -rac_textSignal&#34;, self.rac_description];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>几个关键词的解释:<br><code>defer</code> : 将代码的创建推迟到信号被订阅<br><code>concat</code>: 连接信号,第一个信号必须发送完成，第二个信号才会被激活<br><code>map</code> : 映射,将信号内容转换<br><code>takeUtil</code> :  signalA takeUntil:signalB 当signalB激活之后,停止signalA 的订阅</p>
<p>其实主要的是, 这个 <code>signal</code> 是监听的: <code>UIControlEventAllEditingEvents</code> . 那么也就是说对<code>setter</code> 方式不会触发信号 </p>
<p><code>RACObserve</code> 是一个常用的宏,我们都知道是监听属性值改变的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \&#10;&#9;(&#123; \&#10;&#9;&#9;_Pragma(&#34;clang diagnostic push&#34;) \&#10;&#9;&#9;_Pragma(&#34;clang diagnostic ignored \&#34;-Wreceiver-is-weak\&#34;&#34;) \&#10;&#9;&#9;__weak id target_ = (TARGET); \&#10;&#9;&#9;[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \&#10;&#9;&#9;_Pragma(&#34;clang diagnostic pop&#34;) \&#10;&#9;&#125;)</span><br></pre></td></tr></table></figure>
<p>主要代码是:<code>[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self];</code><br>然后这个<code>rac_valuesForKeyPath</code>的实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer &#123;&#10;&#9;return [[[self&#10;&#9;&#9;rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]&#10;&#9;&#9;map:^(RACTuple *value) &#123;&#10;&#9;&#9;&#9;// -map: because it doesn&#39;t require the block trampoline that -reduceEach: uses&#10;&#9;&#9;&#9;return value[0];&#10;&#9;&#9;&#125;]&#10;&#9;&#9;setNameWithFormat:@&#34;RACObserve(%@, %@)&#34;, self.rac_description, keyPath];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>主要代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]</span><br></pre></td></tr></table></figure>
<p>也就是这个是通过 <code>KVO</code> 实现的. 而 <code>KVO</code> 得实现是通过临时生成一个子类,并重写父类的 <code>setter</code> 方法.这个在官方文档中有说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key-Value Observing Implementation Details&#10;&#10;Automatic key-value observing is implemented using a technique called&#160;isa-swizzling.&#160;&#10;The&#160;isa&#160;pointer, as the name suggests, points to the object&#39;s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.&#160;&#10;When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.&#160;&#10;You should never rely on the&#160;isa&#160;pointer to determine class membership. Instead, you should use the&#160;class&#160;method to determine the class of an object instance.</span><br></pre></td></tr></table></figure>
<h3 id="最终实现">最终实现</h3><p>了解了两者的实现,就可以很容易实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.loginButton,enabled) =[ [RACObserve(self.textFiled, text)  merge:self.textFiled.rac_textSignal ] map:^id(NSString *value) &#123;&#10;     return @(value.length&#62;3);&#10;&#125;];</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-15T06:51:18.000Z"><a href="/2016/06/15/Swift/Swift3-新特性/">2016-06-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/15/Swift/Swift3-新特性/">Swift3 新特性 </a></h1>
  

    </header>
    <div class="entry">
      
        <p>看了一下刚出的 Session 406,简单记录一下关于 Swift3.0相比2.2的改动. 能力有限,若有谬误,欢迎指正 .</p>
<h3 id="简化的_API">简化的 API</h3><ul>
<li>优化将方法名切分,将操作中的动词提取,作为方法名.将其余部分作为参数名.</li>
<li>在不引起歧义的情况下,去掉了重复性的名词.</li>
</ul>
<p>Swift 2.2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var array:Array = [1,2]&#10;&#10;array.appendContentsOf([2,3,4])&#10;array.insert(1, atIndex: 0)&#10;&#10;var url = NSURL(string: &#34;randomLoacation&#34;)!&#10;&#10;if url.fileURL &#123;&#125;&#10;var x = url.URLByAppendingPathComponent(&#34;file.txt&#34;)</span><br></pre></td></tr></table></figure>
<p>Swift 3.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Swift.Array&#10;var array:Array = [1,2]&#10;&#10;array.append(contentsOf: [2,3,4])&#10;array.insert(1, at: 0) //index&#27809;&#26377;&#20160;&#20040;&#29305;&#23450;&#20449;&#24687;,&#21482;&#26159;&#37325;&#22797;&#10;&#10;//Foudation.NSURL&#10;var url = NSURL(string: &#34;randomLoacation&#34;)!&#10;if url.isFileURL &#123;&#125; //&#24847;&#24605;&#26356;&#26126;&#30830;&#10;var x = url.appendingPathComponent(&#34;file.txt&#34;)</span><br></pre></td></tr></table></figure>
<h3 id="一致的函数参数标签">一致的函数参数标签</h3><p>原来2.2中, 第一个参数标签可以省略.类似这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func myFunction(a: Int , b: Int , c: Int)&#123;&#10;&#10;&#125;&#10;&#10;myFunction(42, b: 57, c: 39)</span><br></pre></td></tr></table></figure>
<p>在 3.0 中,上面的用法会报错. 需要显式写出标签,类似这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func myFunction(a: Int , b: Int , c: Int)&#123;&#10;    &#10;&#125;&#10;&#10;myFunction(a: 10, b: 10, c: 10)</span><br></pre></td></tr></table></figure>
<p>当然,如果实在不想写,可以在声明的时候使用 <code>_</code> .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func myFunction(_ a: Int , b: Int , c: Int)&#123;&#10;    &#10;&#125;&#10;&#10;myFunction(10, b: 10, c: 10)</span><br></pre></td></tr></table></figure>
<h3 id="移动_Where_语句到函数声明的结尾">移动 Where 语句到函数声明的结尾</h3><p>在 Swift2.2中,泛型约束语句<code>Where</code>需要放到泛型的<code>&lt;&gt;</code>中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func anyCommon&#60;T: SequenceType, U: SequenceType&#10;    where T.Generator.Element : Equatable,&#10;    T.Generator.Element == U.Generator.Element&#62;(lhs: T, rhs: U) -&#62; Bool&#123;&#10;    print(&#34;here&#34;)&#10;    return true;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Swift3.0中,将其提取到声明之后:<br>代码是参考的 Session 中的代码,但是本人用 Xcode8.0的 Playground 报错.但是主旨不会错,就是将<code>Where</code>语句提取出来.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func anyCommons&#60;T: Sequence, U: Sequence&#62;(lhs: T, rhs: U) -&#62; Bool&#10;    where T.Element: Equatable,T.Element == U.Element&#10;&#123;&#10;    print(&#34;here&#34;)&#10;    return true;&#10;    &#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结果未使用警告的方法">结果未使用警告的方法</h3><p>对于一个没有使用的函数返回值(或者自定义的变量值),编译器都会给你一个警告.因为既然你认为有返回值, 而你却没有使用.这可能就是你忘记了.这种操作可能会造成你编码的 bug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func plusOne(_ a : Int) -&#62;Int&#123;&#10;         print(a)&#10;         return a+1&#10;     &#125;&#10;     &#10;     plusOne(3) //&#24471;&#21040;&#35686;&#21578; Result of call to &#39;plusOne&#39; is unused</span><br></pre></td></tr></table></figure>
<p>但是一些情况下.我们确实不需要用到这个返回值,而且仅仅是为了函数的一个副作用( side effect) 而去调用函数. 例如,上面代码中的<code>print(a)</code>.这就是我调用函数的目的.<br>为了消除警告,可以使用如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;func plusOne(_ a : Int) -&#62;Int&#123;&#10;    print(a)&#10;    return a+1&#10;&#125;&#10;&#10;_ =  plusOne(3)</span><br></pre></td></tr></table></figure>
<p>或者使用标记 <code>@discardableResult</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult&#10;func plusOne(_ a : Int) -&#62;Int&#123;&#10;    print(a)&#10;    return a+1&#10;&#125;&#10;&#10;plusOne(3)</span><br></pre></td></tr></table></figure>
<h3 id="索引集合">索引集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let collection = [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;]&#10;&#10;var i = collection.startIndex</span><br></pre></td></tr></table></figure>
<p>在 Swift 2.2 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift 2 : var next = i.successor()</span><br></pre></td></tr></table></figure>
<p>在 Swift 3.0 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var next = collection.index(after: 2)</span><br></pre></td></tr></table></figure>
<h3 id="浮点型和数值型">浮点型和数值型</h3><ul>
<li>Float,Double,Float80 和 CGFloat统一使用新的浮点协议( Floating Point Protocol )</li>
<li>提供 IEEE-754 相关的属性和方法 (IEEE 754 标准是IEEE二进位浮点数算术标准（IEEE Standard for Floating-Point Arithmetic）的标准编号  ，等同于国际标准ISO/IEC/IEEE 60559[2])</li>
<li>允许在所有的浮点类型上使用算法泛型(水平有限,原文是:permits algrithms to be gerneric over all floating point types)</li>
</ul>
<p>用 PI 来举个例子:<br>Swift 2.2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let v = 2 * Float(M_PI)</span><br></pre></td></tr></table></figure>
<p>而在 Swift3.0中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let v = 2 * Float.pi</span><br></pre></td></tr></table></figure>
<p>如果第一个操作数是浮点数,还可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let anotherV = 2.0 * .pi / 180</span><br></pre></td></tr></table></figure>
<h3 id="隐式解包可选">隐式解包可选</h3><p>在 Swift2.2中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func f(value: Int!)&#123;&#10;    let x = value + 1 // x &#26159; Int &#31867;&#22411; - &#24378;&#21046;&#35299;&#21253;&#10;    let y = value     // y &#26159; Int!&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Swift 3.0 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func f(value: Int!)&#123;&#10;    let x = value + 1 // x &#26159; Int &#31867;&#22411; - &#24378;&#21046;&#35299;&#21253;&#10;    let y = value     // y &#26159; Int?&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体参考:<br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md" target="_blank" rel="external">SE-0054</a></p>
<h3 id="一些细节的增强">一些细节的增强</h3><ul>
<li>当前文件访问级别,新增的权限控制关键字 <code>fileprivate</code> <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md" target="_blank" rel="external">SE-0025</a></li>
<li><code>case</code>中的标签可以使用多种模式 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0043-declare-variables-in-case-labels-with-multiple-patterns.md" target="_blank" rel="external">SE-0043</a></li>
<li>泛型别名 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md" target="_blank" rel="external">SE-0048</a></li>
<li>引用Objective-C 的 key-paths <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md" target="_blank" rel="external">SE-0062</a></li>
<li>引用 Objective-C中属性的 getter 和 setter <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md" target="_blank" rel="external">SE-0064</a></li>
<li>协议和协议拓展的别名 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md" target="_blank" rel="external">SE-0092</a><h3 id="移除的功能">移除的功能</h3></li>
</ul>
<ol>
<li>函数柯里化<a href="http://www.cocoachina.com/ios/20141110/10166.html" target="_blank" rel="external">Currying介绍</a></li>
<li>函数参数中的 <code>var</code> <a href="http://www.swiftcafe.io/2016/05/05/swift3-var/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">详细介绍</a></li>
<li>去掉 <code>++</code> 和 <code>--</code> 操作符</li>
<li>C 风格的for循环</li>
<li>通过元组的形式传递函数参数列表 .<a href="http://www.paulrobinson.net/function-parameters-are-tuples-in-swift/" target="_blank" rel="external">详细介绍</a></li>
</ol>
<p>对第5条做一个说明:<br>在 swift 2.2 中,我们可以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let param = (20,&#34;kenny&#34;,&#34;male&#34;)&#10;&#10;func personInfo(age: Int ,_ name: String ,_ gender: String)&#123;&#10;&#10;&#125;&#10;&#10;personInfo(param)&#10;&#10;//&#20063;&#21487;&#20197;&#19981;&#30465;&#30053;&#26631;&#31614;&#10;&#10;let param = (age:20, name:&#34;kenny&#34;, gender:&#34;male&#34;)&#10;&#10;func personInfo(age age: Int , name: String , gender: String)&#123;&#10;&#10;&#125;&#10;&#10;personInfo(param)</span><br></pre></td></tr></table></figure>
<p>这个语法在 Swift3.0中被去掉了.原因是这么传递,可能会和有一个元组类型参数的函数混淆.</p>
<p>参考 : WWDC 2016 Session 402 What’s new in Swift</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-14T02:18:56.000Z"><a href="/2016/06/14/Swift/在-Swift-中使用DEBUG标记/">2016-06-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/14/Swift/在-Swift-中使用DEBUG标记/">在 Swift 中使用DEBUG标记</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在 OC 中,我们经常会使用 <code>DEBUG</code> 标记来区分开发版本和发行版本,例如,控制调试信息的打印.</p>
<p>但是在使用 Swift 之后,我们发现<code>DEBUG</code> 不能正常工作.原因是 Swift 中没有<code>DEBUG</code>这个标记.例如下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func GUILog&#60;T&#62;(_ message: T, fileName: String = #function, methodName: String = #function, lineNumber: Int = #line) &#123;&#10;    #if DEBUG&#10;    print(&#34;\(methodName)[\(lineNumber)]:\(message)&#34;)&#10;    #endif&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>虽然并不会报错,但是始终不会有打印.</p>
<h3 id="解决方案">解决方案</h3><p>在 <code>Build Settings</code> 中搜索 <code>other swift flags</code><br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658688864325.jpg" alt=""><br>点击图中红色框内部(注意不是直接点击<code>+</code>),会出现一个这样的对话框.(可能已经有其他标记,如果你使用了 <code>cocoapods</code> 的话,不过不用在意),点击左下角的+ ,或者双击任意空白行,输入<code>-DDEBUG</code>.<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658689870706.jpg" alt=""><br>点击其它任意区域.结果如图<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658693876738.jpg" alt=""></p>
<p>现在,<code>DEBUG</code>就能正常工作了!<br>可以通过调整模式来进行测试:<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658692067377.jpg" alt=""></p>
<p>把图中的地方改成<code>Release</code>,即可进行测试.</p>
<h3 id="Tips">Tips</h3><p>这个编译标记可以随便定义,并不是只能是<code>DEBUG</code>,只要标记能够对应,即可正常工作.编译器只是会看,在<code>Debug</code>模式下,有哪些标记.(或者在 <code>Release</code> 模式下有哪些标记.)例如:<br><img src="http://7xkv7m.com1.z0.glb.clouddn.com/%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8DEBUG%E6%A0%87%E8%AE%B014658693876738.jpg" alt=""><br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func GUILog&#60;T&#62;(_ message: T, fileName: String = #function, methodName: String = #function, lineNumber: Int = #line) &#123;&#10;    #if DEFAULT&#10;    print(&#34;\(methodName)[\(lineNumber)]:\(message)&#34;)&#10;    #endif&#10;&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->




<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/categories/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/categories/Git/">Git</a><small>1</small></li>
  
    <li><a href="/categories/ReactiveCocoa/">ReactiveCocoa</a><small>3</small></li>
  
    <li><a href="/categories/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/categories/Swift进阶/">Swift进阶</a><small>4</small></li>
  
    <li><a href="/categories/Vim/">Vim</a><small>5</small></li>
  
    <li><a href="/categories/iOS-Tips/">iOS Tips</a><small>14</small></li>
  
    <li><a href="/categories/主页维护记录/">主页维护记录</a><small>4</small></li>
  
    <li><a href="/categories/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/categories/开发环境相关/">开发环境相关</a><small>5</small></li>
  
    <li><a href="/categories/悟/">悟</a><small>1</small></li>
  
    <li><a href="/categories/知识技巧总结/">知识技巧总结</a><small>1</small></li>
  
    <li><a href="/categories/算法专题/">算法专题</a><small>1</small></li>
  
    <li><a href="/categories/视频相关/">视频相关</a><small>1</small></li>
  
    <li><a href="/categories/辅助编程技能/">辅助编程技能</a><small>7</small></li>
  
    <li><a href="/categories/重构、模式、架构/">重构、模式、架构</a><small>10</small></li>
  
    <li><a href="/categories/高效OC编程/">高效OC编程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/tags/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/tags/Git-命令/">Git 命令</a><small>1</small></li>
  
    <li><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a><small>3</small></li>
  
    <li><a href="/tags/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/tags/Swift-进阶/">Swift 进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶/">Swift进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶-variable-with-a-setter-must-also-have-a-getter/">Swift进阶 variable with a setter must also have a getter</a><small>1</small></li>
  
    <li><a href="/tags/Vim/">Vim</a><small>2</small></li>
  
    <li><a href="/tags/iOS-Tips/">iOS Tips</a><small>3</small></li>
  
    <li><a href="/tags/主页维护记录/">主页维护记录</a><small>2</small></li>
  
    <li><a href="/tags/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/tags/小脚本大智慧/">小脚本大智慧</a><small>1</small></li>
  
    <li><a href="/tags/开发环境相关/">开发环境相关</a><small>3</small></li>
  
    <li><a href="/tags/悟/">悟</a><small>1</small></li>
  
    <li><a href="/tags/正则表达式/">正则表达式</a><small>2</small></li>
  
    <li><a href="/tags/测试小样/">测试小样</a><small>1</small></li>
  
    <li><a href="/tags/算法专题-字符串/">算法专题 字符串</a><small>1</small></li>
  
    <li><a href="/tags/视频相关/">视频相关</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
    <li><a href="/tags/辅助编程技能/">辅助编程技能</a><small>2</small></li>
  
    <li><a href="/tags/重构、模式、架构/">重构、模式、架构</a><small>5</small></li>
  
    <li><a href="/tags/问题解决和思考/">问题解决和思考</a><small>5</small></li>
  
    <li><a href="/tags/高效OC编程/">高效OC编程</a><small>4</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 桂庆
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>