<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | Kenny 肉桂的主页</title>
  <meta name="author" content="桂庆">
  
  <meta name="description" content="Kenny 肉桂的主页 记录自己的进步">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Kenny 肉桂的主页"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kenny 肉桂的主页" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Kenny 肉桂的主页</a></h1>
  <h2><a href="/">记录自己的进步</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-07-20T05:49:42.000Z"><a href="/2015/07/20/开发环境相关/自用Xcode插件整理/">2015-07-20</a></time>
      
      
  
    <h1 class="title"><a href="/2015/07/20/开发环境相关/自用Xcode插件整理/">自用Xcode插件整理</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="RTImageAssets">RTImageAssets</h2><p>根据某张图片自动生成 1x 2x 3x的图片 ,还有关于App图标的功能.</p>
<p><a href="https://github.com/rickytan/RTImageAssets" target="_blank" rel="external">项目地址</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-07-05T06:53:05.000Z"><a href="/2015/07/05/辅助编程技能/xvim相关/">2015-07-05</a></time>
      
      
  
    <h1 class="title"><a href="/2015/07/05/辅助编程技能/xvim相关/">xvim相关</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="配置常用功能">配置常用功能</h2><p>用户目录下的  .xvimrc 如果没有,新建一个即可<br>touch .xvimrc</p>
<h3 id="设置按钮映射">设置按钮映射</h3><p><code>imap zz &lt;Esc&gt;</code> 映射 zz 为 Esc 的功能<br><code>set ic</code> set ignore case 搜索的时候,忽略大小写</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-05T00:56:46.000Z"><a href="/2015/06/05/开发环境相关/Xocde插件失效解决-转载/">2015-06-05</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/05/开发环境相关/Xocde插件失效解决-转载/">Xocde插件失效解决[转载]</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="context">context</h2><p>XCode的插件大大丰富了XCode的功能，而且有了Alcatraz，插件的管理也非常容易，像我这种Vim党完全离不开XVim。但是有个非常恼人的问题：一旦升级XCode，插件就失效！<br>之前XCode升级到6.2的时候遇到过插件失效的问题，Google之后把一段很长命令复制到Terminal后运行一下即可，当时一看解决了， 顿时觉得满足感爆棚，自己可以拯救地球了~就没有再深入，结果升级到6.3时又遇到了。“同样的招式对圣斗士是不能使用第二次的！”，同样的坑对有节操的 程序员是不能掉进去第二次的！因此这一次一定要搞清楚为什么会这样，以后再次遇到了如何解决。<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/06/05/开发环境相关/Xocde插件失效解决-转载/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-04T06:10:47.000Z"><a href="/2015/06/04/高效OC编程读书心得/Tip9 以类族模式隐藏实现细节/">2015-06-04</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/04/高效OC编程读书心得/Tip9 以类族模式隐藏实现细节/">Tip9 以类族模式隐藏实现细节</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="context">context</h2><p>类族是一种很有用的模式,可以隐藏抽象基类背后的细节.OC的系统框架中,普遍使用这个模式.</p>
<p>一个例子: UIButton<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton * button = [UIButton buttonWithType];</span><br></pre></td></tr></table></figure></p>
<p>该方法返回的对象类型取决于传入的 <code>type</code> ,不同的<code>type</code>决定了这个 button 将来的一些属性的不同(或者说可供设置的属性的不同)</p>
<p>要实现类似的功能,如果不用类族,那么还可能是一个类中的枚举.比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawRect:(CGRect)rect&#123;&#10;&#9;if(_type == typeA)&#123;&#10;&#9;&#9;//&#32472;&#21046;&#19968;&#20010; typeA &#31867;&#22411;&#30340; Button&#10;&#9;&#125;else if (_type == typeB)&#123;&#10;&#9;&#9;//&#32472;&#21046;&#19968;&#20010; typeB &#31867;&#22411;&#30340; Button&#10;&#9;&#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的类型,这么看来没有问题,但是如果类型太多,这样就显得非常笨拙了.</p>
<p>稍微聪明一点的程序员,会把这样的代码重构.不同的实现放到子类中,父类中存放公共代码.但是这样也有一个缺点,就是开发者需要知道所有的子类.</p>
<p>现在类族的好处就显而易见了.</p>
<h2 id="一个自定义的类族">一个自定义的类族</h2><p>假设我们有一个 Person 类,Person 分为不同的职业.有老师,学生,医生.那么类族的实现应该是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger,PersonType) &#123;&#10;    PersonTypeDoctor,&#10;    PersonTypeTeacher,&#10;    PersonTypeStudent&#10;&#125;;&#10;&#10;+ (Person *) personWithType:(PersonType)type&#123;&#10;    switch(type)&#123;&#10;        case PersonTypeDoctor:&#10;            return [[PersonDoctor alloc]init];&#10;            break;&#10;        case PersonTypeTeacher:&#10;            return [[PersonTypeTeacher alloc]init];&#10;            break;&#10;        case PersonTypeStudent:&#10;            return [[PersonTypeStudent alloc]init];&#10;            break;&#10;            &#10;    &#125;&#10;    &#10;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-03T09:06:06.000Z"><a href="/2015/06/03/Swift/Currying/">2015-06-03</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/03/Swift/Currying/">Currying</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="context">context</h2><p>最近开始读喵神的书,书是好书,就是非常概略,不利于 Swift 基础薄弱的童鞋,所以,借着自己阅读的理解和查阅的资料,把每个知识点扩充一下.</p>
<h2 id="Currying">Currying</h2><p><strong>Currying就是把一个多参数的方法，拆解为只有第一个参数的方法，这个方法的返回值不是一个具体的值，而是一个新的方法，这个方法的参数是原先的方法刨去第一个参数后的“剩下的方法的片段”，可以理解为，把一个多参数方法只作为某一种模板</strong></p>
<h2 id="基本写法">基本写法</h2><p>基本结构:</p>
<p>func <code>function name</code> (<code>parameters</code>)(<code>parameters</code>)-&gt;<code>return type</code>{<br>    <code>statements</code><br>}</p>
<p>一个 Currying<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func add(originValue: Int)(inputValue: Int) -&#62; Int &#123;&#10;        return originValue + inputVlue&#10;    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个写法就是 <code>currying</code> 函数的基本写法,<code>originValue</code> 是他的固定的基数(或者说基础参数). <code>inputValue</code>是以后调用的不同的输入值.基础参数构建了一个类似模板的东西,而输入值构建了我们想要的最终结果.</p>
<p>使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let addWith10 = add(10)&#10;let addWith100 = add(100)</span><br></pre></td></tr></table></figure>
<p>以上,分别构建了一个以 10 和100 为基数的方法.它们都是新的方法,但是是我们最开始方法的一部分,如果要使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result1 = addWith10(inputValue: 1)&#10;let result2 = addWith100(inputValue: 1)</span><br></pre></td></tr></table></figure>
<p>result1的结果是  11<br>result2的结果是  101</p>
<p>以上就是 Currying 的一个小剖析,下面我们从一般函数入手,看看Currying到底是怎么演化的.</p>
<h2 id="从函数开始">从函数开始</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func sum(a: Int,b: Int) -&#62; Int &#123;&#10;    return a + b&#10;&#125;&#10;sum(1, 2)   //&#36755;&#20986;3</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的函数,如果用 Currying 的写法,会变成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func sum(a: Int)(b: Int) -&#62; Int &#123;&#10;    return a + b&#10;&#125;&#10;var sumByFirst = sum(1)&#10;sumByFirst(b: 4) //&#36755;&#20986;5</span><br></pre></td></tr></table></figure>
<p>只需要传入第一个参数，返回的sumByFirst是一个函数，它包含剩余的其他参数，以及刚刚传入进去的那个1，接着以它自己作为方法传入第二个参数b就行了。<br>如果是三个参数就像这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func sum(a: Int)(b: Int)(c: Int) -&#62; Int &#123;&#10;    return a + b + c&#10;&#125;&#10;var sumByFirst = sum(1)&#10;var sumBySecond = sumByFirst(b: 4)&#10;sumBySecond(c: 10)  //&#36755;&#20986;15</span><br></pre></td></tr></table></figure>
<p>除了第一个参数以外，其他的参数都要显式地写上参数标签，并且要按参数排列的顺序调用。<br>一个括号中放两个参数也可以： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func sum(a: Int)(b: Int, c: Int) -&#62; Int &#123;&#10;    return a + b + c&#10;&#125;&#10;var sumByFirst = sum(1)&#10;sumByFirst(b: 4,c: 10)  //&#36755;&#20986;15</span><br></pre></td></tr></table></figure>
<p>在某些情况下，你可能会用某个相同的参数重复调用某个方法，那么利用柯里化会使代码更易于维护：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func sum(a: Int)(b: Int) -&#62; Int &#123;&#10;    return a + b&#10;&#125;&#10;var sumWithFive = sum(5)&#10;sumWithFive(b: 5)&#10;sumWithFive(b: 10)&#10;sumWithFive(b: 15)</span><br></pre></td></tr></table></figure>
<p>因为 Swift 的 Selector  只能通过字符串生成,这会面临一个很严重的问题,就是难以重构,并且无法在编译期间进行检查,这是非常危险的行为.但是利用方法的 Currying ,我们可以解决这个问题.</p>
<p>参考网址:</p>
<p><a href="http://blog.csdn.net/zhangao0086/article/details/38851759" target="_blank" rel="external">http://blog.csdn.net/zhangao0086/article/details/38851759</a></p>
<p><a href="http://www.tuicool.com/articles/bMBjUfn" target="_blank" rel="external">http://www.tuicool.com/articles/bMBjUfn</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-03T01:23:59.000Z"><a href="/2015/06/03/主页维护记录/新版多说的配置/">2015-06-03</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/03/主页维护记录/新版多说的配置/">新版多说的配置</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="context">context</h2><p>最近给博客更换了一款主题,但是发现多说评论失效了,用一期的配置方法进行配置,还报错.现在重新整理</p>
<h2 id="前提">前提</h2><p>已经注册多说开发者帐号,并且创建了应用.</p>
<h2 id="步骤">步骤</h2><ol>
<li><p>取消HEXO博客根目录中的 _config.yml 中 disqus_shortname: ，暂时不用这个功能，直接永久开启多说评论。(如果没有此参数,可以忽略)</p>
</li>
<li><p>打开 <code>themes\light\layout_partial\comment.ejs</code> (如果没有,请创建)将你的通用代码粘贴进来,并修改三处地方:</p>
</li>
</ol>
<p><code>data-thread-key=&quot;&lt;%= page.path %&gt;</code><br><code>data-title=&quot;&lt;%= page.title %&gt;&quot;</code><br><code>data-url=&quot;&lt;%= page.permalink %&gt;&quot;</code></p>
<p>最终我的完整代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;!-- &#22810;&#35828;&#35780;&#35770;&#26694; start --&#62;&#10;&#9;&#60;div class=&#34;ds-thread&#34; data-thread-key=&#34;&#60;%= page.path %&#62;&#34; data-title=&#34;&#60;%= page.title %&#62;&#34; data-url=&#34;&#60;%= page.permalink %&#62;&#34;&#62;&#60;/div&#62;&#10;&#60;!-- &#22810;&#35828;&#35780;&#35770;&#26694; end --&#62;&#10;&#60;!-- &#22810;&#35828;&#20844;&#20849;JS&#20195;&#30721; start (&#19968;&#20010;&#32593;&#39029;&#21482;&#38656;&#25554;&#20837;&#19968;&#27425;) --&#62;&#10;&#60;script type=&#34;text/javascript&#34;&#62;&#10;var duoshuoQuery = &#123;short_name:&#34;guiqingblog&#34;&#125;;&#10;&#9;(function() &#123;&#10;&#9;&#9;var ds = document.createElement(&#39;script&#39;);&#10;&#9;&#9;ds.type = &#39;text/javascript&#39;;ds.async = true;&#10;&#9;&#9;ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;;&#10;&#9;&#9;ds.charset = &#39;UTF-8&#39;;&#10;&#9;&#9;(document.getElementsByTagName(&#39;head&#39;)[0] &#10;&#9;&#9; || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);&#10;&#9;&#125;)();&#10;&#9;&#60;/script&#62;&#10;&#60;!-- &#22810;&#35828;&#20844;&#20849;JS&#20195;&#30721; end --&#62;</span><br></pre></td></tr></table></figure>
<ol>
<li>打开<code>themes\light\layout_partial\article.ejs</code><br>在最后一行加上如下代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;% if(!index)&#123; %&#62;&#10;&#60;%- partial(&#39;comment&#39;) %&#62;&#10;&#60;% &#125; %&#62;</span><br></pre></td></tr></table></figure>
<h2 id="后记">后记</h2><p>在早期版本,第二步骤中的三个文章参数不是必须的,但是新版中,如果不配置,会报错.样式也不能正常显示 .</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-02T23:34:58.000Z"><a href="/2015/06/03/辅助编程技能/定位程序崩溃点的方法探究/">2015-06-03</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/03/辅助编程技能/定位程序崩溃点的方法探究/">定位程序崩溃点的方法探究</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="context">context</h2><p>昨天遇到问题,当我的 NavitgationController back 的时候,程序崩溃,诡异的地方是: 控制台完全没有任何打印,崩溃的断点直接回到了 main 函数中.</p>
<h2 id="几个尝试">几个尝试</h2><p>想到之前曾经读过一篇出现在这样情景崩溃的文章:有对象依赖被 pop 的控制器,结果导致了崩溃,但是经过仔细排查,发现并没有这样的情况.</p>
<h2 id="查找资料">查找资料</h2><p>网上对崩溃问题的定位常规方法总结起来有:</p>
<h3 id="1-添加通用断点">1.添加通用断点</h3><ol>
<li>选择 BreakPoint Navigator,点击右下角的 ‘+’ ,然后在弹窗中选择 ‘Add Exception BreakPoint’<br><img src="http://i1.tietuku.com/e8b80841e86eb86a.png"></li>
</ol>
<p><img src="http://i1.tietuku.com/de970099a16ad135.png"></p>
<ol>
<li>右键断点,选择 ‘Edit BreakPoint’,检查设置如下<br><img src="http://i1.tietuku.com/d135fc352fd61583.png"></li>
</ol>
<p>然后运行程序,程序就能定位到出现崩溃的代码.</p>
<p>但是很遗憾的是,这种方式只能解决大部分的问题(比如不识别的selector 等),有很多类型的崩溃它是不能定位的 </p>
<p>比如出现 <code>EXEC_BAD_ACCESS</code>这种错误,以上的方法是不能定位的.</p>
<h3 id="2-重写object的respondsToSelector方法">2.重写object的respondsToSelector方法</h3><p>1.重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object.因为有时候程序崩溃根本不知错误发生在什么地方。</p>
<p>在可能出现问题的 .m 或者.mm 文件中加入以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _FOR_DEBUG_  &#10;-(BOOL) respondsToSelector:(SEL)aSelector &#123;  &#10;    printf(&#34;SELECTOR: %s\n&#34;, [NSStringFromSelector(aSelector) UTF8String]);  &#10;    return [super respondsToSelector:aSelector];  &#10;&#125;  &#10;#endif</span><br></pre></td></tr></table></figure>
<ol>
<li>在 <code>other c flags</code>中加入<code>-D _FOR_DEBUG_</code>（记住请只在<code>Debug Configuration</code>下加入此标记）,这样当你程序崩溃时，Xcode的console上就会准确地记录了最后运行的object的方法。</li>
</ol>
<p><img src="http://i1.tietuku.com/4399070fa7215690.png"><br>很不幸,这样还是没有定位我出现问题的代码.</p>
<h2 id="最终方案">最终方案</h2><p>首先说一下 EXC_BAD_ACCESS 这个错误，可以这么说，90%的错误来源在于对一个已经释放的对象进行release操作.那么我们应该启用 僵尸对象.方法如下:</p>
<p><code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Arguments 的 Environment Variables 中，增加标计位NSZombieEnabled设为YES)</code><br><img src="http://i1.tietuku.com/d7c5ed9195b06916.png"></p>
<p>这样,就能看到崩溃的具体原因了.但是如果想知道代码,这个<a href="http://www.jb51.net/article/38948.htm" target="_blank" rel="external">原文</a>说需要借助 Xcode 控制台的 GDB,很不幸的是,高版本的 Xcode 中,已经没有切换到 GDB 的功能了.网上也有帖子介绍 GDB 对应 lldb 的指令是什么,很不幸,都不能正常工作,所以这里不在罗列.</p>
<p>后来,我想到是否可以借助终端来完成任务?</p>
<p>那么问题来了,终端怎么知道这个内存地址是属于谁的?<br>后来想到,可以通过活动监视器,拿到我们程序进程的 pid<br><img src="http://i1.tietuku.com/623a316bb0e053be.png"><br>我的是 <code>1175</code></p>
<p>然后参考刚刚<a href="http://www.jb51.net/article/38948.htm" target="_blank" rel="external">原文</a>中的指令, <code>sudo malloc_history 1175 0x7a692620</code><br>后面一个参数是崩溃的地址.</p>
<p>此时终端提示,没有打印 <code>MallocStackLogging</code> .<br><img src="http://i1.tietuku.com/c13979bcb1add8c6.png"></p>
<p>其实这里是需要在 Xocde 中配置的.按照刚刚配置 <code>NSZombieEnabled</code>的位置和方式,添加一个参数:</p>
<p><code>MallocStackLoggingNoCompact</code> 值设置为 <code>YES</code></p>
<p>然后继续重新编译运行,查看 pid ,查看崩溃的内存地址.</p>
<p><img src="http://i1.tietuku.com/e197b876e9fa3a52.png"></p>
<p>见到终端打印出了调用顺序,一般来说,是最后一个你自定义的方法导致的崩溃.</p>
<p>然后就是解决 bug 了,祝好运 ~</p>
<p>参考网址:<br><a href="http://blog.csdn.net/totogo2010/article/details/8949440" target="_blank" rel="external">http://blog.csdn.net/totogo2010/article/details/8949440</a><br><a href="http://mobile.51cto.com/iphone-279455.htm" target="_blank" rel="external">http://mobile.51cto.com/iphone-279455.htm</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-01T09:57:26.000Z"><a href="/2015/06/01/知识技巧总结/2015-06-01滚动监听-触摸点获取-Tranform-RecealApp/">2015-06-01</a></time>
      
      
  
    <h1 class="title"><a href="/2015/06/01/知识技巧总结/2015-06-01滚动监听-触摸点获取-Tranform-RecealApp/">2015-06-01滚动监听 触摸点获取 Tranform RecealApp</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概要">概要</h2><ul>
<li>UITableView 滚动行为的监听,触摸点的获取</li>
<li>CGAffineTransformMakeTranslation和CGAffineTransformTranslate</li>
<li>reveal app 的项目集成</li>
<li>inputAccessoryView 遇到的几个问题</li>
</ul>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/06/01/知识技巧总结/2015-06-01滚动监听-触摸点获取-Tranform-RecealApp/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-20T02:01:14.000Z"><a href="/2015/05/20/iOS Tips/关于-property中NSString的copy/">2015-05-20</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/20/iOS Tips/关于-property中NSString的copy/">关于@property中NSString的copy-深入细节</a></h1>
  

    </header>
    <div class="entry">
      
        <p>前几天和东盟君讨论关于在 <code>@property(nonatomic,copy)NSString * string;</code>中 <code>copy</code>的使用问题. 虽然自己很明白,见到<code>NSString</code>,果断用 <code>copy</code>,但是却说不出个道道.</p>
<p>今天偶尔在一片国外论坛的文章上看到了关于这个的内容(因为在pad上看的,具体地址没法引用了).所以简单记录一下.</p>
<p><strong>因为类似 NSString这样的不可变父类,它们有可变的子类(比如 NSMutableString),那么就可能造成修改指针指向的结果,而这是我们不愿意看到的</strong></p>
<p>是比较抽象的描述,要弄明白这段话,需要明确 <code>copy</code> 做了什么 ?</p>
<p>在官方的描述中: <code>copy</code>是复制一个对象,并强引用它.</p>
<p>那么开始解释一开始的话:</p>
<p>假设我有一个 <code>Person</code> 类,他有一个 <code>name</code>属性,它是<code>NSString</code>类型的.不可变对象对吧.</p>
<p>那么问题来了,下面的语法是成立的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> NSMutableString * mutableString = [[NSMutableString alloc]initWithString:@&#34;gg&#34;];&#10; //1&#10;per.name = mutableString;</span><br></pre></td></tr></table></figure>
<p>上面1处首先语法没有问题, NSString是 NSMutableString的父类.<br>然后这个时候,如果 <code>name</code>属性是 <code>@property</code> 是 <code>strong</code>的,<br>那么 <code>per.name</code> 和 <code>mutableString</code> 指向的是同一块内存区域,<br>那么,我就可以通过修改 <code>mutableString</code>来修改<code>per.name</code>了,而当初我们既然选择了 <code>NSString</code>,那么就是考虑到不会对其进行修改的.所以,这样违背了我们的初衷.</p>
<p>如果是<code>copy</code>,<code>per.name</code>在使用前会复制一份出来,这样使用的其实是它的副本,即使修改了<code>mutableString</code>也不会对<code>per.name</code>的本尊造成影响.</p>
<h3 id="关于_copy_和_mutableCopy">关于 copy 和 mutableCopy</h3><p>现在我说的这两者是在代码中使用的时候,就是对象创建和赋值时候的.<br>苹果的设计是:</p>
<ul>
<li>copy        拿到的永远是不可变对象</li>
<li>mutableCopy 拿到的是可变对象</li>
</ul>
<p>为什么这样设计呢?</p>
<p>以上两者的调用者可能是 可变的或者不可变的,那么就会有四种组合,对于开发者去记忆四种组合是比较蹩脚的.所以干脆 </p>
<ul>
<li>不管调用者类型是可变与否,copy到得就不可变</li>
<li>不管调用者类型是可变与否,mutableCopy到得就是可变对象</li>
</ul>
<h3 id="关于创建可变类型">关于创建可变类型</h3><p>以前都是用类似 <code>NSMutableString * string = [ NSMutableString string ];</code>这样的方式创建,但是在和东盟君讨论的时候,打印了一下,发现 <code>string</code>的class是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString * string = [NSString stringWithFormat:@&#34;string&#34;];&#10; NSLog(@&#34;string is %@&#34;,[string class]);&#10; &#10; NSMutableString * mutableString = [NSMutableString string];&#10; NSLog(@&#34;mutable string is %@&#34;,[mutableString class]);</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-05-20 10:36:43.549 TestNsstring[10993:1874316] string is __NSCFString&#10;2015-05-20 10:36:43.550 TestNsstring[10993:1874316] mutable string is __NSCFString</span><br></pre></td></tr></table></figure>
<p>究其原因, NSString是一个类簇,具体的实现都会找到合适的类,这个不用纠结了.</p>
<p>不久之后,在 <strong>iOS6 by Tutorial</strong>中一书中看到关于 <code>[@[] mutableCopy]</code> 和 <code>[@{} mutableCopy]</code> 这样的用法.</p>
<p>也符合 copy 和 mutableCopy 的准则</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-12T01:32:52.000Z"><a href="/2015/05/12/Core Aniamtion深入探讨/15-图层性能/15-图层性能/">2015-05-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/12/Core Aniamtion深入探讨/15-图层性能/15-图层性能/">15-图层性能</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="图层性能">图层性能</h1><blockquote>
<p>要更快性能，也要做对正确的事情。<br>——Stephen R. Covey</p>
</blockquote>
<p>在第14章『图像IO』讨论如何高效地载入和显示图像，通过视图来避免可能引起动画帧率下降的性能问题。在最后一章，我们将着重图层树本身，以发掘最好的性能。</p>
<h2 id="隐式绘制">隐式绘制</h2><p>寄宿图可以通过Core Graphics直接绘制，也可以直接载入一个图片文件并赋值给<code>contents</code>属性，或事先绘制一个屏幕之外的<code>CGContext</code>上下文。在之前的两章中我们讨论了这些场景下的优化。但是除了常见的显式创建寄宿图，你也可以通过以下三种方式创建隐式的：1，使用特性的图层属性。2，特定的视图。3，特定的图层子类。</p>
<p>了解这个情况为什么发生何时发生是很重要的，它能够让你避免引入不必要的软件绘制行为。</p>
<h3 id="文本">文本</h3><p><code>CATextLayer</code>和<code>UILabel</code>都是直接将文本绘制在图层的寄宿图中。事实上这两种方式用了完全不同的渲染方式：在iOS 6及之前，<code>UILabel</code>用WebKit的HTML渲染引擎来绘制文本，而<code>CATextLayer</code>用的是Core Text.后者渲染更迅速，所以在所有需要绘制大量文本的情形下都优先使用它吧。但是这两种方法都用了软件的方式绘制，因此他们实际上要比硬件加速合成方式要慢。</p>
<p>不论如何，尽可能地避免改变那些包含文本的视图的frame，因为这样做的话文本就需要重绘。例如，如果你想在图层的角落里显示一段静态的文本，但是这个图层经常改动，你就应该把文本放在一个子图层中。</p>
<h3 id="光栅化">光栅化</h3><p>在第四章『视觉效果』中我们提到了<code>CALayer</code>的<code>shouldRasterize</code>属性，它可以解决重叠透明图层的混合失灵问题。同样在第12章『速度的曲调』中，它也是作为绘制复杂图层树结构的优化方法。</p>
<p>启用<code>shouldRasterize</code>属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的<code>contents</code>和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。</p>
<p>当我们使用得当时，光栅化可以提供很大的性能优势（如你在第12章所见），但是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而且会让性能变的更糟。</p>
<p>为了检测你是否正确地使用了光栅化方式，用Instrument查看一下Color Hits Green和Misses Red项目，是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则你无意间触发了不必要的改变导致了重绘行为）。</p>
<h2 id="离屏渲染">离屏渲染</h2><p>Offscreen rendering does not necessarily imply software drawing, but it means that the layer must first be rendered (either by the CPU or GPU) into an offscreen context before being displayed. The layer attributes that trigger offscreen rendering are as follows:</p>
<p>当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。图层的以下属性将会触发屏幕外绘制：</p>
<ul>
<li>圆角（当和<code>maskToBounds</code>一起使用时）</li>
<li>图层蒙板</li>
<li>阴影</li>
</ul>
<p>屏幕外渲染和我们启用光栅化时相似，除了它并没有像光栅化图层那么消耗大，子图层并没有被影响到，而且结果也没有被缓存，所以不会有长期的内存占用。但是，如果太多图层在屏幕外渲染依然会影响到性能。</p>
<p>有时候我们可以把那些需要屏幕外绘制的图层开启光栅化以作为一个优化方式，前提是这些图层并不会被频繁地重绘。</p>
<p>对于那些需要动画而且要在屏幕外渲染的图层来说，你可以用<code>CAShapeLayer</code>，<code>contentsCenter</code>或者<code>shadowPath</code>来获得同样的表现而且较少地影响到性能。</p>
<h3 id="CAShapeLayer">CAShapeLayer</h3><p><code>cornerRadius</code>和<code>maskToBounds</code>独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。有时候你想显示圆角并沿着图层裁切子图层的时候，你可能会发现你并不需要沿着圆角裁切，这个情况下用<code>CAShapeLayer</code>就可以避免这个问题了。</p>
<p>你想要的只是圆角且沿着矩形边界裁切，同时还不希望引起性能问题。其实你可以用现成的<code>UIBezierPath</code>的构造器<code>+bezierPathWithRoundedRect:cornerRadius:</code>（见清单15.1）.这样做并不会比直接用<code>cornerRadius</code>更快，但是它避免了性能问题。</p>
<p>清单15.1 用<code>CAShapeLayer</code>画一个圆角矩形</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    //create shape layer&#10;    CAShapeLayer *blueLayer = [CAShapeLayer layer];&#10;    blueLayer.frame = CGRectMake(50, 50, 100, 100);&#10;    blueLayer.fillColor = [UIColor blueColor].CGColor;&#10;    blueLayer.path = [UIBezierPath bezierPathWithRoundedRect:&#10;    CGRectMake(0, 0, 100, 100) cornerRadius:20].CGPath;&#10;    &#65532;&#10;    //add it to our view&#10;    [self.layerView.layer addSublayer:blueLayer];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<h3 id="可伸缩图片">可伸缩图片</h3><p>另一个创建圆角矩形的方法就是用一个圆形内容图片并结合第二章『寄宿图』提到的<code>contensCenter</code>属性去创建一个可伸缩图片（见清单15.2）.理论上来说，这个应该比用<code>CAShapeLayer</code>要快，因为一个可拉伸图片只需要18个三角形（一个图片是由一个3*3网格渲染而成），然而，许多都需要渲染成一个顺滑的曲线。在实际应用上，二者并没有太大的区别。</p>
<p>清单15.2 用可伸缩图片绘制圆角矩形</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    //create layer&#10;    CALayer *blueLayer = [CALayer layer];&#10;    blueLayer.frame = CGRectMake(50, 50, 100, 100);&#10;    blueLayer.contentsCenter = CGRectMake(0.5, 0.5, 0.0, 0.0);&#10;    blueLayer.contentsScale = [UIScreen mainScreen].scale;&#10;    blueLayer.contents = (__bridge id)[UIImage imageNamed:@&#34;Circle.png&#34;].CGImage;&#10;    //add it to our view&#10;    [self.layerView.layer addSublayer:blueLayer];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>使用可伸缩图片的优势在于它可以绘制成任意边框效果而不需要额外的性能消耗。举个例子，可伸缩图片甚至还可以显示出矩形阴影的效果。</p>
<h3 id="shadowPath">shadowPath</h3><p>在第2章我们有提到<code>shadowPath</code>属性。如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），创建出一个对应形状的阴影路径就比较容易，而且Core Animation绘制这个阴影也相当简单，避免了屏幕外的图层部分的预排版需求。这对性能来说很有帮助。</p>
<p>如果你的图层是一个更复杂的图形，生成正确的阴影路径可能就比较难了，这样子的话你可以考虑用绘图软件预先生成一个阴影背景图。</p>
<h2 id="混合和过度绘制">混合和过度绘制</h2><p>在第12章有提到，GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。</p>
<p>GPU会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。任何情况下，你应该这样做：</p>
<ul>
<li>给视图的<code>backgroundColor</code>属性设置一个固定的，不透明的颜色</li>
<li>设置<code>opaque</code>属性为YES</li>
</ul>
<p>这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响）并且计算得到了加速，避免了过度绘制行为因为Core Animation可以舍弃所有被完全遮盖住的图层，而不用每个像素都去计算一遍。</p>
<p>如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。</p>
<p>如果是文本的话，一个白色背景的<code>UILabel</code>（或者其他颜色）会比透明背景要更高效。</p>
<p>最后，明智地使用<code>shouldRasterize</code>属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。</p>
<h2 id="减少图层数量">减少图层数量</h2><p>初始化图层，处理图层，打包通过IPC发给渲染引擎，转化成OpenGL几何图形，这些是一个图层的大致资源开销。事实上，一次性能够在屏幕上显示的最大图层数量也是有限的。</p>
<p>确切的限制数量取决于iOS设备，图层类型，图层内容和属性等。但是总得说来可以容纳上百或上千个，下面我们将演示即使图层本身并没有做什么也会遇到的性能问题。</p>
<h3 id="裁切">裁切</h3><p>在对图层做任何优化之前，你需要确定你不是在创建一些不可见的图层，图层在以下几种情况下回事不可见的：</p>
<ul>
<li>图层在屏幕边界之外，或是在父图层边界之外。</li>
<li>完全在一个不透明图层之后。</li>
<li>完全透明</li>
</ul>
<p>Core Animation非常擅长处理对视觉效果无意义的图层。但是经常性地，你自己的代码会比Core Animation更早地想知道一个图层是否是有用的。理想状况下，在图层对象在创建之前就想知道，以避免创建和配置不必要图层的额外工作。</p>
<p>举个例子。清单15.3 的代码展示了一个简单的滚动3D图层矩阵。这看上去很酷，尤其是图层在移动的时候（见图15.1），但是绘制他们并不是很麻烦，因为这些图层就是一些简单的矩形色块。</p>
<p>清单15.3 绘制3D图层矩阵</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;#define WIDTH 10&#10;#define HEIGHT 10&#10;#define DEPTH 10&#10;#define SIZE 100&#10;#define SPACING 150&#10;#define CAMERA_DISTANCE 500&#10;&#10;@interface ViewController ()&#10;&#65532;&#10;@property (nonatomic, strong) IBOutlet UIScrollView *scrollView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    //set content size&#10;    self.scrollView.contentSize = CGSizeMake((WIDTH - 1)*SPACING, (HEIGHT - 1)*SPACING);&#10;&#10;    //set up perspective transform&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    transform.m34 = -1.0 / CAMERA_DISTANCE;&#10;    self.scrollView.layer.sublayerTransform = transform;&#10;&#10;    //create layers&#10;    for (int z = DEPTH - 1; z &#62;= 0; z--) &#123;&#10;        for (int y = 0; y &#60; HEIGHT; y++) &#123;&#10;            for (int x = 0; x &#60; WIDTH; x++) &#123;&#10;                //create layer&#10;                CALayer *layer = [CALayer layer];&#10;                layer.frame = CGRectMake(0, 0, SIZE, SIZE);&#10;                layer.position = CGPointMake(x*SPACING, y*SPACING);&#10;                layer.zPosition = -z*SPACING;&#10;                //set background color&#10;                layer.backgroundColor = [UIColor colorWithWhite:1-z*(1.0/DEPTH) alpha:1].CGColor;&#10;                //attach to scroll view&#10;                [self.scrollView.layer addSublayer:layer];&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    &#65532;&#10;    //log&#10;    NSLog(@&#34;displayed: %i&#34;, DEPTH*HEIGHT*WIDTH);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/71fdb9ac56e0ea67.png"></p>
<p>图15.1 滚动的3D图层矩阵</p>
<p><code>WIDTH</code>，<code>HEIGHT</code>和<code>DEPTH</code>常量控制着图层的生成。在这个情况下，我们得到的是10*10*10个图层，总量为1000个，不过一次性显示在屏幕上的大约就几百个。</p>
<p>如果把<code>WIDTH</code>和<code>HEIGHT</code>常量增加到100，我们的程序就会慢得像龟爬了。这样我们有了100000个图层，性能下降一点儿也不奇怪。</p>
<p>但是显示在屏幕上的图层数量并没有增加，那么根本没有额外的东西需要绘制。程序慢下来的原因其实是因为在管理这些图层上花掉了不少功夫。他们大部分对渲染的最终结果没有贡献，但是在丢弃这么图层之前，Core Animation要强制计算每个图层的位置，就这样，我们的帧率就慢了下来。</p>
<p>我们的图层是被安排在一个均匀的栅格中，我们可以计算出哪些图层会被最终显示在屏幕上，根本不需要对每个图层的位置进行计算。这个计算并不简单，因为我们还要考虑到透视的问题。如果我们直接这样做了，Core Animation就不用费神了。</p>
<p>既然这样，让我们来重构我们的代码吧。改造后，随着视图的滚动动态地实例化图层而不是事先都分配好。这样，在创造他们之前，我们就可以计算出是否需要他。接着，我们增加一些代码去计算可视区域这样就可以排除区域之外的图层了。清单15.4是改造后的结果。</p>
<p>清单15.4 排除可视区域之外的图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;#define WIDTH 100&#10;#define HEIGHT 100&#10;#define DEPTH 10&#10;#define SIZE 100&#10;#define SPACING 150&#10;#define CAMERA_DISTANCE 500&#10;#define PERSPECTIVE(z) (float)CAMERA_DISTANCE/(z + CAMERA_DISTANCE)&#10;&#10;@interface ViewController () &#60;UIScrollViewDelegate&#62;&#10;&#10;@property (nonatomic, weak) IBOutlet UIScrollView *scrollView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //set content size&#10;    self.scrollView.contentSize = CGSizeMake((WIDTH - 1)*SPACING, (HEIGHT - 1)*SPACING);&#10;    //set up perspective transform&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    transform.m34 = -1.0 / CAMERA_DISTANCE;&#10;    self.scrollView.layer.sublayerTransform = transform;&#10;&#125;&#10;&#65532;&#10;- (void)viewDidLayoutSubviews&#10;&#123;&#10;    [self updateLayers];&#10;&#125;&#10;&#10;- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#10;&#123;&#10;    [self updateLayers];&#10;&#125;&#10;&#10;- (void)updateLayers&#10;&#123;&#10;    //calculate clipping bounds&#10;    CGRect bounds = self.scrollView.bounds;&#10;    bounds.origin = self.scrollView.contentOffset;&#10;    bounds = CGRectInset(bounds, -SIZE/2, -SIZE/2);&#10;    //create layers&#10;    NSMutableArray *visibleLayers = [NSMutableArray array];&#10;    for (int z = DEPTH - 1; z &#62;= 0; z--)&#10;    &#123;&#10;        //increase bounds size to compensate for perspective&#10;        CGRect adjusted = bounds;&#10;        adjusted.size.width /= PERSPECTIVE(z*SPACING);&#10;        adjusted.size.height /= PERSPECTIVE(z*SPACING);&#10;        adjusted.origin.x -= (adjusted.size.width - bounds.size.width) / 2;&#10;        adjusted.origin.y -= (adjusted.size.height - bounds.size.height) / 2;&#10;        for (int y = 0; y &#60; HEIGHT; y++) &#123;&#10;        //check if vertically outside visible rect&#10;            if (y*SPACING &#60; adjusted.origin.y || y*SPACING &#62;= adjusted.origin.y + adjusted.size.height)&#10;            &#123;&#10;                continue;&#10;            &#125;&#10;            for (int x = 0; x &#60; WIDTH; x++) &#123;&#10;                //check if horizontally outside visible rect&#10;                if (x*SPACING &#60; adjusted.origin.x ||x*SPACING &#62;= adjusted.origin.x + adjusted.size.width)&#10;                &#123;&#10;                    continue;&#10;                &#125;&#10;                &#65532;&#10;                //create layer&#10;                CALayer *layer = [CALayer layer];&#10;                layer.frame = CGRectMake(0, 0, SIZE, SIZE);&#10;                layer.position = CGPointMake(x*SPACING, y*SPACING);&#10;                layer.zPosition = -z*SPACING;&#10;                //set background color&#10;                layer.backgroundColor = [UIColor colorWithWhite:1-z*(1.0/DEPTH) alpha:1].CGColor;&#10;                //attach to scroll view&#10;                [visibleLayers addObject:layer];&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    //update layers&#10;    self.scrollView.layer.sublayers = visibleLayers;&#10;    //log&#10;    NSLog(@&#34;displayed: %i/%i&#34;, [visibleLayers count], DEPTH*HEIGHT*WIDTH);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>这个计算机制并不具有普适性，但是原则上是一样。（当你用一个<code>UITableView</code>或者<code>UICollectionView</code>时，系统做了类似的事情）。这样做的结果？我们的程序可以处理成百上千个『虚拟』图层而且完全没有性能问题！因为它不需要一次性实例化几百个图层。</p>
<h3 id="对象回收">对象回收</h3><p>处理巨大数量的相似视图或图层时还有一个技巧就是回收他们。对象回收在iOS颇为常见；<code>UITableView</code>和<code>UICollectionView</code>都有用到，<code>MKMapView</code>中的动画pin码也有用到，还有其他很多例子。</p>
<p>对象回收的基础原则就是你需要创建一个相似对象池。当一个对象的指定实例（本例子中指的是图层）结束了使命，你把它添加到对象池中。每次当你需要一个实例时，你就从池中取出一个。当且仅当池中为空时再创建一个新的。</p>
<p>这样做的好处在于避免了不断创建和释放对象（相当消耗资源，因为涉及到内存的分配和销毁）而且也不必给相似实例重复赋值。</p>
<p>好了，让我们再次更新代码吧（见清单15.5）</p>
<p>清单15.5 通过回收减少不必要的分配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController () &#60;UIScrollViewDelegate&#62;&#10;&#10;@property (nonatomic, weak) IBOutlet UIScrollView *scrollView;&#10;@property (nonatomic, strong) NSMutableSet *recyclePool;&#10;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad]; //create recycle pool&#10;    self.recyclePool = [NSMutableSet set];&#10;    //set content size&#10;    self.scrollView.contentSize = CGSizeMake((WIDTH - 1)*SPACING, (HEIGHT - 1)*SPACING);&#10;    //set up perspective transform&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    transform.m34 = -1.0 / CAMERA_DISTANCE;&#10;    self.scrollView.layer.sublayerTransform = transform;&#10;&#125;&#10;&#10;- (void)viewDidLayoutSubviews&#10;&#123;&#10;    [self updateLayers];&#10;&#125;&#10;&#10;- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#10;&#123;&#10;    [self updateLayers];&#10;&#125;&#10;&#10;- (void)updateLayers &#123;&#10;    &#65532;&#10;    //calculate clipping bounds&#10;    CGRect bounds = self.scrollView.bounds;&#10;    bounds.origin = self.scrollView.contentOffset;&#10;    bounds = CGRectInset(bounds, -SIZE/2, -SIZE/2);&#10;    //add existing layers to pool&#10;    [self.recyclePool addObjectsFromArray:self.scrollView.layer.sublayers];&#10;    //disable animation&#10;    [CATransaction begin];&#10;    [CATransaction setDisableActions:YES];&#10;    //create layers&#10;    NSInteger recycled = 0;&#10;    NSMutableArray *visibleLayers = [NSMutableArray array];&#10;    for (int z = DEPTH - 1; z &#62;= 0; z--)&#10;    &#123;&#10;        //increase bounds size to compensate for perspective&#10;        CGRect adjusted = bounds;&#10;        adjusted.size.width /= PERSPECTIVE(z*SPACING);&#10;        adjusted.size.height /= PERSPECTIVE(z*SPACING);&#10;        adjusted.origin.x -= (adjusted.size.width - bounds.size.width) / 2; adjusted.origin.y -= (adjusted.size.height - bounds.size.height) / 2;&#10;        for (int y = 0; y &#60; HEIGHT; y++) &#123;&#10;            //check if vertically outside visible rect&#10;            if (y*SPACING &#60; adjusted.origin.y ||&#10;                y*SPACING &#62;= adjusted.origin.y + adjusted.size.height)&#10;            &#123;&#10;                continue;&#10;            &#125;&#10;            for (int x = 0; x &#60; WIDTH; x++) &#123;&#10;                //check if horizontally outside visible rect&#10;                if (x*SPACING &#60; adjusted.origin.x ||&#10;                    x*SPACING &#62;= adjusted.origin.x + adjusted.size.width)&#10;                &#123;&#10;                    continue;&#10;                &#125;&#10;                //recycle layer if available&#10;                CALayer *layer = [self.recyclePool anyObject]; if (layer)&#10;                &#123;&#10;                    &#65532;&#10;                    recycled ++;&#10;                    [self.recyclePool removeObject:layer]; &#125;&#10;                else&#10;                &#123;&#10;                    layer = [CALayer layer];&#10;                    layer.frame = CGRectMake(0, 0, SIZE, SIZE); &#125;&#10;                //set position&#10;                layer.position = CGPointMake(x*SPACING, y*SPACING); layer.zPosition = -z*SPACING;&#10;                //set background color&#10;                layer.backgroundColor =&#10;                [UIColor colorWithWhite:1-z*(1.0/DEPTH) alpha:1].CGColor;&#10;                //attach to scroll view&#10;                [visibleLayers addObject:layer]; &#125;&#10;        &#125; &#125;&#10;    [CATransaction commit]; //update layers&#10;    self.scrollView.layer.sublayers = visibleLayers;&#10;    //log&#10;    NSLog(@&#34;displayed: %i/%i recycled: %i&#34;,&#10;          [visibleLayers count], DEPTH*HEIGHT*WIDTH, recycled);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>本例中，我们只有图层对象这一种类型，但是UIKit有时候用一个标识符字符串来区分存储在不同对象池中的不同的可回收对象类型。</p>
<p>你可能注意到当设置图层属性时我们用了一个<code>CATransaction</code>来抑制动画效果。在之前并不需要这样做，因为在显示之前我们给所有图层设置一次属性。但是既然图层正在被回收，禁止隐式动画就有必要了，不然当属性值改变时，图层的隐式动画就会被触发。</p>
<h3 id="Core_Graphics绘制">Core Graphics绘制</h3><p>当排除掉对屏幕显示没有任何贡献的图层或者视图之后，长远看来，你可能仍然需要减少图层的数量。例如，如果你正在使用多个<code>UILabel</code>或者<code>UIImageView</code>实例去显示固定内容，你可以把他们全部替换成一个单独的视图，然后用<code>-drawRect:</code>方法绘制出那些复杂的视图层级。</p>
<p>这个提议看上去并不合理因为大家都知道软件绘制行为要比GPU合成要慢而且还需要更多的内存空间，但是在因为图层数量而使得性能受限的情况下，软件绘制很可能提高性能呢，因为它避免了图层分配和操作问题。</p>
<p>你可以自己实验一下这个情况，它包含了性能和栅格化的权衡，但是意味着你可以从图层树上去掉子图层（用<code>shouldRasterize</code>，与完全遮挡图层相反）。</p>
<h3 id="-renderInContext:_方法">-renderInContext: 方法</h3><p>用Core Graphics去绘制一个静态布局有时候会比用层级的<code>UIView</code>实例来得快，但是使用<code>UIView</code>实例要简单得多而且比用手写代码写出相同效果要可靠得多，更边说Interface Builder来得直接明了。为了性能而舍弃这些便利实在是不应该。</p>
<p>幸好，你不必这样，如果大量的视图或者图层真的关联到了屏幕上将会是一个大问题。没有与图层树相关联的图层不会被送到渲染引擎，也没有性能问题（在他们被创建和配置之后）。</p>
<p>使用<code>CALayer</code>的<code>-renderInContext:</code>方法，你可以将图层及其子图层快照进一个Core Graphics上下文然后得到一个图片，它可以直接显示在<code>UIImageView</code>中，或者作为另一个图层的<code>contents</code>。不同于<code>shouldRasterize</code> —— 要求图层与图层树相关联 —— ，这个方法没有持续的性能消耗。</p>
<p>当图层内容改变时，刷新这张图片的机会取决于你（不同于<code>shouldRasterize</code>，它自动地处理缓存和缓存验证），但是一旦图片被生成，相比于让Core Animation处理一个复杂的图层树，你节省了相当客观的性能。</p>
<h2 id="总结">总结</h2><p>本章学习了使用Core Animation图层可能遇到的性能瓶颈，并讨论了如何避免或减小压力。你学习了如何管理包含上千虚拟图层的场景（事实上只创建了几百个）。同时也学习了一些有用的技巧，选择性地选取光栅化或者绘制图层内容在合适的时候重新分配给CPU和GPU。这些就是我们要讲的关于Core Animation的全部了（至少可以等到苹果发明什么新的玩意儿）。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/4/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->




<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/5/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/categories/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/categories/Git/">Git</a><small>1</small></li>
  
    <li><a href="/categories/ReactiveCocoa/">ReactiveCocoa</a><small>2</small></li>
  
    <li><a href="/categories/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/categories/Swift进阶/">Swift进阶</a><small>4</small></li>
  
    <li><a href="/categories/iOS-Tips/">iOS Tips</a><small>14</small></li>
  
    <li><a href="/categories/主页维护记录/">主页维护记录</a><small>4</small></li>
  
    <li><a href="/categories/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/categories/开发环境相关/">开发环境相关</a><small>5</small></li>
  
    <li><a href="/categories/悟/">悟</a><small>1</small></li>
  
    <li><a href="/categories/知识技巧总结/">知识技巧总结</a><small>1</small></li>
  
    <li><a href="/categories/算法专题/">算法专题</a><small>1</small></li>
  
    <li><a href="/categories/辅助编程技能/">辅助编程技能</a><small>7</small></li>
  
    <li><a href="/categories/重构、模式、架构/">重构、模式、架构</a><small>10</small></li>
  
    <li><a href="/categories/高效OC编程/">高效OC编程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/tags/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/tags/Git-命令/">Git 命令</a><small>1</small></li>
  
    <li><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a><small>2</small></li>
  
    <li><a href="/tags/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/tags/Swift-进阶/">Swift 进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶/">Swift进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶-variable-with-a-setter-must-also-have-a-getter/">Swift进阶 variable with a setter must also have a getter</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Tips/">iOS Tips</a><small>3</small></li>
  
    <li><a href="/tags/主页维护记录/">主页维护记录</a><small>2</small></li>
  
    <li><a href="/tags/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/tags/小脚本大智慧/">小脚本大智慧</a><small>1</small></li>
  
    <li><a href="/tags/开发环境相关/">开发环境相关</a><small>3</small></li>
  
    <li><a href="/tags/悟/">悟</a><small>1</small></li>
  
    <li><a href="/tags/正则表达式/">正则表达式</a><small>2</small></li>
  
    <li><a href="/tags/测试小样/">测试小样</a><small>1</small></li>
  
    <li><a href="/tags/算法专题-字符串/">算法专题 字符串</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
    <li><a href="/tags/辅助编程技能/">辅助编程技能</a><small>2</small></li>
  
    <li><a href="/tags/重构、模式、架构/">重构、模式、架构</a><small>5</small></li>
  
    <li><a href="/tags/问题解决和思考/">问题解决和思考</a><small>5</small></li>
  
    <li><a href="/tags/高效OC编程/">高效OC编程</a><small>4</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 桂庆
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>