<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | 桂庆的个人主页</title>
  <meta name="author" content="桂庆">
  
  <meta name="description" content="桂庆的个人主页 记录自己的学习 工作 感悟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="桂庆的个人主页"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="桂庆的个人主页" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">桂庆的个人主页</a></h1>
  <h2><a href="/">记录自己的学习 工作 感悟</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-18T07:33:48.000Z"><a href="/2015/04/18/iOS&OC/MJExtention-对不规范-JSON-解析的一个测试/">2015-04-18</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/18/iOS&OC/MJExtention-对不规范-JSON-解析的一个测试/">MJExtention 对不规范 JSON 解析的一个测试</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Context">Context</h2><p>今天受 MJ 老师吩咐,测试 MJExtension 对于不规范的 JSON 的解析情况.特记录于此 </p>
<h2 id="说明几点">说明几点</h2><h3 id="何为不规范">何为不规范</h3><p>我说的不规则指的是有一定容错能力,但是前提还是 JSON,弄些乱七八糟的字符串就没有意义了哈.比如说,这次我想测试的是前一段事件遇到的一个小问题:服务端返回的是类似这样的一个结果:  </p>
<p><img src="http://ww1.sinaimg.cn/large/9e446dffjw1er9qrf2g2hj206608vaad.jpg"></p>
<p>为了展现,截图是规范的 JSON,服务端给我的实际数据是:<br>两个箭头指向处还有 <code>&quot;</code>  .</p>
<p><img src="http://ww2.sinaimg.cn/large/9e446dffjw1er9ql5uocrj206k08sq3c.jpg">  </p>
<p>换句话说,他是严格执行的: <code>&quot;键&quot;:&quot;无论啥类型&quot;</code> . 网上大多数的所谓的 JSON 格式校验工具认为这种格式是 okay 的,但是它的问题是,没法继续”钻下去” ,这里就是我所说的 “不规范”.<br>说到这里,推荐个地址 <a href="http://tool.oschina.net/codeformat/json">在线校验</a>,这个不仅仅是校验,还有格式化功能.支持按层级折叠和展开.</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/18/iOS&OC/MJExtention-对不规范-JSON-解析的一个测试/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-17T01:32:52.000Z"><a href="/2015/04/17/Core Aniamtion深入探讨/4-视觉效果/4-视觉效果/">2015-04-17</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/17/Core Aniamtion深入探讨/4-视觉效果/4-视觉效果/">4-视觉效果</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="视觉效果">视觉效果</h1><blockquote>
<p>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢？</p>
<p>我们现在能做到那样了么？</p>
<p>史蒂芬·乔布斯</p>
</blockquote>
<p>我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。</p>
<h2 id="圆角">圆角</h2><p>圆角矩形是iOS的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。</p>
<p>CALayer有一个叫做<code>conrnerRadius</code>的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会被截取。</p>
<p>我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)</p>
<p><img src="http://i1.tietuku.com/3a95761f3df03285.png"></p>
<p>图4.1 两个白色的大视图，他们都包含了小一些的红色视图。</p>
<p>然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果</p>
<p>清单4.1 设置<code>cornerRadius</code>和<code>masksToBounds</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;- (void)viewDidLoad&#10;&#123;&#65532;&#65532;&#65532;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/dc9050c13c4b29c0.png"></p>
<p>右图中，红色的子视图沿角半径被裁剪了</p>
<p>如你所见，右边的子视图沿边界被裁剪了。</p>
<p>单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者是CAShapeLayer（见第六章『专用图层』）。</p>
<h2 id="图层边框">图层边框</h2><p>CALayer另外两个非常有用属性就是<code>borderWidth</code>和<code>borderColor</code>。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的<code>bounds</code>绘制，同时也包含图层的角。</p>
<p><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0.<code>borderColor</code>定义了边框的颜色，默认为黑色。</p>
<p><code>borderColor</code>是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了<code>borderColor</code>，虽然属性声明并不能证明这一点。<code>CGColorRef</code>在引用/释放时候的行为表现得与<code>NSObject</code>极其相似。但是Objective-C语法并不支持这一做法，所以<code>CGColorRef</code>属性即便是强引用也只能通过assign关键字来声明。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.</p>
<p>清单4.2 加上边框</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //add a border to our layers&#10;  self.layerView1.layer.borderWidth = 5.0f;&#10;  self.layerView2.layer.borderWidth = 5.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/36dc54ae201277f2.png"></p>
<p>图4.3 给图层增加一个边框</p>
<p>仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.</p>
<p><img src="http://i1.tietuku.com/86e5c09f8cf07c10.png"></p>
<p>图4.4 边框是跟随图层的边界变化的，而不是图层里面的内容</p>
<h2 id="阴影">阴影</h2><p>iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</p>
<p>给<code>shadowOpacity</code>属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。<code>shadowOpacity</code>是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：<code>shadowColor</code>，<code>shadowOffset</code>和<code>shadowRadius</code>。</p>
<p>显而易见，<code>shadowColor</code>属性控制着阴影的颜色，和<code>borderColor</code>和<code>backgroundColor</code>一样，它的类型也是<code>CGColorRef</code>。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</p>
<p><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个<code>CGSize</code>的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。<code>shadowOffset</code>的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p>为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，<code>shadowOffset</code>的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.</p>
<p><img src="http://i1.tietuku.com/7db986fe34f3b61a.png"></p>
<p>图4.5 在iOS（左）和Mac OS（右）上<code>shadowOffset</code>的表现。</p>
<p>苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>
<p><code>shadowRadius</code>属性控制着阴影的<em>模糊度</em>，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。</p>
<p>通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给<code>shadowRadius</code>设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.</p>
<p><img src="http://i1.tietuku.com/be6b969406fb888a.png"></p>
<p>图4.6 大一些的阴影位移和角半径会增加图层的深度即视感</p>
<h2 id="阴影裁剪">阴影裁剪</h2><p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。</p>
<p><img src="http://i1.tietuku.com/f3cbc8b39c5d0031.png"></p>
<p>图4.7 阴影是根据寄宿图的轮廓来确定的</p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了<code>masksToBounds</code>属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.</p>
<p><img src="http://i1.tietuku.com/3beca24155d015a1.png"></p>
<p>图4.8 <code>maskToBounds</code>属性裁剪掉了阴影和内容</p>
<p>从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用<code>masksToBounds</code>裁剪内容的内图层。</p>
<p>如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.</p>
<p><img src="http://i1.tietuku.com/7760492f8e8ba8bf.png"></p>
<p>图4.9 右边，用额外的阴影转换视图包裹被裁剪的视图</p>
<p>我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。</p>
<p>清单4.3 用一个额外的视图来解决阴影裁切的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;@property (nonatomic, weak) IBOutlet UIView *shadowView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#65532;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //add a border to our layers&#10;  self.layerView1.layer.borderWidth = 5.0f;&#10;  self.layerView2.layer.borderWidth = 5.0f;&#10;&#10;  //add a shadow to layerView1&#10;  self.layerView1.layer.shadowOpacity = 0.5f;&#10;  self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&#10;  self.layerView1.layer.shadowRadius = 5.0f;&#10;&#10;  //add same shadow to shadowView (not layerView2)&#10;  self.shadowView.layer.shadowOpacity = 0.5f;&#10;  self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&#10;  self.shadowView.layer.shadowRadius = 5.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/346b0e2ad8ae09d7.png"></p>
<p>图4.10 右边视图，不受裁切阴影的阴影视图。</p>
<h2 id="shadowPath属性"><code>shadowPath</code>属性</h2><p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<code>shadowPath</code>是一个<code>CGPathRef</code>类型（一个指向<code>CGPath</code>的指针）。<code>CGPath</code>是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<p>图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。</p>
<p><img src="http://i1.tietuku.com/2799e67d09602635.png"></p>
<p>图4.11 用<code>shadowPath</code>指定任意阴影形状</p>
<p>清单4.4 创建简单的阴影形状</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //enable layer shadows&#10;  self.layerView1.layer.shadowOpacity = 0.5f;&#10;  self.layerView2.layer.shadowOpacity = 0.5f;&#10;&#10;  //create a square shadow&#10;  CGMutablePathRef squarePath = CGPathCreateMutable();&#10;  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);&#10;  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);&#10;&#10;  &#65532;//create a circular shadow&#10;  CGMutablePathRef circlePath = CGPathCreateMutable();&#10;  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);&#10;  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>如果是一个矩形或者是圆，用<code>CGPath</code>会相当简单明了。但是如果是更加复杂一点的图形，<code>UIBezierPath</code>类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<h2 id="图层蒙板">图层蒙板</h2><p>通过<code>masksToBounds</code>属性，我们可以沿边界裁剪图形；通过<code>cornerRadius</code>属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个属性叫做<code>mask</code>可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
<p><code>mask</code>图层的<code>Color</code>属性是无关紧要的，真正重要的是图层的轮廓。<code>mask</code>属性就像是一个饼干切割机，<code>mask</code>图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）</p>
<p>如果<code>mask</code>图层比父图层要小，只有在<code>mask</code>图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p><img src="http://i1.tietuku.com/3123be453a267e1d.png"></p>
<p>图4.12 把图片和蒙板图层作用在一起的效果</p>
<p>我们将代码演示一下这个过程，创建一个简单的项目，通过图层的<code>mask</code>属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。</p>
<p>清单4.5 应用蒙板图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIImageView *imageView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create mask layer&#10;  CALayer *maskLayer = [CALayer layer];&#10;  maskLayer.frame = self.layerView.bounds;&#10;  UIImage *maskImage = [UIImage imageNamed:@&#34;Cone.png&#34;];&#10;  maskLayer.contents = (__bridge id)maskImage.CGImage;&#10;&#10;  //apply mask to image layer&#65532;&#10;  self.imageView.layer.mask = maskLayer;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/91a010e3dcb3e549.png"></p>
<p>图4.13 使用了<code>mask</code>之后的UIImageView</p>
<p>CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为<code>mask</code>属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。</p>
<h2 id="拉伸过滤">拉伸过滤</h2><p>最后我们再来谈谈<code>minificationFilter</code>和<code>magnificationFilter</code>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。</p>
<p>当图片需要显示不同的大小的时候，有一种叫做<em>拉伸过滤</em>的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
<p>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。<code>CALayer</code>为此提供了三种拉伸过滤方法，他们是：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。</p>
<p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<p><img src="http://i1.tietuku.com/362db4f8519bde1d.png"></p>
<p>图4.14 对于大图来说，双线性滤波和三线性滤波表现得更出色</p>
<p><code>kCAFilterNearest</code>是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>
<p><img src="http://i1.tietuku.com/79c8bfe9549efe33.png"></p>
<p>图4.15 对于没有斜线的小图来说，最近过滤算法要好很多</p>
<p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<p>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。</p>
<p><img src="http://i1.tietuku.com/c5d07147325d611e.png"></p>
<p>图4.16 一个简单的运用拼合技术显示的LCD数字风格的像素字体</p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个<code>IBOutletCollection</code>对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。</p>
<p><img src="http://i1.tietuku.com/6d751b3556c52024.png"><br>图4.17</p>
<p>清单4.6 显示一个LCD风格的时钟</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;&#10;@property (nonatomic, weak) NSTimer *timer;&#10;&#65532;&#65532;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //get spritesheet image&#10;  UIImage *digits = [UIImage imageNamed:@&#34;Digits.png&#34;];&#10;&#10;  //set up digit views&#10;  for (UIView *view in self.digitViews) &#123;&#10;    //set contents&#10;    view.layer.contents = (__bridge id)digits.CGImage;&#10;    view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);&#10;    view.layer.contentsGravity = kCAGravityResizeAspect;&#10;  &#125;&#10;&#10;  //start timer&#10;  self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&#10;&#10;  //set initial clock time&#10;  [self tick];&#10;&#125;&#10;&#10;- (void)setDigit:(NSInteger)digit forView:(UIView *)view&#10;&#123;&#10;  //adjust contentsRect to select correct digit&#10;  view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);&#10;&#125;&#10;&#10;- (void)tick&#10;&#123;&#10;  //convert time to hours, minutes and seconds&#10;  NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];&#10;  NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&#10;  &#65532;&#10;  NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&#10;&#10;  //set hours&#10;  [self setDigit:components.hour / 10 forView:self.digitViews[0]];&#10;  [self setDigit:components.hour % 10 forView:self.digitViews[1]];&#10;&#10;  //set minutes&#10;  [self setDigit:components.minute / 10 forView:self.digitViews[2]];&#10;  [self setDigit:components.minute % 10 forView:self.digitViews[3]];&#10;&#10;  //set seconds&#10;  [self setDigit:components.second / 10 forView:self.digitViews[4]];&#10;  [self setDigit:components.second % 10 forView:self.digitViews[5]];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>如图4.18，这样做的确起了效果，但是图片看起来模糊了。看起来默认的<code>kCAFilterLinear</code>选项让我们失望了。</p>
<p><img src="http://i1.tietuku.com/9907966a7840c64a.png"></p>
<p>图4.18 一个模糊的时钟，由默认的<code>kCAFilterLinear</code>引起</p>
<p>为了能像图4.19中那样，我们需要在for循环中加入如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.magnificationFilter = kCAFilterNearest;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/7acc929bf7f74628.png"></p>
<p>图4.19 设置了最近过滤之后的清晰显示</p>
<h2 id="组透明">组透明</h2><p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了<code>opacity</code>属性，那它的子图层都会受此影响。</p>
<p>iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p><img src="http://i1.tietuku.com/9d67bc29e9634724.png"></p>
<p>图4.20 右边的渐隐按钮中，里面的标签清晰可见</p>
<p>这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的<code>UIViewGroupOpacity</code>为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果<code>UIViewGroupOpacity</code>并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做<code>shouldRasterize</code>属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。</p>
<p>为了启用<code>shouldRasterize</code>属性，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当<code>shouldRasterize</code>和<code>UIViewGroupOpacity</code>一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。</p>
<p>清单4.7 使用<code>shouldRasterize</code>属性解决组透明问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (UIButton *)customButton&#10;&#123;&#10;  //create button&#10;  CGRect frame = CGRectMake(0, 0, 150, 50);&#10;  UIButton *button = [[UIButton alloc] initWithFrame:frame];&#10;  button.backgroundColor = [UIColor whiteColor];&#10;  button.layer.cornerRadius = 10;&#10;&#10;  //add label&#10;  frame = CGRectMake(20, 10, 110, 30);&#10;  UILabel *label = [[UILabel alloc] initWithFrame:frame];&#10;  label.text = @&#34;Hello World&#34;;&#10;  label.textAlignment = NSTextAlignmentCenter;&#10;  [button addSubview:label];&#10;  return button;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create opaque button&#10;  UIButton *button1 = [self customButton];&#10;  button1.center = CGPointMake(50, 150);&#10;  [self.containerView addSubview:button1];&#10;&#10;  //create translucent button&#10;  UIButton *button2 = [self customButton];&#10;  &#65532;&#10;  button2.center = CGPointMake(250, 150);&#10;  button2.alpha = 0.5;&#10;  [self.containerView addSubview:button2];&#10;&#10;  //enable rasterization for the translucent button&#10;  button2.layer.shouldRasterize = YES;&#10;  button2.layer.rasterizationScale = [UIScreen mainScreen].scale;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1cdd82c2af9c9a89.png"></p>
<p>图4.21 修正后的图</p>
<h2 id="总结">总结</h2><p>这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。</p>
<p>在第五章，『变换』中，我们将会研究图层变化和3D转换。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T04:58:58.000Z"><a href="/2015/04/15/主页维护记录/博客成长记/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/主页维护记录/博客成长记/">博客成长记</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="加入评论功能">加入评论功能</h2><p><em>2015-04-15 12:59:49</em>   </p>
<ol>
<li><p>使用微博或者其他帐号登录<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>,建立自己的一个帐号,同时拿到通用代码.    </p>
</li>
<li><p>取消HEXO博客根目录中的 <code>_config.yml</code> 中 <code>disqus_shortname:</code> ，暂时不用这个功能，直接永久开启多说评论。</p>
</li>
<li><p>修改主题目录下面的(我的是 <code>/themes/jacman/_config.ym</code> ) <code>_config.yml</code> 中的 </p>
</li>
</ol>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#### Comment</span></span><br><span class="line"><span class="label">duoshuo_shortname:</span> guiqingblog    <span class="preprocessor">## e.g. wuchong   your duoshuo short name.</span></span><br></pre></td></tr></table></figure>
<p>如果没有请添加.   </p>
<ol>
<li>修改 <code>themes\XXX\layout_partial\article.ejs</code><br>在最后加上下面的代码:</li>
</ol>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span> <span class="keyword">if</span><span class="comment">(!index)</span>&#123; <span class="preprocessor">%</span>&gt;</span><br><span class="line">&lt;<span class="preprocessor">%</span>- partial<span class="comment">('comment')</span> <span class="preprocessor">%</span>&gt;</span><br><span class="line">&lt;<span class="preprocessor">%</span> &#125; <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>修改 <code>themes/jacman/layout/_partial/post/comment.ejs</code> 为你通用代码的 js 部分,如果没有这个文件请新建.</li>
</ol>
<p>最终效果:  </p>
<p><img src="http://ww3.sinaimg.cn/large/9e446dffjw1er66il80t3j20mp09ujs8.jpg"></p>
<p>参考网址:  </p>
<p><a href="http://gpio.me/hexo-duoshuo.html" target="_blank" rel="external">http://gpio.me/hexo-duoshuo.html</a><br><a href="http://duoshuo.com" target="_blank" rel="external">http://duoshuo.com</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T04:47:38.000Z"><a href="/2015/04/15/iOS&OC/在类的头文件中尽量少引入其他头文件/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/iOS&OC/在类的头文件中尽量少引入其他头文件/">高效OC编程-在类的头文件中尽量少引入其他头文件</a></h1>
  

    </header>
    <div class="entry">
      
        <p>与C 和C++ 一样，Objective-C 也使用“头文件”（header file） 与“实现文件”（implementation file）来区隔代码。用Objective-C 语言编写“类”（class）的标准方式为：以类名做文件名，分别创建两个文件，头文件后缀用.h，实现文件后缀用.m。创建好一个类之后，其代码看上去如下所示:   </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCPerson.h</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCPerson.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"EOCPerson.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span></span></span><br><span class="line"><span class="comment">// Implementation of methods</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/15/iOS&OC/在类的头文件中尽量少引入其他头文件/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T01:32:52.000Z"><a href="/2015/04/15/Core Aniamtion深入探讨/3-图层几何学/图层几何学/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/Core Aniamtion深入探讨/3-图层几何学/图层几何学/">3-图层几何学</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="图层几何学">图层几何学</h1><blockquote>
<p><em>不熟悉几何学的人就不要来这里了</em> —柏拉图学院入口的签名</p>
</blockquote>
<p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<h2 id="布局">布局</h2><p><code>UIView</code>有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，<code>CALayer</code>对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p><code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>所在的位置。<code>anchorPoint</code>的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="http://i1.tietuku.com/71af11930be4457f.jpg" alt="图3.1" title="图3.1" width="700"></p>
<p>图3.1 <code>UIView</code>和<code>CALayer</code>的坐标系</p>
<p>视图的<code>frame</code>，<code>bounds</code>和<code>center</code>属性仅仅是<em>存取方法</em>，当操纵视图的<code>frame</code>，实际上是在改变位于视图下方<code>CALayer</code>的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<p>对于视图或者图层来说，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，<code>frame</code>实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说<code>frame</code>的宽高可能和<code>bounds</code>的宽高不再一致了（图3.2）</p>
<p><img src="http://i1.tietuku.com/b3cc087d8701c6c4.jpg"></p>
<p>图3.2 旋转一个视图或者图层之后的<code>frame</code>属性</p>
<h2 id="锚点">锚点</h2><p>之前提到过，视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置，你可以认为<code>anchorPoint</code>是用来移动图层的<em>把柄</em>。</p>
<p>默认来说，<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。<code>anchorPoint</code>属性并没有被<code>UIView</code>接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的<code>anchorPoint</code>可以被移动，比如你可以把它置于图层<code>frame</code>的左上角，于是图层的内容将会向右下角的<code>position</code>方向移动（图3.3），而不是居中了。</p>
<p><img src="http://i1.tietuku.com/cd0b18512266f4e8.jpg"></p>
<p>图3.3 改变<code>anchorPoint</code>的效果</p>
<p>和第二章提到的<code>contentsRect</code>和<code>contentsCenter</code>属性类似，<code>anchorPoint</code>用<em>单位坐标</em>来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。<code>anchorPoint</code>可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了<code>anchorPoint</code>，<code>position</code>属性保持固定的值并没有发生改变，但是<code>frame</code>却移动了。</p>
<p>那在什么场合需要改变<code>anchorPoint</code>呢？既然我们可以随意改变图层位置，那改变<code>anchorPoint</code>不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个<code>UIImageView</code>实例（当然你也可以用正常的视图，设置他们图层的<code>contents</code>图片）。</p>
<p><img src="http://i1.tietuku.com/4cf92548d6313258.jpg"></p>
<p>图3.4 组成钟面和钟表的四张图片</p>
<p>闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的<code>frame</code>，而根据图3.2的演示，当视图旋转的时候，<code>frame</code>是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用<code>NSTimer</code>来更新闹钟，使用视图的<code>transform</code>属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="http://i1.tietuku.com/2eb6826a87ecce6b.jpg"></p>
<p>图3.5 在Interface Builder中布局闹钟视图</p>
<p>清单3.1 <strong>Clock</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIImageView *hourHand;&#10;@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;&#10;@property (nonatomic, weak) IBOutlet UIImageView *secondHand;&#10;@property (nonatomic, weak) NSTimer *timer;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //start timer&#10;    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&#10;                  &#65532;&#10;    //set initial hand positions&#10;    [self tick];&#10;&#125;&#10;&#10;- (void)tick&#10;&#123;&#10;    //convert time to hours, minutes and seconds&#10;    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];&#10;    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&#10;    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&#10;    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;&#10;    //calculate hour hand angle //calculate minute hand angle&#10;    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;&#10;    //calculate second hand angle&#10;    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;&#10;    //rotate hands&#10;    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);&#10;    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);&#10;    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。</p>
<p><img src="http://i1.tietuku.com/8718ca04ee738767.jpg"></p>
<p>图3.6 钟面，和不对齐的钟指针</p>
<p>你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用<code>anchorPoint</code>属性，我们来在<code>-viewDidLoad</code>方法中添加几行代码来给每个钟指针的<code>anchorPoint</code>做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>清单3.2<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#10;&#123;&#10;    [super viewDidLoad];&#10;    // adjust anchor points&#10;&#10;    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &#10;    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &#10;    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);&#10;&#10;&#10;    // start timer&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://i1.tietuku.com/e93155e73f1094dd.jpg"></p>
<p>图3.7 钟面，和正确对齐的钟指针</p>
<h2 id="坐标系">坐标系</h2><p>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的<code>position</code>依赖于它父图层的<code>bounds</code>，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的<em>绝对</em>位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。</p>
<p><code>CALayer</code>给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<pre><code><span class="tag">-</span> (<span class="tag">CGPoint</span>)<span class="rule"><span class="attribute">convertPoint</span>:<span class="value">(CGPoint)point fromLayer:(CALayer *)layer</span></span>; 
<span class="tag">-</span> (<span class="tag">CGPoint</span>)<span class="rule"><span class="attribute">convertPoint</span>:<span class="value">(CGPoint)point toLayer:(CALayer *)layer</span></span>; 
<span class="tag">-</span> (<span class="tag">CGRect</span>)<span class="rule"><span class="attribute">convertRect</span>:<span class="value">(CGRect)rect fromLayer:(CALayer *)layer</span></span>;
<span class="tag">-</span> (<span class="tag">CGRect</span>)<span class="rule"><span class="attribute">convertRect</span>:<span class="value">(CGRect)rect toLayer:(CALayer *)layer</span></span>;
</code></pre><p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<h3 id="翻转的几何结构">翻转的几何结构</h3><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个<code>BOOL</code>类型。在iOS上通过设置它为<code>YES</code>意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的<code>geometryFlipped</code>属性也设为<code>YES</code>）。</p>
<h3 id="Z坐标轴">Z坐标轴</h3><p>和<code>UIView</code>严格的二维坐标系不同，<code>CALayer</code>存在于一个三维空间当中。除了我们已经讨论过的<code>position</code>和<code>anchorPoint</code>属性之外，<code>CALayer</code>还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更<em>深</em>的属性来描述由宽和高做成的<code>bounds</code>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p><code>zPosition</code>属性在大多数情况下其实并不常用。在第五章，我们将会涉及<code>CATransform3D</code>，你会知道如何在三维空间移动和旋转图层，除了做变换之外，<code>zPosition</code>最实用的功能就是改变图层的<em>显示顺序</em>了。</p>
<p>通常，图层是根据它们子图层的<code>sublayers</code>出现的顺序来类绘制的，这就是所谓的<em>画家的算法</em>—就像一个画家在墙上作画—后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的<code>zPosition</code>，就可以把图层向相机方向<em>前置</em>，于是它就在所有其他图层的<em>前面</em>了（或者至少是小于它的<code>zPosition</code>值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="http://i1.tietuku.com/f648365a2b676b41.jpg"></p>
<p>图3.8 在视图层级中绿色视图被绘制在红色视图的后面</p>
<p>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的<code>zPosition</code>（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给<code>zPosition</code>提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>清单3.3</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *greenView;&#10;@property (nonatomic, weak) IBOutlet UIView *redView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    &#65532;&#10;    //move the green view zPosition nearer to the camera&#10;    self.greenView.layer.zPosition = 1.0f;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/5bc7eba82db3b159.jpg"></p>
<p>图3.9 绿色视图被绘制在红色视图的前面</p>
<h2 id="Hit_Testing">Hit Testing</h2><p>第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p><code>CALayer</code>并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<p><code>-containsPoint:</code>接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层<code>frame</code>范围内就返回<code>YES</code>。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用<code>-containsPoint:</code>方法来判断到底是白色还是蓝色的图层被触摸了<br>（图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>清单3.4 使用containsPoint判断被点击的图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView;&#10;@property (nonatomic, weak) CALayer *blueLayer;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create sublayer&#10;    self.blueLayer = [CALayer layer];&#10;    self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);&#10;    self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;&#10;    //add it to our view&#10;    [self.layerView.layer addSublayer:self.blueLayer];&#10;&#125;&#10;&#10;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#10;&#123;&#10;    //get touch position relative to main view&#10;    CGPoint point = [[touches anyObject] locationInView:self.view];&#10;    //convert point to the white layer&#39;s coordinates&#10;    point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];&#10;    //get layer using containsPoint:&#10;    if ([self.layerView.layer containsPoint:point]) &#123;&#10;        //convert point to blueLayer&#8217;s coordinates&#10;        point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];&#10;        if ([self.blueLayer containsPoint:point]) &#123;&#10;            [[[UIAlertView alloc] initWithTitle:@&#34;Inside Blue Layer&#34; &#10;                                        message:nil&#10;                                       delegate:nil &#10;                              cancelButtonTitle:@&#34;OK&#34;&#10;                              otherButtonTitles:nil] show];&#10;        &#125; else &#123;&#10;            [[[UIAlertView alloc] initWithTitle:@&#34;Inside White Layer&#34;&#10;                                        message:nil &#10;                                       delegate:nil&#10;                              cancelButtonTitle:@&#34;OK&#34;&#10;                              otherButtonTitles:nil] show];&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/163d32eb250cae4f.jpg"></p>
<p>图3.10 点击图层被正确标识</p>
<p><code>-hitTest:</code>方法同样接受一个<code>CGPoint</code>类型参数，而不是<code>BOOL</code>类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用<code>-containsPoint:</code>那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用<code>-hitTest:</code>方法被点击图层的代码如清单3.5所示。</p>
<p>清单3.5 使用hitTest判断被点击的图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#10;&#123;&#10;    //get touch position&#10;    CGPoint point = [[touches anyObject] locationInView:self.view];&#10;    //get touched layer&#10;    CALayer *layer = [self.layerView.layer hitTest:point];&#10;    //get layer using hitTest&#10;    if (layer == self.blueLayer) &#123;&#10;        [[[UIAlertView alloc] initWithTitle:@&#34;Inside Blue Layer&#34;&#10;                                    message:nil&#10;                                   delegate:nil&#10;                          cancelButtonTitle:@&#34;OK&#34;&#10;                          otherButtonTitles:nil] show];&#10;    &#125; else if (layer == self.layerView.layer) &#123;&#10;        [[[UIAlertView alloc] initWithTitle:@&#34;Inside White Layer&#34;&#10;                                    message:nil&#10;                                   delegate:nil&#10;                          cancelButtonTitle:@&#34;OK&#34;&#10;                          otherButtonTitles:nil] show];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的<code>zPosition</code>值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<h2 id="自动布局">自动布局</h2><p>你可能用过<code>UIViewAutoresizingMask</code>类型的一些常量，应用于当父视图改变尺寸的时候，相应<code>UIView</code>的<code>frame</code>也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了<em>自动排版</em>机制，它和自动调整不同，并且更加复杂。</p>
<p>在Mac OS平台，<code>CALayer</code>有一个叫做<code>layoutManager</code>的属性可以通过<code>CALayoutManager</code>协议和<code>CAConstraintLayoutManager</code>类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用<code>UIView</code>类接口暴露出来的<code>UIViewAutoresizingMask</code>和<code>NSLayoutConstraint</code>API，但如果想随意控制<code>CALayer</code>的布局，就需要手工操作。最简单的方法就是使用<code>CALayerDelegate</code>如下函数：</p>
<pre><code><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">layoutSublayersOfLayer</span>:<span class="value">(CALayer *)layer</span></span>;
</code></pre><p>当图层的<code>bounds</code>发生改变，或者图层的<code>-setNeedsLayout</code>方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像<code>UIView</code>的<code>autoresizingMask</code>和<code>constraints</code>属性做到自适应屏幕旋转。</p>
<p>这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。</p>
<h2 id="总结">总结</h2><p>本章涉及了<code>CALayer</code>的集合结构，包括它的<code>frame</code>，<code>position</code>和<code>bounds</code>，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-14T04:54:11.000Z"><a href="/2015/04/14/辅助编程技能/git问题汇总/">2015-04-14</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/14/辅助编程技能/git问题汇总/">git问题汇总</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="2015-04-14_12:54:43">2015-04-14 12:54:43</h3><h4 id="问题描述">问题描述</h4><p>使用git add添加要提交的文件的时候，如果文件名是中文，会显示形如274\232\350\256\256\346\200\273\347\273\223.png的乱码。</p>
<h4 id="解决方案">解决方案</h4><p>在终端输入    </p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">global</span> core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="说明">说明</h4><p>core.quotepath设为false的话，就不会对0×80以上的字符进行quote。中文显示正常。  </p>
<h4 id="问题描述-1">问题描述</h4><p>在MsysGit中，使用git log显示提交的中文log乱码。</p>
<h4 id="解决方案-1">解决方案</h4><p>设置git gui的界面编码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global gui<span class="class">.encoding</span> utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>设置 commit log 提交时使用 utf-8 编码，可避免服务器上乱码，同时与linux上的提交保持一致！</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n<span class="class">.commitencoding</span> utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>使得在 <code>$ git log</code> 时将 utf-8 编码转换成 gbk 编码，解决Msys bash中git log 乱码。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n<span class="class">.logoutputencoding</span> gbk</span><br></pre></td></tr></table></figure>
<p>使得 git log 可以正常显示中文（配合i18n.logoutputencoding = gbk)，在 /etc/profile 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LESSCHARSET=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="问题描述-2">问题描述</h4><p>在MsysGit自带的bash中，使用ls命令查看中文文件名乱码。cygwin没有这个问题。  </p>
<h4 id="解决方案-2">解决方案</h4><p>使用 <code>lls --show-control-chars</code> 命令来强制使用控制台字符编码显示文件名，即可查看中文文件名。</p>
<p>为了方便使用，可以编辑 <code>/etc/git-completion.bash</code> ，新增一行 <code>alias ls=&quot;ls --show-control-chars&quot;</code>  </p>
<p>参考地址:<a href="http://www.cnblogs.com/perseus/archive/2012/11/21/2781074.html" target="_blank" rel="external">http://www.cnblogs.com/perseus/archive/2012/11/21/2781074.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-14T03:03:13.000Z"><a href="/2015/04/14/主页维护记录/网站错误解决日志/">2015-04-14</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/14/主页维护记录/网站错误解决日志/">网站错误解决日志</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="时间">时间</h2><h3 id=""> </h3><h2 id="时间_2015-04-14_11:10:43">时间 2015-04-14 11:10:43</h2><h3 id="问题描述">问题描述</h3><p>今天使用 hexo 部署到 git 的时候,报错:  </p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Error: <span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span>@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line"><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span>@</span><br><span class="line">Permissions <span class="number">0777</span> <span class="keyword">for</span> <span class="string">'/Users/katsura/.ssh/id_rsa'</span> are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">bad permissions: ignore key: /Users/katsura/.ssh/id_rsa</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository <span class="keyword">exists</span>.</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/Users/katsura/Git/guiqingblog.github.io/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:<span class="number">42</span>:<span class="number">17</span>)</span><br><span class="line">    at ChildProcess.<span class="keyword">emit</span> (events.js:<span class="number">98</span>:<span class="number">17</span>)</span><br><span class="line">    at maybeClose (child_process.js:<span class="number">766</span>:<span class="number">16</span>)</span><br><span class="line">    at Socket.&lt;anonymous&gt; (child_process.js:<span class="number">979</span>:<span class="number">11</span>)</span><br><span class="line">    at Socket.<span class="keyword">emit</span> (events.js:<span class="number">95</span>:<span class="number">17</span>)</span><br><span class="line">    at Pipe.close (net.js:<span class="number">466</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/14/主页维护记录/网站错误解决日志/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-13T14:25:14.000Z"><a href="/2015/04/13/iOS&OC/UIApplication-tips/">2015-04-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/13/iOS&OC/UIApplication-tips/">UIApplication tips -给新手的笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="UIApplication_对象是应用程序的象征">UIApplication 对象是应用程序的象征</h3><p>每一个应用程序都有自己的 UIApplication对象,而且是单例的.<br>通过 [UIApplication sharedApplication]可以获得这个单例对象<br>一个iOS程序启动后创建的第一个对象就是 UIApplication 对象<br>一个iOS程序启动后创建的第一个对象就是 UIApplication 对象<br>利用 UIApplication 对象,能进行一些应用级别的操作 </p>
<p>验证单例操作:  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIApplication</span> *app  = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">    <span class="built_in">UIApplication</span> *app2 = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">    <span class="built_in">UIApplication</span> *app3 = [[<span class="built_in">UIApplication</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p,%p,%p"</span>,app,app2,app3);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/13/iOS&OC/UIApplication-tips/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-13T01:32:52.000Z"><a href="/2015/04/13/Core Aniamtion深入探讨/2-寄宿图/寄宿图/">2015-04-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/13/Core Aniamtion深入探讨/2-寄宿图/寄宿图/">2-寄宿图</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="寄宿图">寄宿图</h1><blockquote>
<p>图片胜过千言万语，界面抵得上千图片  ——Ben Shneiderman</p>
</blockquote>
<p>我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。</p>
<h2 id="contents属性">contents属性</h2><p>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p>
<p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p>
<p>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。</p>
<p>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contents = (__bridge id)image.CGImage;</span><br></pre></td></tr></table></figure>
<p>如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p>
<p>让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的<code>contents</code>属性设置成图片。</p>
<p>清单2.1 更新后的代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //load an image&#10;  UIImage *image = [UIImage imageNamed:@&#34;Snowman.png&#34;];&#10;&#10;  //add it directly to our view&#39;s layer&#10;  self.layerView.layer.contents = (__bridge id)image.CGImage;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>图表2.1 在UIView的宿主图层中显示一张图片</p>
<p><img src="http://i1.tietuku.com/32c66c1156e89ff6.png"></p>
<p>我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。</p>
<p><strong>contentGravity</strong></p>
<p>你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把<code>contentMode</code>属性设置成更合适的值，像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.contentMode = UIViewContentModeScaleAspectFit;</span><br></pre></td></tr></table></figure>
<p>这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如<code>contentMode</code>，对这些属性的操作其实是对对应图层的操作。</p>
<p>CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。<code>contentsGravity</code>可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<p>和<code>cotentMode</code>一样，<code>contentsGravity</code>的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</span><br></pre></td></tr></table></figure>
<p>图2.2 可以看到结果</p>
<p><img src="http://i1.tietuku.com/e60dd08653489c05.png"></p>
<p>图2.2 正确地设置<code>contentsGravity</code>的值</p>
<h2 id="contentsScale">contentsScale</h2><p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p><code>contentsScale</code>的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为<code>contents</code>由于设置了<code>contentsGravity</code>属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的<code>contents</code>图片，你可以通过使用图层的<code>transform</code>和<code>affineTransform</code>属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是<code>contentsScale</code>的目的所在.</p>
<p><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置<code>contentsGravity</code>属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。</p>
<p>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。</p>
<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）</p>
<p><img src="http://i1.tietuku.com/265368df4b0dee5d.png"></p>
<p>图2.3 用错误的<code>contentsScale</code>属性显示Retina图片</p>
<p>如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置<code>contentsScale</code>来修复这个问题（如2.2清单），图2.4是结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //load an image&#10;  UIImage *image = [UIImage imageNamed:@&#34;Snowman.png&#34;]; //add it directly to our view&#39;s layer&#10;  self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image&#10;  self.layerView.layer.contentsGravity = kCAGravityCenter;&#10;&#10;  //set the contentsScale to match image&#10;  self.layerView.layer.contentsScale = image.scale;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/7ed03480b54336a5.png"></p>
<p>图2.4 同样的Retina图片设置了正确的<code>contentsScale</code>之后</p>
<p>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的<code>contentsScale</code>属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contentsScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>
<h2 id="maskToBounds">maskToBounds</h2><p>现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。</p>
<p>UIView有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code>，把它设置为YES，雪人就在边界里啦～（如图2.5）</p>
<p><img src="http://i1.tietuku.com/fd4ce0c4dd5a0cc1.png"></p>
<p>图2.5 使用<code>masksToBounds</code>来修建图层内容</p>
<h2 id="contentsRect">contentsRect</h2><p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比<code>contentsGravity</code>灵活多了</p>
<p>和<code>bounds</code>，<code>frame</code>不同，<code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<p>默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）</p>
<p><img src="http://i1.tietuku.com/87eb9c5c16057eb0.png"></p>
<p>图2.6 一个自定义的<code>contentsRect</code>（左）和之前显示的内容（右）</p>
<p>事实上给<code>contentsRect</code>设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p><code>contentsRect</code>在app中最有趣的地方在于一个叫做<em>image sprites</em>（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</p>
<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</p>
<p>2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用<code>contentsRect</code></p>
<p>首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：</p>
<p><img src="http://i1.tietuku.com/cfbaa7a4d5061b3a.png"></p>
<p>接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的<code>contents</code>，然后设置每个图层的<code>contentsRect</code>来去掉我们不想显示的部分。</p>
<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;@interface ViewController ()&#10;@property (nonatomic, weak) IBOutlet UIView *coneView;&#10;@property (nonatomic, weak) IBOutlet UIView *shipView;&#10;@property (nonatomic, weak) IBOutlet UIView *iglooView;&#10;@property (nonatomic, weak) IBOutlet UIView *anchorView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect &#65532;toLayer:(CALayer *)layer //set image&#10;&#123;&#10;  layer.contents = (__bridge id)image.CGImage;&#10;&#10;  //scale contents to fit&#10;  layer.contentsGravity = kCAGravityResizeAspect;&#10;&#10;  //set contentsRect&#10;  layer.contentsRect = rect;&#10;&#125;&#10;&#10;- (void)viewDidLoad &#10;&#123;&#10;  [super viewDidLoad]; //load sprite sheet&#10;  UIImage *image = [UIImage imageNamed:@&#34;Sprites.png&#34;];&#10;  //set igloo sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];&#10;  //set cone sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];&#10;  //set anchor sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];&#10;  //set spaceship sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/cfbaa7a4d5061b3a.png"></p>
<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。</p>
<p>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置<code>contentsRect</code>，这样开发者就不用手动写代码来摆放位置了。</p>
<p>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites" target="_blank" rel="external">https://github.com/nicklockwood/LayerSprites</a>)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。</p>
<h2 id="contentsCenter">contentsCenter</h2><p>本章我们介绍的最后一个和内容有关的属性是<code>contentsCenter</code>，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。<code>contentsCenter</code>其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<p>默认情况下，<code>contentsCenter</code>是{0, 0, 1, 1}，这意味着如果大小（由<code>conttensGravity</code>决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了<code>contentsCenter</code>设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>
<p><img src="http://i1.tietuku.com/b3f2cc3480447a08.png"></p>
<p>图2.9 <code>contentsCenter</code>的例子</p>
<p>这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。</p>
<p><img src="http://i1.tietuku.com/36ceb25b30b0c7dd.png"></p>
<p>图2.10 同一图片使用不同的<code>contentsCenter</code></p>
<p>清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11</p>
<p>清单2.4 用<code>contentsCenter</code>设置可拉伸视图</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *button1;&#10;@property (nonatomic, weak) IBOutlet UIView *button2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)addStretchableImage:(UIImage *)image withContentCenter:(CGRect)rect toLayer:(CALayer *)layer&#10;&#123;  &#10;  //set image&#10;  layer.contents = (__bridge id)image.CGImage;&#10;&#10;  //set contentsCenter&#10;  layer.contentsCenter = rect;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //load button image&#10;  UIImage *image = [UIImage imageNamed:@&#34;Button.png&#34;];&#10;&#10;  //set button 1&#10;  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button1.layer];&#10;&#10;  //set button 2&#10;  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button2.layer];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/f4ac7ce4f38e0537.png"></p>
<p>图2.11 用Interface Builder 探测窗口控制<code>contentsCenter</code>属性</p>
<h2 id="Custome_Drawing">Custome Drawing</h2><p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
<p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</p>
<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code>协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（<code>delegate</code>属性被声明为id类型，所有的代理方法都是可选的）。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(void)displayLayer:(CALayerCALayer *)layer;</span><br></pre></td></tr></table></figure>
<p>趁着这个机会，如果代理想直接设置<code>contents</code>属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现<code>-displayLayer:</code>方法，CALayer就会转而尝试调用下面这个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</span><br></pre></td></tr></table></figure>
<p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<p>让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是他的结果</p>
<p>清单2.5 实现CALayerDelegate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;  &#65532;&#10;  //create sublayer&#10;  CALayer *blueLayer = [CALayer layer];&#10;  blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);&#10;  blueLayer.backgroundColor = [UIColor blueColor].CGColor;&#10;&#10;  //set controller as layer delegate&#10;  blueLayer.delegate = self;&#10;&#10;  //ensure that layer backing image uses correct scale&#10;  blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view&#10;  [self.layerView.layer addSublayer:blueLayer];&#10;&#10;  //force layer to redraw&#10;  [blueLayer display];&#10;&#125;&#10;&#10;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#10;&#123;&#10;  //draw a thick red circle&#10;  CGContextSetLineWidth(ctx, 10.0f); &#10;  CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);&#10;  CGContextStrokeEllipseInRect(ctx, layer.bounds);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1bc64ecb7d221235.png"></p>
<p>图2.12 实现CALayerDelegate来绘制图层</p>
<p>注意一下一些有趣的事情：</p>
<ul>
<li>我们在blueLayer上显式地调用了<code>-display</code>。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用<code>masksToBounds</code>属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<p>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个<code>-displayLayer:</code>的实现，那所有的问题就都没了。</p>
<p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>
<h2 id="总结">总结</h2><p>本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。</p>
<p>在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察他们是如何放置和改变相互的尺寸的。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-12T12:11:09.000Z"><a href="/2015/04/12/iOS&OC/25条提升iOS-App性能的建议/">2015-04-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/12/iOS&OC/25条提升iOS-App性能的建议/">25条提升iOS App性能的建议-iOS 方法论</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="25条提高_iOS_App_性能的建议">25条提高 iOS App 性能的建议</h2><p>性能关系到用户体验,所以它对于我们的开发来说是至关重要的.  </p>
<h3 id="特别注意:">特别注意:</h3><p>在优化代码之后,必须保证有个需要解决的问题!不要陷入”pre-optimizing(预优化)”你的代码.用Instruments分析你的代码,来发现需要提高的地方.</p>
<p>下面是一些值得预先考虑的地方,分为三个不同的级别-基础,中级,高级<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/12/iOS&OC/25条提升iOS-App性能的建议/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Swift进阶/">Swift进阶</a><small>1</small></li>
  
    <li><a href="/categories/iOS-OC/">iOS&amp;OC</a><small>26</small></li>
  
    <li><a href="/categories/主页维护记录/">主页维护记录</a><small>3</small></li>
  
    <li><a href="/categories/应用架构/">应用架构</a><small>2</small></li>
  
    <li><a href="/categories/知识技巧总结/">知识技巧总结</a><small>2</small></li>
  
    <li><a href="/categories/辅助编程技能/">辅助编程技能</a><small>5</small></li>
  
    <li><a href="/categories/高效OC编程/">高效OC编程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/tags/Swift-进阶/">Swift 进阶</a><small>1</small></li>
  
    <li><a href="/tags/主页维护记录/">主页维护记录</a><small>1</small></li>
  
    <li><a href="/tags/小脚本大智慧/">小脚本大智慧</a><small>1</small></li>
  
    <li><a href="/tags/正则表达式/">正则表达式</a><small>2</small></li>
  
    <li><a href="/tags/测试小样/">测试小样</a><small>1</small></li>
  
    <li><a href="/tags/辅助编程技能/">辅助编程技能</a><small>2</small></li>
  
    <li><a href="/tags/问题解决和思考/">问题解决和思考</a><small>5</small></li>
  
    <li><a href="/tags/高效OC编程/">高效OC编程</a><small>4</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 桂庆
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>