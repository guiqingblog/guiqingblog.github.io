<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | 桂庆的个人主页</title>
  <meta name="author" content="桂庆">
  
  <meta name="description" content="桂庆的个人主页 记录自己的学习 工作 感悟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="桂庆的个人主页"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="桂庆的个人主页" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">桂庆的个人主页</a></h1>
  <h2><a href="/">记录自己的学习 工作 感悟</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-23T01:32:52.000Z"><a href="/2015/04/23/Core Aniamtion深入探讨/6-专有图层/6-专有图层/">2015-04-23</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/23/Core Aniamtion深入探讨/6-专有图层/6-专有图层/">6-专有图层</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="专用图层">专用图层</h2><blockquote>
<p>复杂的组织都是专门化的</p>
<p>Catharine R. Stimpson</p>
</blockquote>
<p>到目前为止，我们已经探讨过<code>CALayer</code>类了，同时我们也了解到了一些非常有用的绘图和动画功能。但是Core Animation图层不仅仅能作用于图片和颜色而已。本章就会学习其他的一些图层类，进一步扩展使用Core Animation绘图的能力。</p>
<h2 id="CAShapeLayer">CAShapeLayer</h2><p>在第四章『视觉效果』我们学习到了不使用图片的情况下用<code>CGPath</code>去构造任意形状的阴影。如果我们能用同样的方式创建相同形状的图层就好了。</p>
<p><code>CAShapeLayer</code>是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用<code>CGPath</code>来定义想要绘制的图形，最后<code>CAShapeLayer</code>就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的<code>CALyer</code>的内容中绘制一个路径，相比直下，使用<code>CAShapeLayer</code>有以下一些优点：</p>
<ul>
<li>渲染快速。<code>CAShapeLayer</code>使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个<code>CAShapeLayer</code>不需要像普通<code>CALayer</code>一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个<code>CAShapeLayer</code>可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通<code>CALayer</code>一样被剪裁掉（如我们在第二章所见）。</li>
<li>不会出现像素化。当你给<code>CAShapeLayer</code>做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h3 id="创建一个CGPath">创建一个<code>CGPath</code></h3><p><code>CAShapeLayer</code>可以用来绘制所有能够通过<code>CGPath</code>来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如<code>lineWith</code>（线宽，用点表示单位），<code>lineCap</code>（线条结尾的样子），和<code>lineJoin</code>（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。</p>
<p>清单6.1 的代码用一个<code>CAShapeLayer</code>渲染一个简单的火柴人。<code>CAShapeLayer</code>属性是<code>CGPathRef</code>类型，但是我们用<code>UIBezierPath</code>帮助类创建了图层路径，这样我们就不用考虑人工释放<code>CGPath</code>了。图6.1是代码运行的结果。虽然还不是很完美，但是总算知道了大意对吧！</p>
<p>清单6.1 用<code>CAShapeLayer</code>绘制一个火柴人</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;DrawingView.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;  //create path&#10;  UIBezierPath *path = [[UIBezierPath alloc] init];&#10;  [path moveToPoint:CGPointMake(175, 100)];&#10;  &#65532;&#10;  [path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];&#10;  [path moveToPoint:CGPointMake(150, 125)];&#10;  [path addLineToPoint:CGPointMake(150, 175)];&#10;  [path addLineToPoint:CGPointMake(125, 225)];&#10;  [path moveToPoint:CGPointMake(150, 175)];&#10;  [path addLineToPoint:CGPointMake(175, 225)];&#10;  [path moveToPoint:CGPointMake(100, 150)];&#10;  [path addLineToPoint:CGPointMake(200, 150)];&#10;&#10;  //create shape layer&#10;  CAShapeLayer *shapeLayer = [CAShapeLayer layer];&#10;  shapeLayer.strokeColor = [UIColor redColor].CGColor;&#10;  shapeLayer.fillColor = [UIColor clearColor].CGColor;&#10;  shapeLayer.lineWidth = 5;&#10;  shapeLayer.lineJoin = kCALineJoinRound;&#10;  shapeLayer.lineCap = kCALineCapRound;&#10;  shapeLayer.path = path.CGPath;&#10;  //add it to our view&#10;  [self.containerView.layer addSublayer:shapeLayer];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/0c3ef267d5bc7abc.png"></p>
<p>图6.1 用<code>CAShapeLayer</code>绘制一个简单的火柴人</p>
<h3 id="圆角">圆角</h3><p>第二章里面提到了<code>CAShapeLayer</code>为创建圆角视图提供了一个方法，就是<code>CALayer</code>的<code>cornerRadius</code>属性（译者注：其实是在第四章提到的）。虽然使用<code>CAShapeLayer</code>类需要更多的工作，但是它有一个优势就是可以单独指定每个角。</p>
<p>我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上<code>UIBezierPath</code>有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//define path parameters&#10;CGRect rect = CGRectMake(50, 50, 100, 100);&#10;CGSize radii = CGSizeMake(20, 20);&#10;UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;&#10;//create path&#10;UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</span><br></pre></td></tr></table></figure>
<p>我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把<code>CAShapeLayer</code>作为视图的宿主图层，而不是添加一个子视图（图层蒙板的详细解释见第四章『视觉效果』）。</p>
<h2 id="CATextLayer">CATextLayer</h2><p>用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。</p>
<p>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容（这就是UILabel的精髓）。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还要逻辑上判断哪个图层需要显示哪个字符串，更别提还要记录不同的字体，颜色等一系列乱七八糟的东西。</p>
<p>万幸的是这些都是不必要的，Core Animation提供了一个<code>CALayer</code>的子类<code>CATextLayer</code>，它以图层的形式包含了<code>UILabel</code>几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>同样，<code>CATextLayer</code>也要比<code>UILabel</code>渲染得快得多。很少有人知道在iOS 6及之前的版本，<code>UILabel</code>其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而<code>CATextLayer</code>使用了Core text，并且渲染得非常快。</p>
<p>让我们来尝试用<code>CATextLayer</code>来显示一些文字。清单6.2的代码实现了这一功能，结果如图6.2所示。</p>
<p>清单6.2 用<code>CATextLayer</code>来实现一个<code>UILabel</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *labelView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create a text layer&#10;  CATextLayer *textLayer = [CATextLayer layer];&#10;  textLayer.frame = self.labelView.bounds;&#10;  [self.labelView.layer addSublayer:textLayer];&#10;&#10;  //set text attributes&#10;  textLayer.foregroundColor = [UIColor blackColor].CGColor;&#10;  textLayer.alignmentMode = kCAAlignmentJustified;&#10;  textLayer.wrapped = YES;&#10;&#10;  //choose a font&#10;  UIFont *font = [UIFont systemFontOfSize:15];&#10;&#10;  //set layer font&#10;  CFStringRef fontName = (__bridge CFStringRef)font.fontName;&#10;  CGFontRef fontRef = CGFontCreateWithFontName(fontName);&#10;  textLayer.font = fontRef;&#10;  textLayer.fontSize = font.pointSize;&#10;  CGFontRelease(fontRef);&#10;&#10;  //choose some text&#10;  NSString *text = @&#34;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&#34;;&#10;&#10;  //set layer text&#10;  textLayer.string = text;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/5bd6fcd0d8296dd3.png"></p>
<p>图6.2 用<code>CATextLayer</code>来显示一个纯文本标签</p>
<p>如果你仔细看这个文本，你会发现一个奇怪的地方：这些文本有一些像素化了。这是因为并没有以Retina的方式渲染，第二章提到了这个<code>contentScale</code>属性，用来决定图层内容应该以怎样的分辨率来渲染。<code>contentsScale</code>并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来显示文字，我们就得手动地设置<code>CATextLayer</code>的<code>contentsScale</code>属性，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textLayer.contentsScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>
<p>这样就解决了这个问题（如图6.3）</p>
<p><img src="http://i1.tietuku.com/54374edb2978ba15.png"></p>
<p>图6.3 设置<code>contentsScale</code>来匹配屏幕</p>
<p><code>CATextLayer</code>的<code>font</code>属性不是一个<code>UIFont</code>类型，而是一个<code>CFTypeRef</code>类型。这样可以根据你的具体需要来决定字体属性应该是用<code>CGFontRef</code>类型还是<code>CTFontRef</code>类型（Core Text字体）。同时字体大小也是用<code>fontSize</code>属性单独设置的，因为<code>CTFontRef</code>和<code>CGFontRef</code>并不像UIFont一样包含点大小。这个例子会告诉你如何将<code>UIFont</code>转换成<code>CGFontRef</code>。</p>
<p>另外，<code>CATextLayer</code>的<code>string</code>属性并不是你想象的<code>NSString</code>类型，而是<code>id</code>类型。这样你既可以用<code>NSString</code>也可以用<code>NSAttributedString</code>来指定文本了（注意，<code>NSAttributedString</code>并不是<code>NSString</code>的子类）。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体，颜色，字重，斜体等。</p>
<h3 id="富文本">富文本</h3><p>iOS 6中，Apple给<code>UILabel</code>和其他UIKit文本视图添加了直接的属性化字符串的支持，应该说这是一个很方便的特性。不过事实上从iOS3.2开始<code>CATextLayer</code>就已经支持属性化字符串了。这样的话，如果你想要支持更低版本的iOS系统，<code>CATextLayer</code>无疑是你向界面中增加富文本的好办法，而且也不用去跟复杂的Core Text打交道，也省了用<code>UIWebView</code>的麻烦。</p>
<p>让我们编辑一下示例使用到<code>NSAttributedString</code>（见清单6.3）.iOS 6及以上我们可以用新的<code>NSTextAttributeName</code>实例来设置我们的字符串属性，但是练习的目的是为了演示在iOS 5及以下，所以我们用了Core Text，也就是说你需要把Core Text framework添加到你的项目中。否则，编译器是无法识别属性常量的。</p>
<p>图6.4是代码运行结果（注意那个红色的下划线文本）</p>
<p>清单6.3 用NSAttributedString实现一个富文本标签。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;DrawingView.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;#import &#60;CoreText/CoreText.h&#62;&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *labelView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create a text layer&#10;  CATextLayer *textLayer = [CATextLayer layer];&#10;  textLayer.frame = self.labelView.bounds;&#10;  textLayer.contentsScale = [UIScreen mainScreen].scale;&#10;  [self.labelView.layer addSublayer:textLayer];&#10;&#10;  //set text attributes&#10;  textLayer.alignmentMode = kCAAlignmentJustified;&#10;  textLayer.wrapped = YES;&#10;&#10;  //choose a font&#10;  UIFont *font = [UIFont systemFontOfSize:15];&#10;&#10;  //choose some text&#10;  NSString *text = @&#34;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc \ elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&#34;;&#10;  &#65532;&#10;  //create attributed string&#10;  NSMutableAttributedString *string = nil;&#10;  string = [[NSMutableAttributedString alloc] initWithString:text];&#10;&#10;  //convert UIFont to a CTFont&#10;  CFStringRef fontName = (__bridge CFStringRef)font.fontName;&#10;  CGFloat fontSize = font.pointSize;&#10;  CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);&#10;&#10;  //set text attributes&#10;  NSDictionary *attribs = @&#123;&#10;    (__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor,&#10;    (__bridge id)kCTFontAttributeName: (__bridge id)fontRef&#10;  &#125;;&#10;&#10;  [string setAttributes:attribs range:NSMakeRange(0, [text length])];&#10;  attribs = @&#123;&#10;    (__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,&#10;    (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),&#10;    (__bridge id)kCTFontAttributeName: (__bridge id)fontRef&#10;  &#125;;&#10;  [string setAttributes:attribs range:NSMakeRange(6, 5)];&#10;&#10;  //release the CTFont we created earlier&#10;  CFRelease(fontRef);&#10;&#10;  //set layer text&#10;  textLayer.string = string;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/53df3d778dad5b5f.png"></p>
<p>图6.4 用CATextLayer实现一个富文本标签。</p>
<h3 id="行距和字距">行距和字距</h3><p>有必要提一下的是，由于绘制的实现机制不同（Core Text和WebKit），用<code>CATextLayer</code>渲染和用<code>UILabel</code>渲染出的文本行距和字距也不是不尽相同的。</p>
<p>二者的差异程度（由使用的字体和字符决定）总的来说挺小，但是如果你想正确的显示普通便签和<code>CATextLayer</code>就一定要记住这一点。</p>
<h3 id="UILabel的替代品"><code>UILabel</code>的替代品</h3><p>我们已经证实了<code>CATextLayer</code>比<code>UILabel</code>有着更好的性能表现，同时还有额外的布局选项并且在iOS 5上支持富文本。但是与一般的标签比较而言会更加繁琐一些。如果我们真的在需求一个<code>UILabel</code>的可用替代品，最好是能够在Interface Builder上创建我们的标签，而且尽可能地像一般的视图一样正常工作。</p>
<p>我们应该继承<code>UILabel</code>，然后添加一个子图层<code>CATextLayer</code>并重写显示文本的方法。但是仍然会有由<code>UILabel</code>的<code>-drawRect:</code>方法创建的空寄宿图。而且由于<code>CALayer</code>不支持自动缩放和自动布局，子视图并不是主动跟踪视图边界的大小，所以每次视图大小被更改，我们不得不手动更新子图层的边界。</p>
<p>我们真正想要的是一个用<code>CATextLayer</code>作为宿主图层的<code>UILabel</code>子类，这样就可以随着视图自动调整大小而且也没有冗余的寄宿图啦。</p>
<p>就像我们在第一章『图层树』讨论的一样，每一个<code>UIView</code>都是寄宿在一个<code>CALayer</code>的示例上。这个图层是由视图自动创建和管理的，那我们可以用别的图层类型替代它么？一旦被创建，我们就无法代替这个图层了。但是如果我们继承了<code>UIView</code>，那我们就可以重写<code>+layerClass</code>方法使得在创建的时候能返回一个不同的图层子类。<code>UIView</code>会在初始化的时候调用<code>+layerClass</code>方法，然后用它的返回类型来创建宿主图层。</p>
<p>清单6.4 演示了一个<code>UILabel</code>子类<code>LayerLabel</code>用<code>CATextLayer</code>绘制它的问题，而不是调用一般的<code>UILabel</code>使用的较慢的<code>-drawRect：</code>方法。<code>LayerLabel</code>示例既可以用代码实现，也可以在Interface Builder实现，只要把普通的标签拖入视图之中，然后设置它的类是LayerLabel就可以了。</p>
<p>清单6.4 使用<code>CATextLayer</code>的<code>UILabel</code>子类：<code>LayerLabel</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;LayerLabel.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;@implementation LayerLabel&#10;+ (Class)layerClass&#10;&#123;&#10;  //this makes our label create a CATextLayer //instead of a regular CALayer for its backing layer&#10;  return [CATextLayer class];&#10;&#125;&#10;&#10;- (CATextLayer *)textLayer&#10;&#123;&#10;  return (CATextLayer *)self.layer;&#10;&#125;&#10;&#10;- (void)setUp&#10;&#123;&#10;  //set defaults from UILabel settings&#10;  self.text = self.text;&#10;  self.textColor = self.textColor;&#10;  self.font = self.font;&#10;&#10;  //we should really derive these from the UILabel settings too&#10;  //but that&#39;s complicated, so for now we&#39;ll just hard-code them&#10;  [self textLayer].alignmentMode = kCAAlignmentJustified;&#10;  &#65532;&#10;  [self textLayer].wrapped = YES;&#10;  [self.layer display];&#10;&#125;&#10;&#10;- (id)initWithFrame:(CGRect)frame&#10;&#123;&#10;  //called when creating label programmatically&#10;  if (self = [super initWithFrame:frame]) &#123;&#10;    [self setUp];&#10;  &#125;&#10;  return self;&#10;&#125;&#10;&#10;- (void)awakeFromNib&#10;&#123;&#10;  //called when creating label using Interface Builder&#10;  [self setUp];&#10;&#125;&#10;&#10;- (void)setText:(NSString *)text&#10;&#123;&#10;  super.text = text;&#10;  //set layer text&#10;  [self textLayer].string = text;&#10;&#125;&#10;&#10;- (void)setTextColor:(UIColor *)textColor&#10;&#123;&#10;  super.textColor = textColor;&#10;  //set layer text color&#10;  [self textLayer].foregroundColor = textColor.CGColor;&#10;&#125;&#10;&#10;- (void)setFont:(UIFont *)font&#10;&#123;&#10;  super.font = font;&#10;  //set layer font&#10;  CFStringRef fontName = (__bridge CFStringRef)font.fontName;&#10;  CGFontRef fontRef = CGFontCreateWithFontName(fontName);&#10;  [self textLayer].font = fontRef;&#10;  [self textLayer].fontSize = font.pointSize;&#10;  &#65532;&#10;  CGFontRelease(fontRef);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>如果你运行代码，你会发现文本并没有像素化，而我们也没有设置<code>contentsScale</code>属性。把<code>CATextLayer</code>作为宿主图层的另一好处就是视图自动设置了<code>contentsScale</code>属性。</p>
<p>在这个简单的例子中，我们只是实现了<code>UILabel</code>的一部分风格和布局属性，不过稍微再改进一下我们就可以创建一个支持<code>UILabel</code>所有功能甚至更多功能的<code>LayerLabel</code>类（你可以在一些线上的开源项目中找到）。</p>
<p>如果你打算支持iOS 6及以上，基于<code>CATextLayer</code>的标签可能就有有些局限性。但是总得来说，如果想在app里面充分利用<code>CALayer</code>子类，用<code>+layerClass</code>来创建基于不同图层的视图是一个简单可复用的方法。</p>
<h3 id="CATransformLayer">CATransformLayer</h3><p>当我们在构造复杂的3D事物的时候，如果能够组织独立元素就太方便了。比如说，你想创造一个孩子的手臂：你就需要确定哪一部分是孩子的手腕，哪一部分是孩子的前臂，哪一部分是孩子的肘，哪一部分是孩子的上臂，哪一部分是孩子的肩膀等等。</p>
<p>当然是允许独立地移动每个区域的啦。以肘为指点会移动前臂和手，而不是肩膀。Core Animation图层很容易就可以让你在2D环境下做出这样的层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的孩子都平面化到一个场景中（第五章『变换』有提到）。</p>
<p><code>CATransformLayer</code>解决了这个问题，<code>CATransformLayer</code>不同于普通的<code>CALayer</code>，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。<code>CATransformLayer</code>并不平面化它的子图层，所以它能够用于构造一个层级的3D结构，比如我的手臂示例。</p>
<p>用代码创建一个手臂需要相当多的代码，所以我就演示得更简单一些吧：在第五章的立方体示例，我们将通过旋转<code>camara</code>来解决图层平面化问题而不是像立方体示例代码中用的<code>sublayerTransform</code>。这是一个非常不错的技巧，但是只能作用域单个对象上，如果你的场景包含两个立方体，那我们就不能用这个技巧单独旋转他们了。</p>
<p>那么，就让我们来试一试<code>CATransformLayer</code>吧，第一个问题就来了：在第五章，我们是用多个视图来构造了我们的立方体，而不是单独的图层。我们不能在不打乱已有的视图层次的前提下在一个本身不是有寄宿图的图层中放置一个寄宿图图层。我们可以创建一个新的<code>UIView</code>子类寄宿在<code>CATransformLayer</code>（用<code>+layerClass</code>方法）之上。但是，为了简化案例，我们仅仅重建了一个单独的图层，而不是使用视图。这意味着我们不能像第五章一样在立方体表面显示按钮和标签，不过我们现在也用不到这个特性。</p>
<p>清单6.5就是代码。我们以我们在第五章使用过的相同基本逻辑放置立方体。但是并不像以前那样直接将立方面添加到容器视图的宿主图层，我们将他们放置到一个<code>CATransformLayer</code>中创建一个独立的立方体对象，然后将两个这样的立方体放进容器中。我们随机地给立方面染色以将他们区分开来，这样就不用靠标签或是光亮来区分他们。图6.5是运行结果。</p>
<p>清单6.5 用<code>CATransformLayer</code>装配一个3D图层体系</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (CALayer *)faceWithTransform:(CATransform3D)transform&#10;&#123;&#10;  //create cube face layer&#10;  CALayer *face = [CALayer layer];&#10;  face.frame = CGRectMake(-50, -50, 100, 100);&#10;&#10;  //apply a random color&#10;  CGFloat red = (rand() / (double)INT_MAX);&#10;  CGFloat green = (rand() / (double)INT_MAX);&#10;  CGFloat blue = (rand() / (double)INT_MAX);&#10;  face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;&#10;&#10;  &#65532;//apply the transform and return&#10;  face.transform = transform;&#10;  return face;&#10;&#125;&#10;&#10;- (CALayer *)cubeWithTransform:(CATransform3D)transform&#10;&#123;&#10;  //create cube layer&#10;  CATransformLayer *cube = [CATransformLayer layer];&#10;&#10;  //add cube face 1&#10;  CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);&#10;  [cube addSublayer:[self faceWithTransform:ct]];&#10;&#10;  //add cube face 2&#10;  ct = CATransform3DMakeTranslation(50, 0, 0);&#10;  ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);&#10;  [cube addSublayer:[self faceWithTransform:ct]];&#10;&#10;  //add cube face 3&#10;  ct = CATransform3DMakeTranslation(0, -50, 0);&#10;  ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);&#10;  [cube addSublayer:[self faceWithTransform:ct]];&#10;&#10;  //add cube face 4&#10;  ct = CATransform3DMakeTranslation(0, 50, 0);&#10;  ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);&#10;  [cube addSublayer:[self faceWithTransform:ct]];&#10;&#10;  //add cube face 5&#10;  ct = CATransform3DMakeTranslation(-50, 0, 0);&#10;  ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);&#10;  [cube addSublayer:[self faceWithTransform:ct]];&#10;&#10;  //add cube face 6&#10;  ct = CATransform3DMakeTranslation(0, 0, -50);&#10;  ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);&#10;  [cube addSublayer:[self faceWithTransform:ct]];&#10;&#10;  //center the cube layer within the container&#10;  CGSize containerSize = self.containerView.bounds.size;&#10;  cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);&#10;&#10;  //apply the transform and return&#10;  cube.transform = transform;&#10;  return cube;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#65532;&#10;  [super viewDidLoad];&#10;&#10;  //set up the perspective transform&#10;  CATransform3D pt = CATransform3DIdentity;&#10;  pt.m34 = -1.0 / 500.0;&#10;  self.containerView.layer.sublayerTransform = pt;&#10;&#10;  //set up the transform for cube 1 and add it&#10;  CATransform3D c1t = CATransform3DIdentity;&#10;  c1t = CATransform3DTranslate(c1t, -100, 0, 0);&#10;  CALayer *cube1 = [self cubeWithTransform:c1t];&#10;  [self.containerView.layer addSublayer:cube1];&#10;&#10;  //set up the transform for cube 2 and add it&#10;  CATransform3D c2t = CATransform3DIdentity;&#10;  c2t = CATransform3DTranslate(c2t, 100, 0, 0);&#10;  c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0);&#10;  c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0);&#10;  CALayer *cube2 = [self cubeWithTransform:c2t];&#10;  [self.containerView.layer addSublayer:cube2];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/8703bb7ac0577e6e.png"></p>
<p>图6.5 同一视角下的俩不同变换的立方体</p>
<h2 id="CAGradientLayer">CAGradientLayer</h2><p><code>CAGradientLayer</code>是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个<code>CAGradientLayer</code>并将内容绘制到一个普通图层的寄宿图也是有可能的，但是<code>CAGradientLayer</code>的真正好处在于绘制使用了硬件加速。</p>
<h3 id="基础渐变">基础渐变</h3><p>我们将从一个简单的红变蓝的对角线渐变开始（见清单6.6）.这些渐变色彩放在一个数组中，并赋给<code>colors</code>属性。这个数组成员接受<code>CGColorRef</code>类型的值（并不是从<code>NSObject</code>派生而来），所以我们要用通过bridge转换以确保编译正常。</p>
<p><code>CAGradientLayer</code>也有<code>startPoint</code>和<code>endPoint</code>属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。代码运行结果如图6.6</p>
<p>清单6.6 简单的两种颜色的对角线渐变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;  //create gradient layer and add it to our container view&#10;  CAGradientLayer *gradientLayer = [CAGradientLayer layer];&#10;  gradientLayer.frame = self.containerView.bounds;&#10;  [self.containerView.layer addSublayer:gradientLayer];&#10;&#10;  //set gradient colors&#10;  gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];&#10;&#10;  //set gradient start and end points&#10;  gradientLayer.startPoint = CGPointMake(0, 0);&#10;  gradientLayer.endPoint = CGPointMake(1, 1);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/fa8d98e6fe4ec176.png"></p>
<p>图6.6 用<code>CAGradientLayer</code>实现简单的两种颜色的对角线渐变</p>
<h3 id="多重渐变">多重渐变</h3><p>如果你愿意，<code>colors</code>属性可以包含很多颜色，所以创建一个彩虹一样的多重渐变也是很简单的。默认情况下，这些颜色在空间上均匀地被渲染，但是我们可以用<code>locations</code>属性来调整空间。<code>locations</code>属性是一个浮点数值的数组（以<code>NSNumber</code>包装）。这些浮点数定义了<code>colors</code>属性中每个不同颜色的位置，同样的，也是以单位坐标系进行标定。0.0代表着渐变的开始，1.0代表着结束。</p>
<p><code>locations</code>数组并不是强制要求的，但是如果你给它赋值了就一定要确保<code>locations</code>的数组大小和<code>colors</code>数组大小一定要相同，否则你将会得到一个空白的渐变。</p>
<p>清单6.7展示了一个基于清单6.6的对角线渐变的代码改造。现在变成了从红到黄最后到绿色的渐变。<code>locations</code>数组指定了0.0，0.25和0.5三个数值，这样这三个渐变就有点像挤在了左上角。（如图6.7）.</p>
<p>清单6.7 在渐变上使用<code>locations</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;&#10;&#9;[super viewDidLoad];&#10;&#10;&#9;//create gradient layer and add it to our container view&#10;&#9;CAGradientLayer *gradientLayer = [CAGradientLayer layer];&#10;&#9;gradientLayer.frame = self.containerView.bounds;&#10;&#9;[self.containerView.layer addSublayer:gradientLayer];&#10;&#10;&#9;//set gradient colors&#10;&#9;gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];&#10;&#10;&#9;//set locations&#10;&#9;gradientLayer.locations = @[@0.0, @0.25, @0.5];&#10;&#10;&#9;//set gradient start and end points&#10;&#9;gradientLayer.startPoint = CGPointMake(0, 0);&#10;&#9;gradientLayer.endPoint = CGPointMake(1, 1);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/907e567fadbcbdff.png"></p>
<p>图6.7 用<code>locations</code>构造偏移至左上角的三色渐变</p>
<h2 id="CAReplicatorLayer">CAReplicatorLayer</h2><p><code>CAReplicatorLayer</code>的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。看上去演示能够更加解释这些，我们来写个例子吧。</p>
<h3 id="重复图层（Repeating_Layers）">重复图层（Repeating Layers）</h3><p>清单6.8中，我们在屏幕的中间创建了一个小白色方块图层，然后用<code>CAReplicatorLayer</code>生成十个图层组成一个圆圈。<code>instanceCount</code>属性指定了图层需要重复多少次。<code>instanceTransform</code>指定了一个<code>CATransform3D</code>3D变换（这种情况下，下一图层的位移和旋转将会移动到圆圈的下一个点）。</p>
<p>变换是逐步增加的，每个实例都是相对于前一实例布局。这就是为什么这些复制体最终不会出现在同意位置上，图6.8是代码运行结果。</p>
<p>清单6.8 用<code>CAReplicatorLayer</code>重复图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create a replicator layer and add it to our view&#10;    CAReplicatorLayer *replicator = [CAReplicatorLayer layer];&#10;    replicator.frame = self.containerView.bounds;&#10;    [self.containerView.layer addSublayer:replicator];&#10;&#10;    //configure the replicator&#10;    replicator.instanceCount = 10;&#10;&#10;    //apply a transform for each instance&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    transform = CATransform3DTranslate(transform, 0, 200, 0);&#10;    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);&#10;    transform = CATransform3DTranslate(transform, 0, -200, 0);&#10;    replicator.instanceTransform = transform;&#10;&#10;    //apply a color shift for each instance&#10;    replicator.instanceBlueOffset = -0.1;&#10;    replicator.instanceGreenOffset = -0.1;&#10;&#10;    //create a sublayer and place it inside the replicator&#10;    CALayer *layer = [CALayer layer];&#10;    layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);&#10;    layer.backgroundColor = [UIColor whiteColor].CGColor;&#10;    [replicator addSublayer:layer];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/62203e36ef12a3ab.png"></p>
<p>图6.8 用<code>CAReplicatorLayer</code>创建一圈图层</p>
<p>注意到当图层在重复的时候，他们的颜色也在变化：这是用<code>instanceBlueOffset</code>和<code>instanceGreenOffset</code>属性实现的。通过逐步减少蓝色和绿色通道，我们逐渐将图层颜色转换成了红色。这个复制效果看起来很酷，但是<code>CAReplicatorLayer</code>真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了<code>CAEmitterLayer</code>，它更适合创建任意的粒子效果）。除此之外，还有一个实际应用是：反射。</p>
<h3 id="反射">反射</h3><p>使用<code>CAReplicatorLayer</code>并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果。让我们来尝试实现这个创意：指定一个继承于<code>UIView</code>的<code>ReflectionView</code>，它会自动产生内容的反射效果。实现这个效果的代码很简单（见清单6.9），实际上用<code>ReflectionView</code>实现这个效果会更简单，我们只需要把<code>ReflectionView</code>的实例放置于Interface Builder（见图6.9），它就会实时生成子视图的反射，而不需要别的代码（见图6.10）.</p>
<p>清单6.9 用<code>CAReplicatorLayer</code>自动绘制反射</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ReflectionView.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;@implementation ReflectionView&#10;&#10;+ (Class)layerClass&#10;&#123;&#10;    return [CAReplicatorLayer class];&#10;&#125;&#10;&#10;- (void)setUp&#10;&#123;&#10;    //configure replicator&#10;    CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;&#10;    layer.instanceCount = 2;&#10;&#10;    //move reflection instance below original and flip vertically&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    CGFloat verticalOffset = self.bounds.size.height + 2;&#10;    transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);&#10;    transform = CATransform3DScale(transform, 1, -1, 0);&#10;    layer.instanceTransform = transform;&#10;&#10;    //reduce alpha of reflection layer&#10;    layer.instanceAlphaOffset = -0.6;&#10;&#125;&#10;&#65532;&#10;- (id)initWithFrame:(CGRect)frame&#10;&#123;&#10;    //this is called when view is created in code&#10;    if ((self = [super initWithFrame:frame])) &#123;&#10;        [self setUp];&#10;    &#125;&#10;    return self;&#10;&#125;&#10;&#10;- (void)awakeFromNib&#10;&#123;&#10;    //this is called when view is created from a nib&#10;    [self setUp];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/92bf63d0527089d5.png"></p>
<p>图6.9 在Interface Builder中使用<code>ReflectionView</code></p>
<p><img src="http://i1.tietuku.com/de61cf27aa1ee3e8.png"></p>
<p>图6.10 <code>ReflectionView</code>自动实时产生反射效果。</p>
<p>开源代码<code>ReflectionView</code>完成了一个自适应的渐变淡出效果（用<code>CAGradientLayer</code>和图层蒙板实现），代码见 <a href="https://github.com/nicklockwood/ReflectionView" target="_blank" rel="external">https://github.com/nicklockwood/ReflectionView</a></p>
<h2 id="CAScrollLayer">CAScrollLayer</h2><p>对于一个未转换的图层，它的<code>bounds</code>和它的<code>frame</code>是一样的，<code>frame</code>属性是由<code>bounds</code>属性自动计算而出的，所以更改任意一个值都会更新其他值。</p>
<p>但是如果你只想显示一个大图层里面的一小部分呢。比如说，你可能有一个很大的图片，你希望用户能够随意滑动，或者是一个数据或文本的长列表。在一个典型的iOS应用中，你可能会用到<code>UITableView</code>或是<code>UIScrollView</code>，但是对于独立的图层来说，什么会等价于刚刚提到的<code>UITableView</code>和<code>UIScrollView</code>呢？</p>
<p>在第二章中，我们探索了图层的<code>contentsRect</code>属性的用法，它的确是能够解决在图层中小地方显示大图片的解决方法。但是如果你的图层包含子图层那它就不是一个非常好的解决方案，因为，这样做的话每次你想『滑动』可视区域的时候，你就需要手工重新计算并更新所有的子图层位置。</p>
<p>这个时候就需要<code>CAScrollLayer</code>了。<code>CAScrollLayer</code>有一个<code>-scrollToPoint:</code>方法，它自动适应<code>bounds</code>的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。前面提到过，Core Animation并不处理用户输入，所以<code>CAScrollLayer</code>并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>
<p>让我们来用<code>CAScrollLayer</code>来常见一个基本的<code>UIScrollView</code>替代品。我们将会用<code>CAScrollLayer</code>作为视图的宿主图层，并创建一个自定义的<code>UIView</code>，然后用<code>UIPanGestureRecognizer</code>实现触摸事件响应。这段代码见清单6.10. 图6.11是运行效果：<code>ScrollView</code>显示了一个大于它的<code>frame</code>的<code>UIImageView</code>。</p>
<p>清单6.10 用<code>CAScrollLayer</code>实现滑动视图</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ScrollView.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62; @implementation ScrollView&#10;+ (Class)layerClass&#10;&#123;&#10;    return [CAScrollLayer class];&#10;&#125;&#10;&#10;- (void)setUp&#10;&#123;&#10;    //enable clipping&#10;    self.layer.masksToBounds = YES;&#10;&#10;    //attach pan gesture recognizer&#10;    UIPanGestureRecognizer *recognizer = nil;&#10;    recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];&#10;    [self addGestureRecognizer:recognizer];&#10;&#125;&#10;&#10;- (id)initWithFrame:(CGRect)frame&#10;&#123;&#10;    //this is called when view is created in code&#10;    if ((self = [super initWithFrame:frame])) &#123;&#10;        [self setUp];&#10;    &#125;&#10;    return self;&#10;&#125;&#10;&#10;- (void)awakeFromNib &#123;&#10;    //this is called when view is created from a nib&#10;    [self setUp];&#10;&#125;&#10;&#10;- (void)pan:(UIPanGestureRecognizer *)recognizer&#10;&#123;&#10;    //get the offset by subtracting the pan gesture&#10;    //translation from the current bounds origin&#10;    CGPoint offset = self.bounds.origin;&#10;    offset.x -= [recognizer translationInView:self].x;&#10;    offset.y -= [recognizer translationInView:self].y;&#10;&#10;    //scroll the layer&#10;    [(CAScrollLayer *)self.layer scrollToPoint:offset];&#10;&#10;    //reset the pan gesture translation&#10;    [recognizer setTranslation:CGPointZero inView:self];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/c15a280edf622629.png"><br>图6.11 用<code>UIScrollView</code>创建一个凑合的滑动视图</p>
<p>不同于<code>UIScrollView</code>，我们定制的滑动视图类并没有实现任何形式的边界检查（bounds checking）。图层内容极有可能滑出视图的边界并无限滑下去。<code>CAScrollLayer</code>并没有等同于<code>UIScrollView</code>中<code>contentSize</code>的属性，所以当<code>CAScrollLayer</code>滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。</p>
<p>那你一定会奇怪用<code>CAScrollLayer</code>的意义到底何在，因为你可以简单地用一个普通的<code>CALayer</code>然后手动适应边界原点啊。真相其实并不复杂，<code>UIScrollView</code>并没有用<code>CAScrollLayer</code>，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>
<p><code>CAScrollLayer</code>有一个潜在的有用特性。如果你查看<code>CAScrollLayer</code>的头文件，你就会注意到有一个扩展分类实现了一些方法和属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollPoint:(CGPoint)p;&#10;- (void)scrollRectToVisible:(CGRect)r;&#10;@property(readonly) CGRect visibleRect;</span><br></pre></td></tr></table></figure>
<p>看到这些方法和属性名，你也许会以为这些方法给每个<code>CALayer</code>实例增加了滑动功能。但是事实上他们只是放置在<code>CAScrollLayer</code>中的图层的实用方法。<code>scrollPoint:</code>方法从图层树中查找并找到第一个可用的<code>CAScrollLayer</code>，然后滑动它使得指定点成为可视的。<code>scrollRectToVisible:</code>方法实现了同样的事情只不过是作用在一个矩形上的。<code>visibleRect</code>属性决定图层（如果存在的话）的哪部分是当前的可视区域。如果你自己实现这些方法就会相对容易明白一点，但是<code>CAScrollLayer</code>帮你省了这些麻烦，所以当涉及到实现图层滑动的时候就可以用上了。</p>
<h2 id="CATiledLayer">CATiledLayer</h2><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用<code>UIImage</code>的<code>-imageNamed:</code>方法或者<code>-imageWithContentsOfFile:</code>方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>
<p>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048*2048，或4096*4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。</p>
<p><code>CATiledLayer</code>为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。</p>
<h3 id="小片裁剪">小片裁剪</h3><p>这个示例中，我们将会从一个2048*2048分辨率的雪人图片入手。为了能够从<code>CATiledLayer</code>中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那<code>CATiledLayer</code>这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。</p>
<p>清单6.11 演示了一个简单的Mac OS命令行程序，它用<code>CATiledLayer</code>将一个图片裁剪成小图并存储到不同的文件中。</p>
<p>清单6.11 裁剪图片成小图的终端程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;AppKit/AppKit.h&#62;&#10;&#10;int main(int argc, const char * argv[])&#10;&#123;&#10;    @autoreleasepool&#123;&#10;        &#65532;//handle incorrect arguments&#10;        if (argc &#60; 2) &#123;&#10;            NSLog(@&#34;TileCutter arguments: inputfile&#34;);&#10;            return 0;&#10;        &#125;&#10;&#10;        //input file&#10;        NSString *inputFile = [NSString stringWithCString:argv[1] encoding:NSUTF8StringEncoding];&#10;&#10;        //tile size&#10;        CGFloat tileSize = 256; //output path&#10;        NSString *outputPath = [inputFile stringByDeletingPathExtension];&#10;&#10;        //load image&#10;        NSImage *image = [[NSImage alloc] initWithContentsOfFile:inputFile];&#10;        NSSize size = [image size];&#10;        NSArray *representations = [image representations];&#10;        if ([representations count])&#123;&#10;            NSBitmapImageRep *representation = representations[0];&#10;            size.width = [representation pixelsWide];&#10;            size.height = [representation pixelsHigh];&#10;        &#125;&#10;        NSRect rect = NSMakeRect(0.0, 0.0, size.width, size.height);&#10;        CGImageRef imageRef = [image CGImageForProposedRect:&#38;rect context:NULL hints:nil];&#10;&#10;        //calculate rows and columns&#10;        NSInteger rows = ceil(size.height / tileSize);&#10;        NSInteger cols = ceil(size.width / tileSize);&#10;&#10;        //generate tiles&#10;        for (int y = 0; y &#60; rows; ++y) &#123;&#10;            for (int x = 0; x &#60; cols; ++x) &#123;&#10;            //extract tile image&#10;            CGRect tileRect = CGRectMake(x*tileSize, y*tileSize, tileSize, tileSize);&#10;            CGImageRef tileImage = CGImageCreateWithImageInRect(imageRef, tileRect);&#10;&#10;            //convert to jpeg data&#10;            NSBitmapImageRep *imageRep = [[NSBitmapImageRep alloc] initWithCGImage:tileImage];&#10;            NSData *data = [imageRep representationUsingType: NSJPEGFileType properties:nil];&#10;            CGImageRelease(tileImage);&#10;&#10;            //save file&#10;            NSString *path = [outputPath stringByAppendingFormat: @&#34;_%02i_%02i.jpg&#34;, x, y];&#10;            [data writeToFile:path atomically:NO];&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序将2048*2048分辨率的雪人图案裁剪成了64个不同的256*256的小图。（256*256是<code>CATiledLayer</code>的默认小图大小，默认大小可以通过<code>tileSize</code>属性更改）。程序接受一个图片路径作为命令行的第一个参数。我们可以在编译的scheme将路径参数硬编码然后就可以在Xcode中运行了，但是以后作用在另一个图片上就不方便了。所以，我们编译了这个程序并把它保存到敏感的地方，然后从终端调用，如下面所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62; path/to/TileCutterApp path/to/Snowman.jpg</span><br></pre></td></tr></table></figure>
<p>The app is very basic, but could easily be extended to support additional arguments such as tile size, or to export images in formats other than JPEG. The result of running it is a sequence of 64 new images, named as follows:</p>
<p>这个程序相当基础，但是能够轻易地扩展支持额外的参数比如小图大小，或者导出格式等等。运行结果是64个新图的序列，如下面命名：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Snowman_00_00<span class="class">.jpg</span></span><br><span class="line">Snowman_00_01<span class="class">.jpg</span></span><br><span class="line">Snowman_00_02<span class="class">.jpg</span></span><br><span class="line">...</span><br><span class="line">Snowman_07_07.jpg</span><br></pre></td></tr></table></figure>
<p>既然我们有了裁切后的小图，我们就要让iOS程序用到他们。<code>CATiledLayer</code>很好地和<code>UIScrollView</code>集成在一起。除了设置图层和滑动视图边界以适配整个图片大小，我们真正要做的就是实现<code>-drawLayer:inContext:</code>方法，当需要载入新的小图时，<code>CATiledLayer</code>就会调用到这个方法。</p>
<p>清单6.12演示了代码。图6.12是代码运行结果。</p>
<p>清单6.12 一个简单的滚动<code>CATiledLayer</code>实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIScrollView *scrollView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //add the tiled layer&#10;    CATiledLayer *tileLayer = [CATiledLayer layer];&#65532;&#10;    tileLayer.frame = CGRectMake(0, 0, 2048, 2048);&#10;    tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer];&#10;&#10;    //configure the scroll view&#10;    self.scrollView.contentSize = tileLayer.frame.size;&#10;&#10;    //draw layer&#10;    [tileLayer setNeedsDisplay];&#10;&#125;&#10;&#10;- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx&#10;&#123;&#10;    //determine tile coordinate&#10;    CGRect bounds = CGContextGetClipBoundingBox(ctx);&#10;    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);&#10;    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);&#10;&#10;    //load tile image&#10;    NSString *imageName = [NSString stringWithFormat: @&#34;Snowman_%02i_%02i&#34;, x, y];&#10;    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@&#34;jpg&#34;];&#10;    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];&#10;&#10;    //draw tile&#10;    UIGraphicsPushContext(ctx);&#10;    [tileImage drawInRect:bounds];&#10;    UIGraphicsPopContext();&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/355ae23084f66f77.png"></p>
<p>图6.12 用<code>UIScrollView</code>滚动<code>CATiledLayer</code></p>
<p>当你滑动这个图片，你会发现当<code>CATiledLayer</code>载入小图的时候，他们会淡入到界面中。这是<code>CATiledLayer</code>的默认行为。（你可能已经在iOS 6之前的苹果地图程序中见过这个效果）你可以用<code>fadeDuration</code>属性改变淡入时长或直接禁用掉。<code>CATiledLayer</code>（不同于大部分的<code>UIKit</code>和Core Animation方法）支持多线程绘制，<code>-drawLayer:inContext:</code>方法可以在多个线程中同时地并发调用，所以请小心谨慎地确保你在这个方法中实现的绘制代码是线程安全的。</p>
<h3 id="Retina小图">Retina小图</h3><p>你也许已经注意到了这些小图并不是以Retina的分辨率显示的。为了以屏幕的原生分辨率来渲染<code>CATiledLayer</code>，我们需要设置图层的<code>contentsScale</code>来匹配<code>UIScreen</code>的<code>scale</code>属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tileLayer.contentsScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>
<p>有趣的是，<code>tileSize</code>是以像素为单位，而不是点，所以增大了<code>contentsScale</code>就自动有了默认的小图尺寸（现在它是128*128的点而不是256*256）.所以，我们不需要手工更新小图的尺寸或是在Retina分辨率下指定一个不同的小图。我们需要做的是适应小图渲染代码以对应安排<code>scale</code>的变化，然而：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//determine tile coordinate&#10;CGRect bounds = CGContextGetClipBoundingBox(ctx);&#10;CGFloat scale = [UIScreen mainScreen].scale;&#10;NSInteger x = floor(bounds.origin.x / layer.tileSize.width * scale);&#10;NSInteger y = floor(bounds.origin.y / layer.tileSize.height * scale);</span><br></pre></td></tr></table></figure>
<p>通过这个方法纠正<code>scale</code>也意味着我们的雪人图将以一半的大小渲染在Retina设备上（总尺寸是1024*1024，而不是2048*2048）。这个通常都不会影响到用<code>CATiledLayer</code>正常显示的图片类型（比如照片和地图，他们在设计上就是要支持放大缩小，能够在不同的缩放条件下显示），但是也需要在心里明白。</p>
<h2 id="CAEmitterLayer">CAEmitterLayer</h2><p>在iOS 5中，苹果引入了一个新的<code>CALayer</code>子类叫做<code>CAEmitterLayer</code>。<code>CAEmitterLayer</code>是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<p><code>CAEmitterLayer</code>看上去像是许多<code>CAEmitterCell</code>的容器，这些<code>CAEmitierCell</code>定义了一个例子效果。你将会为不同的例子效果定义一个或多个<code>CAEmitterCell</code>作为模版，同时<code>CAEmitterLayer</code>负责基于这些模版实例化一个粒子流。一个<code>CAEmitterCell</code>类似于一个<code>CALayer</code>：它有一个<code>contents</code>属性可以定义为一个<code>CGImage</code>，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在<code>CAEmitterCell</code>类的头文件中找到。</p>
<p>我们来举个例子。我们将利用在一圆中发射不同速度和透明度的粒子创建一个火爆炸的效果。清单6.13包含了生成爆炸的代码。图6.13是运行结果</p>
<p>清单6.13 用<code>CAEmitterLayer</code>创建爆炸效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;&#10;@end&#10;&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    &#65532;&#10;    //create particle emitter layer&#10;    CAEmitterLayer *emitter = [CAEmitterLayer layer];&#10;    emitter.frame = self.containerView.bounds;&#10;    [self.containerView.layer addSublayer:emitter];&#10;&#10;    //configure emitter&#10;    emitter.renderMode = kCAEmitterLayerAdditive;&#10;    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);&#10;&#10;    //create a particle template&#10;    CAEmitterCell *cell = [[CAEmitterCell alloc] init];&#10;    cell.contents = (__bridge id)[UIImage imageNamed:@&#34;Spark.png&#34;].CGImage;&#10;    cell.birthRate = 150;&#10;    cell.lifetime = 5.0;&#10;    cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;&#10;    cell.alphaSpeed = -0.4;&#10;    cell.velocity = 50;&#10;    cell.velocityRange = 50;&#10;    cell.emissionRange = M_PI * 2.0;&#10;&#10;    //add particle template to emitter&#10;    emitter.emitterCells = @[cell];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/bb2edec984c774ed.png"><br>图6.13 火焰爆炸效果</p>
<p><code>CAEMitterCell</code>的属性基本上可以分为三种：</p>
<ul>
<li>这种粒子的某一属性的初始值。比如，<code>color</code>属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</li>
<li>例子某一属性的变化范围。比如<code>emissionRange</code>属性的值是2π，这意味着例子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</li>
<li>指定值在时间线上的变化。比如，在示例中，我们将<code>alphaSpeed</code>设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐小时的效果。</li>
</ul>
<p><code>CAEmitterLayer</code>的属性它自己控制着整个例子系统的位置和形状。一些属性比如<code>birthRate</code>，<code>lifetime</code>和<code>celocity</code>，这些属性在<code>CAEmitterCell</code>中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。其他值得提到的属性有以下这些：</p>
<ul>
<li><code>preservesDepth</code>，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层</li>
<li><code>renderMode</code>，控制着在视觉上粒子图片是如何混合的。你可能已经注意到了示例中我们把它设置为<code>kCAEmitterLayerAdditive</code>，它实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果我们把它设置为默认的<code>kCAEmitterLayerUnordered</code>，效果就没那么好看了（见图6.14）.</li>
</ul>
<p><img src="http://i1.tietuku.com/8e9d15b78b5df4cb.png"></p>
<p>图6.14 禁止混色之后的火焰粒子</p>
<h2 id="CAEAGLLayer">CAEAGLLayer</h2><p>当iOS要处理高性能图形绘制，必要时就是OpenGL。应该说它应该是最后的杀手锏，至少对于非游戏的应用来说是的。因为相比Core Animation和UIkit框架，它不可思议地复杂。</p>
<p>OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。用起来非常复杂和强大，但是用OpenGL绘制iOS用户界面就需要很多很多的工作了。</p>
<p>为了能够以高性能使用Core Animation，你需要判断你需要绘制哪种内容（矢量图形，例子，文本，等等），但后选择合适的图层去呈现这些内容，Core Animation中只有一些类型的内容是被高度优化的；所以如果你想绘制的东西并不能找到标准的图层类，想要得到高性能就比较费事情了。</p>
<p>因为OpenGL根本不会对你的内容进行假设，它能够绘制得相当快。利用OpenGL，你可以绘制任何你知道必要的集合信息和形状逻辑的内容。所以很多游戏都喜欢用OpenGL（这些情况下，Core Animation的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。</p>
<p>在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做<code>CLKView</code>的<code>UIView</code>的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用<code>CAEAGLLayer</code>完成，它是<code>CALayer</code>的一个子类，用来显示任意的OpenGL图形。</p>
<p>大部分情况下你都不需要手动设置<code>CAEAGLLayer</code>（假设用GLKView），过去的日子就不要再提了。特别的，我们将设置一个OpenGL ES 2.0的上下文，它是现代的iOS设备的标准做法。</p>
<p>尽管不需要GLKit也可以做到这一切，但是GLKit囊括了很多额外的工作，比如设置顶点和片段着色器，这些都以类C语言叫做GLSL自包含在程序中，同时在运行时载入到图形硬件中。编写GLSL代码和设置<code>EAGLayer</code>没有什么关系，所以我们将用<code>GLKBaseEffect</code>类将着色逻辑抽象出来。其他的事情，我们还是会有以往的方式。</p>
<p>在开始之前，你需要将GLKit和OpenGLES框架加入到你的项目中，然后就可以实现清单6.14中的代码，里面是设置一个<code>GAEAGLLayer</code>的最少工作，它使用了OpenGL ES 2.0 的绘图上下文，并渲染了一个有色三角（见图6.15）.</p>
<p>清单6.14 用<code>CAEAGLLayer</code>绘制一个三角形</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;#import &#60;GLKit/GLKit.h&#62;&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *glView;&#10;@property (nonatomic, strong) EAGLContext *glContext;&#10;@property (nonatomic, strong) CAEAGLLayer *glLayer;&#10;@property (nonatomic, assign) GLuint framebuffer;&#10;@property (nonatomic, assign) GLuint colorRenderbuffer;&#10;@property (nonatomic, assign) GLint framebufferWidth;&#10;@property (nonatomic, assign) GLint framebufferHeight;&#10;@property (nonatomic, strong) GLKBaseEffect *effect;&#10;&#65532;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)setUpBuffers&#10;&#123;&#10;    //set up frame buffer&#10;    glGenFramebuffers(1, &#38;_framebuffer);&#10;    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);&#10;&#10;    //set up color render buffer&#10;    glGenRenderbuffers(1, &#38;_colorRenderbuffer);&#10;    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);&#10;    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderbuffer);&#10;    [self.glContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.glLayer];&#10;    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &#38;_framebufferWidth);&#10;    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &#38;_framebufferHeight);&#10;&#10;    //check success&#10;    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;&#10;        NSLog(@&#34;Failed to make complete framebuffer object: %i&#34;, glCheckFramebufferStatus(GL_FRAMEBUFFER));&#10;    &#125;&#10;&#125;&#10;&#10;- (void)tearDownBuffers&#10;&#123;&#10;    if (_framebuffer) &#123;&#10;        //delete framebuffer&#10;        glDeleteFramebuffers(1, &#38;_framebuffer);&#10;        _framebuffer = 0;&#10;    &#125;&#10;&#10;    if (_colorRenderbuffer) &#123;&#10;        //delete color render buffer&#10;        glDeleteRenderbuffers(1, &#38;_colorRenderbuffer);&#10;        _colorRenderbuffer = 0;&#10;    &#125;&#10;&#125;&#10;&#10;- (void)drawFrame &#123;&#10;    //bind framebuffer &#38; set viewport&#10;    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);&#10;    glViewport(0, 0, _framebufferWidth, _framebufferHeight);&#10;&#10;    //bind shader program&#10;    [self.effect prepareToDraw];&#10;&#10;    //clear the screen&#10;    glClear(GL_COLOR_BUFFER_BIT); glClearColor(0.0, 0.0, 0.0, 1.0);&#10;&#10;    //set up vertices&#10;    GLfloat vertices[] = &#123;&#10;        -0.5f, -0.5f, -1.0f, 0.0f, 0.5f, -1.0f, 0.5f, -0.5f, -1.0f,&#10;    &#125;;&#10;&#10;    //set up colors&#10;    GLfloat colors[] = &#123;&#10;        0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,&#10;    &#125;;&#10;&#10;    //draw triangle&#10;    glEnableVertexAttribArray(GLKVertexAttribPosition);&#10;    glEnableVertexAttribArray(GLKVertexAttribColor);&#10;    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vertices);&#10;    glVertexAttribPointer(GLKVertexAttribColor,4, GL_FLOAT, GL_FALSE, 0, colors);&#10;    glDrawArrays(GL_TRIANGLES, 0, 3);&#10;&#10;    //present render buffer&#10;    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);&#10;    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //set up context&#10;    self.glContext = [[EAGLContext alloc] initWithAPI: kEAGLRenderingAPIOpenGLES2];&#10;    [EAGLContext setCurrentContext:self.glContext];&#10;&#10;    //set up layer&#10;    self.glLayer = [CAEAGLLayer layer];&#10;    self.glLayer.frame = self.glView.bounds;&#10;    [self.glView.layer addSublayer:self.glLayer];&#10;    self.glLayer.drawableProperties = @&#123;kEAGLDrawablePropertyRetainedBacking:@NO, kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8&#125;;&#10;&#10;    //set up base effect&#10;    self.effect = [[GLKBaseEffect alloc] init];&#10;&#10;    //set up buffers&#10;    [self setUpBuffers];&#10;&#10;    //draw frame&#10;    [self drawFrame];&#10;&#125;&#10;&#10;- (void)viewDidUnload&#10;&#123;&#10;    [self tearDownBuffers];&#10;    [super viewDidUnload];&#10;&#125;&#10;&#10;- (void)dealloc&#10;&#123;&#10;    [self tearDownBuffers];&#10;    [EAGLContext setCurrentContext:nil];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/264b2ca4bb1b89ad.png"></p>
<p>图6.15 用OpenGL渲染的<code>CAEAGLLayer</code>图层</p>
<p>在一个真正的OpenGL应用中，我们可能会用<code>NSTimer</code>或<code>CADisplayLink</code>周期性地每秒钟调用<code>-drawRrame</code>方法60次，同时会将几何图形生成和绘制分开以便不会每次都重新生成三角形的顶点（这样也可以让我们绘制其他的一些东西而不是一个三角形而已），不过上面这个例子已经足够演示了绘图原则了。</p>
<h2 id="AVPlayerLayer">AVPlayerLayer</h2><p>最后一个图层类型是<code>AVPlayerLayer</code>。尽管它不是Core Animation框架的一部分（AV前缀看上去像），<code>AVPlayerLayer</code>是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个<code>CALayer</code>子类来显示自定义的内容类型。</p>
<p><code>AVPlayerLayer</code>是用来在iOS上播放视频的。他是高级接口例如<code>MPMoivePlayer</code>的底层实现，提供了显示视频的底层控制。<code>AVPlayerLayer</code>的使用相当简单：你可以用<code>+playerLayerWithPlayer:</code>方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用<code>player</code>属性绑定一个<code>AVPlayer</code>实例。</p>
<p>在我们开始之前，我们需要添加AVFoundation到我们的项目中。然后，清单6.15创建了一个简单的电影播放器，图6.16是代码运行结果。</p>
<p>清单6.15 用<code>AVPlayerLayer</code>播放视频</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;#import &#60;QuartzCore/QuartzCore.h&#62;&#10;#import &#60;AVFoundation/AVFoundation.h&#62;&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView; @end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //get video URL&#10;    NSURL *URL = [[NSBundle mainBundle] URLForResource:@&#34;Ship&#34; withExtension:@&#34;mp4&#34;];&#10;&#10;    //create player and player layer&#10;    AVPlayer *player = [AVPlayer playerWithURL:URL];&#10;    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];&#10;&#10;    //set player layer frame and attach it to our view&#10;    playerLayer.frame = self.containerView.bounds;&#10;    [self.containerView.layer addSublayer:playerLayer];&#10;&#10;    //play the video&#10;    [player play];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/767cd84146a9f06d.png"></p>
<p>图6.16 用<code>AVPlayerLayer</code>图层播放视频的截图</p>
<p>我们用代码创建了一个<code>AVPlayerLayer</code>，但是我们仍然把它添加到了一个容器视图中，而不是直接在controller中的主视图上添加。这样其实是为了可以使用自动布局限制使得图层在最中间；否则，一旦设备被旋转了我们就要手动重新放置位置，因为Core Animation并不支持自动大小和自动布局（见第三章『图层几何学』）。</p>
<p>当然，因为<code>AVPlayerLayer</code>是<code>CALayer</code>的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频；清单6.16演示了在3D，圆角，有色边框，蒙板，阴影等效果（见图6.17）.</p>
<p>清单6.16 给视频增加变换，边框和圆角</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    ...&#10;    //set player layer frame and attach it to our view&#10;    playerLayer.frame = self.containerView.bounds;&#10;    [self.containerView.layer addSublayer:playerLayer];&#10;&#10;    //transform layer&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    transform.m34 = -1.0 / 500.0;&#10;    transform = CATransform3DRotate(transform, M_PI_4, 1, 1, 0);&#10;    playerLayer.transform = transform;&#10;    &#65532;&#10;    //add rounded corners and border&#10;    playerLayer.masksToBounds = YES;&#10;    playerLayer.cornerRadius = 20.0;&#10;    playerLayer.borderColor = [UIColor redColor].CGColor;&#10;    playerLayer.borderWidth = 5.0;&#10;&#10;    //play the video&#10;    [player play];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/6cfda2774a727a93.png"></p>
<p>图6.17 3D视角下的边框和圆角<code>AVPlayerLayer</code></p>
<h2 id="总结">总结</h2><p>这一章我们简要概述了一些专用图层以及用他们实现的一些效果，我们只是了解到这些图层的皮毛，像<code>CATiledLayer</code>和<code>CAEMitterLayer</code>这些类可以单独写一章的。但是，重点是记住<code>CALayer</code>是用处很大的，而且它并没有为所有可能的场景进行优化。为了获得Core Animation最好的性能，你需要为你的工作选对正确的工具，希望你能够挖掘这些不同的<code>CALayer</code>子类的功能。<br>这一章我们通过<code>CAEmitterLayer</code>和<code>AVPlayerLayer</code>类简单地接触到了一些动画，在第二章，我们将继续深入研究动画，就从隐式动画开始。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-21T01:32:52.000Z"><a href="/2015/04/21/Core Aniamtion深入探讨/5-变换/变换/">2015-04-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/21/Core Aniamtion深入探讨/5-变换/变换/">5-变换</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="变换">变换</h1><blockquote>
<p><em>很不幸，没人能告诉你母体是什么，你只能自己体会</em> — 骇客帝国</p>
</blockquote>
<p>在第四章“可视效果”中，我们研究了一些增强图层和它的内容显示效果的一些技术，在这一章中，我们将要研究可以用来对图层旋转，摆放或者扭曲的<code>CGAffineTransform</code>，以及可以将扁平物体转换成三维空间对象的<code>CATransform3D</code>（而不是仅仅对圆角矩形添加下沉阴影）。</p>
<h2 id="仿射变换">仿射变换</h2><p>在第三章“图层几何学”中，我们使用了<code>UIView</code>的<code>transform</code>属性旋转了钟的指针，但并没有解释背后运作的原理，实际上<code>UIView</code>的<code>transform</code>属性是一个<code>CGAffineTransform</code>类型，用于在二维空间做旋转，缩放和平移。<code>CGAffineTransform</code>是一个可以和二维空间向量（例如<code>CGPoint</code>）做乘法的3X2的矩阵（见图5.1）。</p>
<p><img src="http://i1.tietuku.com/adb6d030a880b185.jpg"></p>
<p>图5.1 用矩阵表示的<code>CGAffineTransform</code>和<code>CGPoint</code></p>
<p>用<code>CGPoint</code>的每一列和<code>CGAffineTransform</code>矩阵的每一行对应元素相乘再求和，就形成了一个新的<code>CGPoint</code>类型的结果。要解释一下图中显示的灰色元素，为了能让矩阵做乘法，左边矩阵的列数一定要和右边矩阵的行数个数相同，所以要给矩阵填充一些标志值，使得既可以让矩阵做乘法，又不改变运算结果，并且没必要存储这些添加的值，因为它们的值不会发生变化，但是要用来做运算。</p>
<p>因此，通常会用3×3（而不是2×3）的矩阵来做二维变换，你可能会见到3行2列格式的矩阵，这是所谓的以列为主的格式，图5.1所示的是以行为主的格式，只要能保持一致，用哪种格式都无所谓。</p>
<p>当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。<code>CGAffineTransform</code>中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行，<code>CGAffineTransform</code>可以做出任意符合上述标注的变换，图5.2显示了一些仿射的和非仿射的变换：</p>
<p><img src="http://i1.tietuku.com/efa605e116f25bcf.jpg"></p>
<p>图5.2 仿射和非仿射变换</p>
<h3 id="创建一个CGAffineTransform">创建一个<code>CGAffineTransform</code></h3><p>对矩阵数学做一个全面的阐述就超出本书的讨论范围了，不过如果你对矩阵完全不熟悉的话，矩阵变换可能会使你感到畏惧。幸运的是，Core Graphics提供了一系列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个<code>CGAffineTransform</code>实例：</p>
<pre><code><span class="function"><span class="title">CGAffineTransformMakeRotation</span><span class="params">(CGFloat angle)</span></span> 
<span class="function"><span class="title">CGAffineTransformMakeScale</span><span class="params">(CGFloat sx, CGFloat sy)</span></span>
<span class="function"><span class="title">CGAffineTransformMakeTranslation</span><span class="params">(CGFloat tx, CGFloat ty)</span></span>
</code></pre><p>旋转和缩放变换都可以很好解释—分别旋转或者缩放一个向量的值。平移变换是指每个点都移动了向量指定的x或者y值—所以如果向量代表了一个点，那它就平移了这个点的距离。</p>
<p>我们用一个很简单的项目来做个demo，把一个原始视图旋转45度角度（图5.3）</p>
<p><img src="http://i1.tietuku.com/070f74e3ec457111.jpg"></p>
<p>图5.3 使用仿射变换旋转45度角之后的视图</p>
<p><code>UIView</code>可以通过设置<code>transform</code>属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p><code>CALayer</code>同样也有一个<code>transform</code>属性，但它的类型是<code>CATransform3D</code>，而不是<code>CGAffineTransform</code>，本章后续将会详细解释。<code>CALayer</code>对应于<code>UIView</code>的<code>transform</code>属性叫做<code>affineTransform</code>，清单5.1的例子就是使用<code>affineTransform</code>对图层做了45度顺时针旋转。</p>
<p>清单5.1 使用<code>affineTransform</code>对图层旋转45度<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees&#10;    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>注意我们使用的旋转常量是<code>M_PI_4</code>，而不是你想象的45，因为iOS的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。</p>
<p>C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，<code>M_PI_4</code>于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">RADIANS_TO_DEGREES</span><span class="params">(x)</span></span> ((x)/M_PI*<span class="number">180.0</span>) 
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">DEGREES_TO_RADIANS</span><span class="params">(x)</span></span> ((x)/<span class="number">180.0</span>*M_PI)
</code></pre><h3 id="混合变换">混合变换</h3><p>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要<em>缩放</em>又要<em>旋转</em>的变换，这就会非常有用了。例如下面几个函数：</p>
<pre><code><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> angle)     
<span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)      
<span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)
</code></pre><p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要—也就是创建一个<code>CGAffineTransform</code>类型的空值，矩阵论中称作<em>单位矩阵</em>，Core Graphics同样也提供了一个方便的常量：</p>
<pre><code><span class="built_in">CGAffineTransformIdentity</span>
</code></pre><p>最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：</p>
<pre><code><span class="built_in">CGAffineTransformConcat</span>(<span class="built_in">CGAffineTransform</span> t1, <span class="built_in">CGAffineTransform</span> t2);
</code></pre><p>我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。</p>
<p>清单5.2 使用若干方法创建一个复合变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad]; //create a new transform&#10;    CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%&#10;    transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees&#10;    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //translate by 200 points&#10;    transform = CGAffineTransformTranslate(transform, 200, 0);&#10;    //apply transform to layer&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1ea93463a1d07eaa.jpg"></p>
<p>图5.4 顺序应用多个仿射变换之后的结果</p>
<p>图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<h3 id="剪切变换">剪切变换</h3><p>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置<code>CGAffineTransform</code>的值。除非需要创建一个<em>斜切</em>的变换，Core Graphics并没有提供直接的函数。</p>
<p>斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。</p>
<p><img src="http://i1.tietuku.com/c7d96f71ed1c7751.jpg"></p>
<p>图5.5 水平方向的斜切变换</p>
<p>清单5.3 实现一个斜切变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)&#10;&#123;&#10;    CGAffineTransform transform = CGAffineTransformIdentity;&#10;    transform.c = -x;&#10;    transform.b = y;&#10;    return transform;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //shear the layer at a 45-degree angle&#10;    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<h2 id="3D变换">3D变换</h2><p>CG的前缀告诉我们，<code>CGAffineTransform</code>类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且<code>CGAffineTransform</code>仅仅对2D变换有效。</p>
<p>在第三章中，我们提到了<code>zPosition</code>属性，可以用来让图层靠近或者远离相机（用户视角），<code>transform</code>属性（<code>CATransform3D</code>类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。</p>
<p>和<code>CGAffineTransform</code>类似，<code>CATransform3D</code>也是一个矩阵，但是和2x3的矩阵不同，<code>CATransform3D</code>是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。</p>
<p><img src="http://i1.tietuku.com/a1ea53bd4112cdd0.png"></p>
<p>图5.6 对一个3D像素点做<code>CATransform3D</code>矩阵变换</p>
<p>和<code>CGAffineTransform</code>矩阵类似，Core Animation提供了一系列的方法用来创建和组合<code>CATransform3D</code>类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个<code>z</code>参数，并且旋转函数除了<code>angle</code>之外多出了<code>x</code>,<code>y</code>,<code>z</code>三个参数，分别决定了每个坐标轴方向上的旋转：</p>
<pre><code><span class="built_in">CATransform3DMakeRotation</span>(<span class="built_in">CGFloat</span> angle, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> z)
<span class="built_in">CATransform3DMakeScale</span>(<span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy, <span class="built_in">CGFloat</span> sz) 
<span class="built_in">CATransform3DMakeTranslation</span>(Gloat tx, <span class="built_in">CGFloat</span> ty, <span class="built_in">CGFloat</span> tz)
</code></pre><p>你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7）。</p>
<p><img src="http://i1.tietuku.com/c6b630ab7aa08924.jpg"></p>
<p>图5.7 X，Y，Z轴，以及围绕它们旋转的方向</p>
<p>由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>
<p>举个例子：清单5.4的代码使用了<code>CATransform3DMakeRotation</code>对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。</p>
<p>结果见图5.8，但并不像我们期待的那样。</p>
<p>清单5.4 绕Y轴旋转图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees along the Y axis&#10;    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/d033b9cb3cc6e390.jpg"></p>
<p>图5.8 绕y轴旋转45度的视图</p>
<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？</p>
<p>其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是<em>透视</em>。</p>
<h3 id="透视投影">透视投影</h3><p>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入<em>投影变换</em>（又称作<em>z变换</em>）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p><code>CATransform3D</code>的透视效果通过一个矩阵中一个很简单的元素来控制：<code>m34</code>。<code>m34</code>（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><img src="http://i1.tietuku.com/d6160e8602e6a4ce.jpg"></p>
<p>图5.9 <code>CATransform3D</code>的<code>m34</code>元素，用来做透视</p>
<p><code>m34</code>的默认值是0，我们可以通过设置<code>m34</code>为-1.0 / <code>d</code>来应用透视效果，<code>d</code>代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的防止的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。</p>
<p>清单5.5 对变换应用透视效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create a new transform&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    //apply perspective&#10;    transform.m34 = - 1.0 / 500.0;&#10;    //rotate by 45 degrees along the Y axis&#10;    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);&#10;    //apply to layer&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/c2ecbd5db5454204.jpg"></p>
<p>图5.10 应用透视效果之后再次对图层做旋转</p>
<h3 id="灭点">灭点</h3><p>当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><img src="http://i1.tietuku.com/efe4aebcddaef0d0.png"></p>
<p>图5.11 灭点</p>
<p>Core Animation定义了这个点位于变换图层的<code>anchorPoint</code>（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前<code>anchorPoint</code>的位置。</p>
<p>当改变一个图层的<code>position</code>，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整<code>m34</code>来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的<code>position</code>），这样所有的3D图层都共享一个灭点。</p>
<h3 id="sublayerTransform属性"><code>sublayerTransform</code>属性</h3><p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个<code>position</code>，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。</p>
<p><code>CALayer</code>有一个属性叫做<code>sublayerTransform</code>。它也是<code>CATransform3D</code>类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在<em>容器图层</em>的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用<code>position</code>和<code>frame</code>来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p>我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。</p>
<p><img src="http://i1.tietuku.com/1dff7af353fc1e09.jpg"></p>
<p>图5.12 在一个视图容器内并排放置两个视图</p>
<p>清单5.6 应用<code>sublayerTransform</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //apply perspective transform to container&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = - 1.0 / 500.0;&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //rotate layerView1 by 45 degrees along the Y axis&#10;    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView1.layer.transform = transform1;&#10;    //rotate layerView2 by 45 degrees along the Y axis&#10;    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);&#10;    self.layerView2.layer.transform = transform2;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/6d6a571f355e1889.jpg"></p>
<p>图5.13 通过相同的透视效果分别对视图做变换</p>
<h3 id="背面">背面</h3><p>我们既然可以在3D场景下旋转图层，那么也可以从<em>背面</em>去观察它。如果我们在清单5.4中把角度修改为<code>M_PI</code>（180度）而不是当前的<code>M_PI_4</code>（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。</p>
<p>那么从背部看图层是什么样的呢，见图5.14</p>
<p><img src="http://i1.tietuku.com/d256c892ff0ee21a.jpg"></p>
<p>图5.14 视图的背面，一个镜像对称的图片</p>
<p>如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p><code>CALayer</code>有一个叫做<code>doubleSided</code>的属性来控制图层的背面是否要被绘制。这是一个<code>BOOL</code>类型，默认为<code>YES</code>，如果设置为<code>NO</code>，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<h3 id="扁平化图层">扁平化图层</h3><p>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15</p>
<p><img src="http://i1.tietuku.com/cfb668bfe041f088.jpg"></p>
<p>图5.15 反方向变换的嵌套图层</p>
<p>注意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。</p>
<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>
<p>验证一下，相应代码见清单5.7，结果见5.16</p>
<p>清单5.7 绕Z轴做相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *outerView;&#10;@property (nonatomic, weak) IBOutlet UIView *innerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);&#10;    self.innerView.layer.transform = inner;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/0d4804a3dc9fd31a.jpg"></p>
<p>图5.16 旋转后的视图</p>
<p>运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用<code>sublayerTransform</code>属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。</p>
<p>清单5.8 绕Y轴相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DIdentity;&#10;    outer.m34 = -1.0 / 500.0;&#10;    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DIdentity;&#10;    inner.m34 = -1.0 / 500.0;&#10;    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);&#10;    self.innerView.layer.transform = inner;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>预期的效果应该如图5.17所示。</p>
<p><img src="http://i1.tietuku.com/92f50e93fb3ac918.jpg"></p>
<p>图5.17 绕Y轴做相反旋转的预期结果。</p>
<p>但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。</p>
<p>这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在<em>同一个</em>3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p><img src="http://i1.tietuku.com/7781e04efefb13e7.jpg"></p>
<p>图5.18 绕Y轴做相反旋转的真实结果</p>
<p>类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系—在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的<code>CALayer</code>的时候是这样，<code>CALayer</code>有一个叫做<code>CATransformLayer</code>的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。</p>
<h2 id="固体对象">固体对象</h2><p>现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的<em>空洞</em>对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。</p>
<p>在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。</p>
<p><img src="http://i1.tietuku.com/5b91ab29ab27a4e7.jpg"></p>
<p>图5.19 用Interface Builder对立方体的六个面进行布局</p>
<p>这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的<code>transform</code>对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。</p>
<p>我们把一个有颜色的<code>UILabel</code>放置在视图内部，是为了清楚的辨别它们之间的关系，并且<code>UIButton</code>被放置在第三个面视图里面，后面会做简单的解释。</p>
<p>具体把视图组织成立方体的代码见清单5.9，结果见图5.20</p>
<p>清单5.9 创建一个立方体</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees&#10;    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>注意我们使用的旋转常量是<code>M_PI_4</code>，而不是你想象的45，因为iOS的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。</p>
<p>C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，<code>M_PI_4</code>于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">RADIANS_TO_DEGREES</span><span class="params">(x)</span></span> ((x)/M_PI*<span class="number">180.0</span>) 
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">DEGREES_TO_RADIANS</span><span class="params">(x)</span></span> ((x)/<span class="number">180.0</span>*M_PI)
</code></pre><h3 id="混合变换-1">混合变换</h3><p>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要<em>缩放</em>又要<em>旋转</em>的变换，这就会非常有用了。例如下面几个函数：</p>
<pre><code><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> angle)     
<span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)      
<span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)
</code></pre><p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要—也就是创建一个<code>CGAffineTransform</code>类型的空值，矩阵论中称作<em>单位矩阵</em>，Core Graphics同样也提供了一个方便的常量：</p>
<pre><code><span class="built_in">CGAffineTransformIdentity</span>
</code></pre><p>最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：</p>
<pre><code><span class="built_in">CGAffineTransformConcat</span>(<span class="built_in">CGAffineTransform</span> t1, <span class="built_in">CGAffineTransform</span> t2);
</code></pre><p>我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。</p>
<p>清单5.2 使用若干方法创建一个复合变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad]; //create a new transform&#10;    CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%&#10;    transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees&#10;    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //translate by 200 points&#10;    transform = CGAffineTransformTranslate(transform, 200, 0);&#10;    //apply transform to layer&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1ea93463a1d07eaa.jpg"></p>
<p>图5.4 顺序应用多个仿射变换之后的结果</p>
<p>图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<h3 id="剪切变换-1">剪切变换</h3><p>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置<code>CGAffineTransform</code>的值。除非需要创建一个<em>斜切</em>的变换，Core Graphics并没有提供直接的函数。</p>
<p>斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。</p>
<p><img src="http://i1.tietuku.com/c7d96f71ed1c7751.jpg"></p>
<p>图5.5 水平方向的斜切变换</p>
<p>清单5.3 实现一个斜切变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)&#10;&#123;&#10;    CGAffineTransform transform = CGAffineTransformIdentity;&#10;    transform.c = -x;&#10;    transform.b = y;&#10;    return transform;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //shear the layer at a 45-degree angle&#10;    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<h2 id="3D变换-1">3D变换</h2><p>CG的前缀告诉我们，<code>CGAffineTransform</code>类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且<code>CGAffineTransform</code>仅仅对2D变换有效。</p>
<p>在第三章中，我们提到了<code>zPosition</code>属性，可以用来让图层靠近或者远离相机（用户视角），<code>transform</code>属性（<code>CATransform3D</code>类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。</p>
<p>和<code>CGAffineTransform</code>类似，<code>CATransform3D</code>也是一个矩阵，但是和2x3的矩阵不同，<code>CATransform3D</code>是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。</p>
<p><img src="./5.6.jpeg" alt="图5.6" title="图5.6" width="700"></p>
<p>图5.6 对一个3D像素点做<code>CATransform3D</code>矩阵变换</p>
<p>和<code>CGAffineTransform</code>矩阵类似，Core Animation提供了一系列的方法用来创建和组合<code>CATransform3D</code>类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个<code>z</code>参数，并且旋转函数除了<code>angle</code>之外多出了<code>x</code>,<code>y</code>,<code>z</code>三个参数，分别决定了每个坐标轴方向上的旋转：</p>
<pre><code><span class="built_in">CATransform3DMakeRotation</span>(<span class="built_in">CGFloat</span> angle, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> z)
<span class="built_in">CATransform3DMakeScale</span>(<span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy, <span class="built_in">CGFloat</span> sz) 
<span class="built_in">CATransform3DMakeTranslation</span>(Gloat tx, <span class="built_in">CGFloat</span> ty, <span class="built_in">CGFloat</span> tz)
</code></pre><p>你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7）。</p>
<p><img src="./5.7.jpeg" alt="图5.7" title="图5.7" width="700"></p>
<p>图5.7 X，Y，Z轴，以及围绕它们旋转的方向</p>
<p>由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>
<p>举个例子：清单5.4的代码使用了<code>CATransform3DMakeRotation</code>对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。</p>
<p>结果见图5.8，但并不像我们期待的那样。</p>
<p>清单5.4 绕Y轴旋转图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees along the Y axis&#10;    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="./5.8.jpeg" alt="图5.8" title="图5.8" width="700"></p>
<p>图5.8 绕y轴旋转45度的视图</p>
<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？</p>
<p>其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是<em>透视</em>。</p>
<h3 id="透视投影-1">透视投影</h3><p>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入<em>投影变换</em>（又称作<em>z变换</em>）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p><code>CATransform3D</code>的透视效果通过一个矩阵中一个很简单的元素来控制：<code>m34</code>。<code>m34</code>（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><img src="./5.9.jpeg" alt="图5.9" title="图5.9" width="700"></p>
<p>图5.9 <code>CATransform3D</code>的<code>m34</code>元素，用来做透视</p>
<p><code>m34</code>的默认值是0，我们可以通过设置<code>m34</code>为-1.0 / <code>d</code>来应用透视效果，<code>d</code>代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的放置的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小或者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。</p>
<p>清单5.5 对变换应用透视效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create a new transform&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    //apply perspective&#10;    transform.m34 = - 1.0 / 500.0;&#10;    //rotate by 45 degrees along the Y axis&#10;    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);&#10;    //apply to layer&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="./5.10.jpeg" alt="图5.10" title="图5.10" width="700"></p>
<p>图5.10 应用透视效果之后再次对图层做旋转</p>
<h3 id="灭点-1">灭点</h3><p>当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><img src="./5.11.jpeg" alt="图5.11" title="图5.11" width="700"></p>
<p>图5.11 灭点</p>
<p>Core Animation定义了这个点位于变换图层的<code>anchorPoint</code>（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前<code>anchorPoint</code>的位置。</p>
<p>当改变一个图层的<code>position</code>，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整<code>m34</code>来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的<code>position</code>），这样所有的3D图层都共享一个灭点。</p>
<h3 id="sublayerTransform属性-1"><code>sublayerTransform</code>属性</h3><p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个<code>position</code>，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。</p>
<p><code>CALayer</code>有一个属性叫做<code>sublayerTransform</code>。它也是<code>CATransform3D</code>类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在<em>容器图层</em>的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用<code>position</code>和<code>frame</code>来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p>我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。</p>
<p><img src="./5.12.jpeg" alt="图5.12" title="图5.12" width="700"></p>
<p>图5.12 在一个视图容器内并排放置两个视图</p>
<p>清单5.6 应用<code>sublayerTransform</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //apply perspective transform to container&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = - 1.0 / 500.0;&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //rotate layerView1 by 45 degrees along the Y axis&#10;    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView1.layer.transform = transform1;&#10;    //rotate layerView2 by 45 degrees along the Y axis&#10;    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);&#10;    self.layerView2.layer.transform = transform2;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./5.13.jpeg" alt="图5.13" title="图5.13" width="700"></p>
<p>图5.13 通过相同的透视效果分别对视图做变换</p>
<h3 id="背面-1">背面</h3><p>我们既然可以在3D场景下旋转图层，那么也可以从<em>背面</em>去观察它。如果我们在清单5.4中把角度修改为<code>M_PI</code>（180度）而不是当前的<code>M_PI_4</code>（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。</p>
<p>那么从背部看图层是什么样的呢，见图5.14</p>
<p><img src="./5.14.jpeg" alt="图5.14" title="图5.14" width="700"></p>
<p>图5.14 视图的背面，一个镜像对称的图片</p>
<p>如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p><code>CALayer</code>有一个叫做<code>doubleSided</code>的属性来控制图层的背面是否要被绘制。这是一个<code>BOOL</code>类型，默认为<code>YES</code>，如果设置为<code>NO</code>，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<h3 id="扁平化图层-1">扁平化图层</h3><p>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15</p>
<p><img src="./5.15.jpeg" alt="图5.15" title="图5.15" width="700"></p>
<p>图5.15 反方向变换的嵌套图层</p>
<p>注意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。</p>
<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>
<p>验证一下，相应代码见清单5.7，结果见5.16</p>
<p>清单5.7 绕Z轴做相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *outerView;&#10;@property (nonatomic, weak) IBOutlet UIView *innerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);&#10;    self.innerView.layer.transform = inner;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="./5.16.jpeg" alt="图5.16" title="图5.16" width="700"></p>
<p>图5.16 旋转后的视图</p>
<p>运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用<code>sublayerTransform</code>属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。</p>
<p>清单5.8 绕Y轴相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DIdentity;&#10;    outer.m34 = -1.0 / 500.0;&#10;    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DIdentity;&#10;    inner.m34 = -1.0 / 500.0;&#10;    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);&#10;    self.innerView.layer.transform = inner;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>预期的效果应该如图5.17所示。</p>
<p><img src="./5.17.jpeg" alt="图5.17" title="图5.17" width="700"></p>
<p>图5.17 绕Y轴做相反旋转的预期结果。</p>
<p>但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。</p>
<p>这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在<em>同一个</em>3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p><img src="./5.18.jpeg" alt="图5.18" title="图5.18" width="700"></p>
<p>图5.18 绕Y轴做相反旋转的真实结果</p>
<p>类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系—在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的<code>CALayer</code>的时候是这样，<code>CALayer</code>有一个叫做<code>CATransformLayer</code>的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。</p>
<h2 id="固体对象-1">固体对象</h2><p>现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的<em>空洞</em>对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。</p>
<p>在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。</p>
<p><img src="./5.19.jpeg" alt="图5.19" title="图5.19" width="700"></p>
<p>图5.19 用Interface Builder对立方体的六个面进行布局</p>
<p>这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的<code>transform</code>对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。</p>
<p>我们把一个有颜色的<code>UILabel</code>放置在视图内部，是为了清楚的辨别它们之间的关系，并且<code>UIButton</code>被放置在第三个面视图里面，后面会做简单的解释。</p>
<p>具体把视图组织成立方体的代码见清单5.9，结果见图5.20</p>
<p>清单5.9 创建一个立方体</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform&#10;&#123;&#10;    //get the face view and add it to the container&#10;    UIView *face = self.faces[index];&#10;    [self.containerView addSubview:face];&#10;    //center the face view within the container&#10;    CGSize containerSize = self.containerView.bounds.size;&#10;    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);&#10;    // apply the transform&#10;    face.layer.transform = transform;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //set up the container sublayer transform&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = -1.0 / 500.0;&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //add cube face 1&#10;    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);&#10;    [self addFace:0 withTransform:transform];&#10;    //add cube face 2&#10;    transform = CATransform3DMakeTranslation(100, 0, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);&#10;    [self addFace:1 withTransform:transform];&#10;    //add cube face 3&#10;    transform = CATransform3DMakeTranslation(0, -100, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);&#10;    [self addFace:2 withTransform:transform];&#10;    //add cube face 4&#10;    transform = CATransform3DMakeTranslation(0, 100, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);&#10;    [self addFace:3 withTransform:transform];&#10;    //add cube face 5&#10;    transform = CATransform3DMakeTranslation(-100, 0, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);&#10;    [self addFace:4 withTransform:transform];&#10;    //add cube face 6&#10;    transform = CATransform3DMakeTranslation(0, 0, -100);&#10;    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);&#10;    [self addFace:5 withTransform:transform];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/6eb66c57fcdc0d1d.jpg"></p>
<p>图5.20 正面朝上的立方体</p>
<p>从这个角度看立方体并不是很明显；看起来只是一个方块，为了更好地欣赏它，我们将更换一个<em>不同的视角</em>。</p>
<p>旋转这个立方体将会显得很笨重，因为我们要单独对每个面做旋转。另一个简单的方案是通过调整容器视图的<code>sublayerTransform</code>去旋转<em>照相机</em>。</p>
<p>添加如下几行去旋转<code>containerView</code>图层的<code>perspective</code>变换矩阵：</p>
<pre><code>perspective = CATra<span class="label">nsform3</span>DRotate<span class="comment">(perspective, -M_PI_4, 1, 0, 0)</span>; 
perspective = CATra<span class="label">nsform3</span>DRotate<span class="comment">(perspective, -M_PI_4, 0, 1, 0)</span>;
</code></pre><p>这就对相机（或者相对相机的整个场景，你也可以这么认为）绕Y轴旋转45度，并且绕X轴旋转45度。现在从另一个角度去观察立方体，就能看出它的真实面貌（图5.21）。</p>
<p><img src="http://i1.tietuku.com/fefaf7cd35c56492.jpg"></p>
<p>图5.21 从一个边角观察的立方体</p>
<h3 id="光亮和阴影">光亮和阴影</h3><p>现在它看起来更像是一个立方体没错了，但是对每个面之间的连接还是很难分辨。Core Animation可以用3D显示图层，但是它对<em>光线</em>并没有概念。如果想让立方体看起来更加真实，需要自己做一个阴影效果。你可以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。</p>
<p>如果需要<em>动态</em>地创建光线效果，你可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，你需要得到每个面的<em>正太向量</em>（垂直于表面的向量），然后根据一个想象的光源计算出两个向量<em>叉乘</em>结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</p>
<p>清单5.10实现了这样一个结果，我们用GLKit框架来做向量的计算（你需要引入GLKit库来运行代码），每个面的<code>CATransform3D</code>都被转换成<code>GLKMatrix4</code>，然后通过<code>GLKMatrix4GetMatrix3</code>函数得出一个3×3的<em>旋转矩阵</em>。这个旋转矩阵指定了图层的方向，然后可以用它来得到正太向量的值。</p>
<p>结果如图5.22所示，试着调整<code>LIGHT_DIRECTION</code>和<code>AMBIENT_LIGHT</code>的值来切换光线效果</p>
<p>清单5.10 对立方体的表面应用动态的光线效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34; &#10;#import &#60;QuartzCore/QuartzCore.h&#62; &#10;#import &#60;GLKit/GLKit.h&#62;&#10;&#10;#define LIGHT_DIRECTION 0, 1, -0.5 &#10;#define AMBIENT_LIGHT 0.5&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)applyLightingToFace:(CALayer *)face&#10;&#123;&#10;    //add lighting layer&#10;    CALayer *layer = [CALayer layer];&#10;    layer.frame = face.bounds;&#10;    [face addSublayer:layer];&#10;    //convert the face transform to matrix&#10;    //(GLKMatrix4 has the same structure as CATransform3D)&#10;    //&#35793;&#32773;&#27880;&#65306;GLKMatrix4&#21644;CATransform3D&#20869;&#23384;&#32467;&#26500;&#19968;&#33268;&#65292;&#20294;&#22352;&#26631;&#31867;&#22411;&#26377;&#38271;&#24230;&#21306;&#21035;&#65292;&#25152;&#20197;&#29702;&#35770;&#19978;&#24212;&#35813;&#20570;&#19968;&#27425;float&#21040;CGFloat&#30340;&#36716;&#25442;&#65292;&#24863;&#35874;[@zihuyishi](https://github.com/zihuyishi)&#21516;&#23398;~&#10;    CATransform3D transform = face.transform;&#10;    GLKMatrix4 matrix4 = *(GLKMatrix4 *)&#38;transform;&#10;    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);&#10;    //get face normal&#10;    GLKVector3 normal = GLKVector3Make(0, 0, 1);&#10;    normal = GLKMatrix3MultiplyVector3(matrix3, normal);&#10;    normal = GLKVector3Normalize(normal);&#10;    //get dot product with light direction&#10;    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));&#10;    float dotProduct = GLKVector3DotProduct(light, normal);&#10;    //set lighting layer opacity&#10;    CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;&#10;    UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];&#10;    layer.backgroundColor = color.CGColor;&#10;&#125;&#10;&#10;- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform&#10;&#123;&#10;    //get the face view and add it to the container&#10;    UIView *face = self.faces[index];&#10;    [self.containerView addSubview:face];&#10;    //center the face view within the container&#10;    CGSize containerSize = self.containerView.bounds.size;&#10;    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);&#10;    // apply the transform&#10;    face.layer.transform = transform;&#10;    //apply lighting&#10;    [self applyLightingToFace:face.layer];&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //set up the container sublayer transform&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = -1.0 / 500.0;&#10;    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);&#10;    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //add cube face 1&#10;    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);&#10;    [self addFace:0 withTransform:transform];&#10;    //add cube face 2&#10;    transform = CATransform3DMakeTranslation(100, 0, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);&#10;    [self addFace:1 withTransform:transform];&#10;    //add cube face 3&#10;    transform = CATransform3DMakeTranslation(0, -100, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);&#10;    [self addFace:2 withTransform:transform];&#10;    //add cube face 4&#10;    transform = CATransform3DMakeTranslation(0, 100, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);&#10;    [self addFace:3 withTransform:transform];&#10;    //add cube face 5&#10;    transform = CATransform3DMakeTranslation(-100, 0, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);&#10;    [self addFace:4 withTransform:transform];&#10;    //add cube face 6&#10;    transform = CATransform3DMakeTranslation(0, 0, -100);&#10;    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);&#10;    [self addFace:5 withTransform:transform];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/bf9c09e6dcc75155.jpg"></p>
<p>图5.22 动态计算光线效果之后的立方体</p>
<h3 id="点击事件">点击事件</h3><p>你应该能注意到现在可以在第三个表面的顶部看见按钮了，点击它，什么都没发生，为什么呢？</p>
<p>这并不是因为iOS在3D场景下正确地处理响应事件，实际上是可以做到的。问题在于<em>视图顺序</em>。在第三章中我们简要提到过，点击事件的处理由视图在父视图中的顺序决定的，并不是3D空间中的Z轴顺序。当给立方体添加视图的时候，我们实际上是按照一个顺序添加，所以按照视图/图层顺序来说，4，5，6在3的前面。</p>
<p>即使我们看不见4，5，6的表面（因为被1，2，3遮住了），iOS在事件响应上仍然保持之前的顺序。当试图点击表面3上的按钮，表面4，5，6截断了点击事件（取决于点击的位置），这就和普通的2D布局在按钮上覆盖物体一样。</p>
<p>你也许认为把<code>doubleSided</code>设置成<code>NO</code>可以解决这个问题，因为它不再渲染视图后面的内容，但实际上并不起作用。因为背对相机而隐藏的视图仍然会响应点击事件（这和通过设置<code>hidden</code>属性或者设置<code>alpha</code>为0而隐藏的视图不同，那两种方式将不会响应事件）。所以即使禁止了双面渲染仍然不能解决这个问题（虽然由于性能问题，还是需要把它设置成<code>NO</code>）。</p>
<p>这里有几种正确的方案：把除了表面3的其他视图<code>userInteractionEnabled</code>属性都设置成<code>NO</code>来禁止事件传递。或者简单通过代码把视图3覆盖在视图6上。无论怎样都可以点击按钮了（图5.23）。</p>
<p><img src="http://i1.tietuku.com/1096c5e277cf7dd9.jpg"></p>
<p>图5.23 背景视图不再阻碍按钮，我们可以点击它了</p>
<h2 id="总结">总结</h2><p>这一章涉及了一些2D和3D的变换。你学习了一些矩阵计算的基础，以及如何用Core Animation创建3D场景。你看到了图层背后到底是如何呈现的，并且知道了不能把扁平的图片做成真实的立体效果，最后我们用demo说明了触摸事件的处理，视图中图层添加的层级顺序会比屏幕上显示的顺序更有意义。</p>
<p>第六章我们会研究一些Core Animation提供不同功能的具体的<code>CALayer</code>子类。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-18T07:33:48.000Z"><a href="/2015/04/18/iOS&OC/MJExtention-对不规范-JSON-解析的一个测试/">2015-04-18</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/18/iOS&OC/MJExtention-对不规范-JSON-解析的一个测试/">MJExtention 对不规范 JSON 解析的一个测试</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Context">Context</h2><p>今天受 MJ 老师吩咐,测试 MJExtension 对于不规范的 JSON 的解析情况.特记录于此 </p>
<h2 id="说明几点">说明几点</h2><h3 id="何为不规范">何为不规范</h3><p>我说的不规则指的是有一定容错能力,但是前提还是 JSON,弄些乱七八糟的字符串就没有意义了哈.比如说,这次我想测试的是前一段事件遇到的一个小问题:服务端返回的是类似这样的一个结果:  </p>
<p><img src="http://ww1.sinaimg.cn/large/9e446dffjw1er9qrf2g2hj206608vaad.jpg"></p>
<p>为了展现,截图是规范的 JSON,服务端给我的实际数据是:<br>两个箭头指向处还有 <code>&quot;</code>  .</p>
<p><img src="http://ww2.sinaimg.cn/large/9e446dffjw1er9ql5uocrj206k08sq3c.jpg">  </p>
<p>换句话说,他是严格执行的: <code>&quot;键&quot;:&quot;无论啥类型&quot;</code> . 网上大多数的所谓的 JSON 格式校验工具认为这种格式是 okay 的,但是它的问题是,没法继续”钻下去” ,这里就是我所说的 “不规范”.<br>说到这里,推荐个地址 <a href="http://tool.oschina.net/codeformat/json">在线校验</a>,这个不仅仅是校验,还有格式化功能.支持按层级折叠和展开.</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/18/iOS&OC/MJExtention-对不规范-JSON-解析的一个测试/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-17T01:32:52.000Z"><a href="/2015/04/17/Core Aniamtion深入探讨/4-视觉效果/4-视觉效果/">2015-04-17</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/17/Core Aniamtion深入探讨/4-视觉效果/4-视觉效果/">4-视觉效果</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="视觉效果">视觉效果</h1><blockquote>
<p>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢？</p>
<p>我们现在能做到那样了么？</p>
<p>史蒂芬·乔布斯</p>
</blockquote>
<p>我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。</p>
<h2 id="圆角">圆角</h2><p>圆角矩形是iOS的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。</p>
<p>CALayer有一个叫做<code>conrnerRadius</code>的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会被截取。</p>
<p>我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)</p>
<p><img src="http://i1.tietuku.com/3a95761f3df03285.png"></p>
<p>图4.1 两个白色的大视图，他们都包含了小一些的红色视图。</p>
<p>然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果</p>
<p>清单4.1 设置<code>cornerRadius</code>和<code>masksToBounds</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;- (void)viewDidLoad&#10;&#123;&#65532;&#65532;&#65532;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/dc9050c13c4b29c0.png"></p>
<p>右图中，红色的子视图沿角半径被裁剪了</p>
<p>如你所见，右边的子视图沿边界被裁剪了。</p>
<p>单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者是CAShapeLayer（见第六章『专用图层』）。</p>
<h2 id="图层边框">图层边框</h2><p>CALayer另外两个非常有用属性就是<code>borderWidth</code>和<code>borderColor</code>。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的<code>bounds</code>绘制，同时也包含图层的角。</p>
<p><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0.<code>borderColor</code>定义了边框的颜色，默认为黑色。</p>
<p><code>borderColor</code>是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了<code>borderColor</code>，虽然属性声明并不能证明这一点。<code>CGColorRef</code>在引用/释放时候的行为表现得与<code>NSObject</code>极其相似。但是Objective-C语法并不支持这一做法，所以<code>CGColorRef</code>属性即便是强引用也只能通过assign关键字来声明。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.</p>
<p>清单4.2 加上边框</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //add a border to our layers&#10;  self.layerView1.layer.borderWidth = 5.0f;&#10;  self.layerView2.layer.borderWidth = 5.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/36dc54ae201277f2.png"></p>
<p>图4.3 给图层增加一个边框</p>
<p>仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.</p>
<p><img src="http://i1.tietuku.com/86e5c09f8cf07c10.png"></p>
<p>图4.4 边框是跟随图层的边界变化的，而不是图层里面的内容</p>
<h2 id="阴影">阴影</h2><p>iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</p>
<p>给<code>shadowOpacity</code>属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。<code>shadowOpacity</code>是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：<code>shadowColor</code>，<code>shadowOffset</code>和<code>shadowRadius</code>。</p>
<p>显而易见，<code>shadowColor</code>属性控制着阴影的颜色，和<code>borderColor</code>和<code>backgroundColor</code>一样，它的类型也是<code>CGColorRef</code>。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</p>
<p><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个<code>CGSize</code>的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。<code>shadowOffset</code>的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p>为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，<code>shadowOffset</code>的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.</p>
<p><img src="http://i1.tietuku.com/7db986fe34f3b61a.png"></p>
<p>图4.5 在iOS（左）和Mac OS（右）上<code>shadowOffset</code>的表现。</p>
<p>苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>
<p><code>shadowRadius</code>属性控制着阴影的<em>模糊度</em>，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。</p>
<p>通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给<code>shadowRadius</code>设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.</p>
<p><img src="http://i1.tietuku.com/be6b969406fb888a.png"></p>
<p>图4.6 大一些的阴影位移和角半径会增加图层的深度即视感</p>
<h2 id="阴影裁剪">阴影裁剪</h2><p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。</p>
<p><img src="http://i1.tietuku.com/f3cbc8b39c5d0031.png"></p>
<p>图4.7 阴影是根据寄宿图的轮廓来确定的</p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了<code>masksToBounds</code>属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.</p>
<p><img src="http://i1.tietuku.com/3beca24155d015a1.png"></p>
<p>图4.8 <code>maskToBounds</code>属性裁剪掉了阴影和内容</p>
<p>从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用<code>masksToBounds</code>裁剪内容的内图层。</p>
<p>如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.</p>
<p><img src="http://i1.tietuku.com/7760492f8e8ba8bf.png"></p>
<p>图4.9 右边，用额外的阴影转换视图包裹被裁剪的视图</p>
<p>我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。</p>
<p>清单4.3 用一个额外的视图来解决阴影裁切的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;@property (nonatomic, weak) IBOutlet UIView *shadowView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#65532;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //add a border to our layers&#10;  self.layerView1.layer.borderWidth = 5.0f;&#10;  self.layerView2.layer.borderWidth = 5.0f;&#10;&#10;  //add a shadow to layerView1&#10;  self.layerView1.layer.shadowOpacity = 0.5f;&#10;  self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&#10;  self.layerView1.layer.shadowRadius = 5.0f;&#10;&#10;  //add same shadow to shadowView (not layerView2)&#10;  self.shadowView.layer.shadowOpacity = 0.5f;&#10;  self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&#10;  self.shadowView.layer.shadowRadius = 5.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/346b0e2ad8ae09d7.png"></p>
<p>图4.10 右边视图，不受裁切阴影的阴影视图。</p>
<h2 id="shadowPath属性"><code>shadowPath</code>属性</h2><p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<code>shadowPath</code>是一个<code>CGPathRef</code>类型（一个指向<code>CGPath</code>的指针）。<code>CGPath</code>是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<p>图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。</p>
<p><img src="http://i1.tietuku.com/2799e67d09602635.png"></p>
<p>图4.11 用<code>shadowPath</code>指定任意阴影形状</p>
<p>清单4.4 创建简单的阴影形状</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //enable layer shadows&#10;  self.layerView1.layer.shadowOpacity = 0.5f;&#10;  self.layerView2.layer.shadowOpacity = 0.5f;&#10;&#10;  //create a square shadow&#10;  CGMutablePathRef squarePath = CGPathCreateMutable();&#10;  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);&#10;  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);&#10;&#10;  &#65532;//create a circular shadow&#10;  CGMutablePathRef circlePath = CGPathCreateMutable();&#10;  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);&#10;  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>如果是一个矩形或者是圆，用<code>CGPath</code>会相当简单明了。但是如果是更加复杂一点的图形，<code>UIBezierPath</code>类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<h2 id="图层蒙板">图层蒙板</h2><p>通过<code>masksToBounds</code>属性，我们可以沿边界裁剪图形；通过<code>cornerRadius</code>属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个属性叫做<code>mask</code>可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
<p><code>mask</code>图层的<code>Color</code>属性是无关紧要的，真正重要的是图层的轮廓。<code>mask</code>属性就像是一个饼干切割机，<code>mask</code>图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）</p>
<p>如果<code>mask</code>图层比父图层要小，只有在<code>mask</code>图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p><img src="http://i1.tietuku.com/3123be453a267e1d.png"></p>
<p>图4.12 把图片和蒙板图层作用在一起的效果</p>
<p>我们将代码演示一下这个过程，创建一个简单的项目，通过图层的<code>mask</code>属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。</p>
<p>清单4.5 应用蒙板图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIImageView *imageView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create mask layer&#10;  CALayer *maskLayer = [CALayer layer];&#10;  maskLayer.frame = self.layerView.bounds;&#10;  UIImage *maskImage = [UIImage imageNamed:@&#34;Cone.png&#34;];&#10;  maskLayer.contents = (__bridge id)maskImage.CGImage;&#10;&#10;  //apply mask to image layer&#65532;&#10;  self.imageView.layer.mask = maskLayer;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/91a010e3dcb3e549.png"></p>
<p>图4.13 使用了<code>mask</code>之后的UIImageView</p>
<p>CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为<code>mask</code>属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。</p>
<h2 id="拉伸过滤">拉伸过滤</h2><p>最后我们再来谈谈<code>minificationFilter</code>和<code>magnificationFilter</code>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。</p>
<p>当图片需要显示不同的大小的时候，有一种叫做<em>拉伸过滤</em>的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
<p>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。<code>CALayer</code>为此提供了三种拉伸过滤方法，他们是：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。</p>
<p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<p><img src="http://i1.tietuku.com/362db4f8519bde1d.png"></p>
<p>图4.14 对于大图来说，双线性滤波和三线性滤波表现得更出色</p>
<p><code>kCAFilterNearest</code>是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>
<p><img src="http://i1.tietuku.com/79c8bfe9549efe33.png"></p>
<p>图4.15 对于没有斜线的小图来说，最近过滤算法要好很多</p>
<p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<p>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。</p>
<p><img src="http://i1.tietuku.com/c5d07147325d611e.png"></p>
<p>图4.16 一个简单的运用拼合技术显示的LCD数字风格的像素字体</p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个<code>IBOutletCollection</code>对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。</p>
<p><img src="http://i1.tietuku.com/6d751b3556c52024.png"><br>图4.17</p>
<p>清单4.6 显示一个LCD风格的时钟</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;&#10;@property (nonatomic, weak) NSTimer *timer;&#10;&#65532;&#65532;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //get spritesheet image&#10;  UIImage *digits = [UIImage imageNamed:@&#34;Digits.png&#34;];&#10;&#10;  //set up digit views&#10;  for (UIView *view in self.digitViews) &#123;&#10;    //set contents&#10;    view.layer.contents = (__bridge id)digits.CGImage;&#10;    view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);&#10;    view.layer.contentsGravity = kCAGravityResizeAspect;&#10;  &#125;&#10;&#10;  //start timer&#10;  self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&#10;&#10;  //set initial clock time&#10;  [self tick];&#10;&#125;&#10;&#10;- (void)setDigit:(NSInteger)digit forView:(UIView *)view&#10;&#123;&#10;  //adjust contentsRect to select correct digit&#10;  view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);&#10;&#125;&#10;&#10;- (void)tick&#10;&#123;&#10;  //convert time to hours, minutes and seconds&#10;  NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];&#10;  NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&#10;  &#65532;&#10;  NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&#10;&#10;  //set hours&#10;  [self setDigit:components.hour / 10 forView:self.digitViews[0]];&#10;  [self setDigit:components.hour % 10 forView:self.digitViews[1]];&#10;&#10;  //set minutes&#10;  [self setDigit:components.minute / 10 forView:self.digitViews[2]];&#10;  [self setDigit:components.minute % 10 forView:self.digitViews[3]];&#10;&#10;  //set seconds&#10;  [self setDigit:components.second / 10 forView:self.digitViews[4]];&#10;  [self setDigit:components.second % 10 forView:self.digitViews[5]];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>如图4.18，这样做的确起了效果，但是图片看起来模糊了。看起来默认的<code>kCAFilterLinear</code>选项让我们失望了。</p>
<p><img src="http://i1.tietuku.com/9907966a7840c64a.png"></p>
<p>图4.18 一个模糊的时钟，由默认的<code>kCAFilterLinear</code>引起</p>
<p>为了能像图4.19中那样，我们需要在for循环中加入如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.magnificationFilter = kCAFilterNearest;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/7acc929bf7f74628.png"></p>
<p>图4.19 设置了最近过滤之后的清晰显示</p>
<h2 id="组透明">组透明</h2><p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了<code>opacity</code>属性，那它的子图层都会受此影响。</p>
<p>iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p><img src="http://i1.tietuku.com/9d67bc29e9634724.png"></p>
<p>图4.20 右边的渐隐按钮中，里面的标签清晰可见</p>
<p>这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的<code>UIViewGroupOpacity</code>为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果<code>UIViewGroupOpacity</code>并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做<code>shouldRasterize</code>属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。</p>
<p>为了启用<code>shouldRasterize</code>属性，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当<code>shouldRasterize</code>和<code>UIViewGroupOpacity</code>一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。</p>
<p>清单4.7 使用<code>shouldRasterize</code>属性解决组透明问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (UIButton *)customButton&#10;&#123;&#10;  //create button&#10;  CGRect frame = CGRectMake(0, 0, 150, 50);&#10;  UIButton *button = [[UIButton alloc] initWithFrame:frame];&#10;  button.backgroundColor = [UIColor whiteColor];&#10;  button.layer.cornerRadius = 10;&#10;&#10;  //add label&#10;  frame = CGRectMake(20, 10, 110, 30);&#10;  UILabel *label = [[UILabel alloc] initWithFrame:frame];&#10;  label.text = @&#34;Hello World&#34;;&#10;  label.textAlignment = NSTextAlignmentCenter;&#10;  [button addSubview:label];&#10;  return button;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create opaque button&#10;  UIButton *button1 = [self customButton];&#10;  button1.center = CGPointMake(50, 150);&#10;  [self.containerView addSubview:button1];&#10;&#10;  //create translucent button&#10;  UIButton *button2 = [self customButton];&#10;  &#65532;&#10;  button2.center = CGPointMake(250, 150);&#10;  button2.alpha = 0.5;&#10;  [self.containerView addSubview:button2];&#10;&#10;  //enable rasterization for the translucent button&#10;  button2.layer.shouldRasterize = YES;&#10;  button2.layer.rasterizationScale = [UIScreen mainScreen].scale;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1cdd82c2af9c9a89.png"></p>
<p>图4.21 修正后的图</p>
<h2 id="总结">总结</h2><p>这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。</p>
<p>在第五章，『变换』中，我们将会研究图层变化和3D转换。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T04:58:58.000Z"><a href="/2015/04/15/主页维护记录/博客成长记/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/主页维护记录/博客成长记/">博客成长记</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="加入评论功能">加入评论功能</h2><p><em>2015-04-15 12:59:49</em>   </p>
<ol>
<li><p>使用微博或者其他帐号登录<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>,建立自己的一个帐号,同时拿到通用代码.    </p>
</li>
<li><p>取消HEXO博客根目录中的 <code>_config.yml</code> 中 <code>disqus_shortname:</code> ，暂时不用这个功能，直接永久开启多说评论。</p>
</li>
<li><p>修改主题目录下面的(我的是 <code>/themes/jacman/_config.ym</code> ) <code>_config.yml</code> 中的 </p>
</li>
</ol>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#### Comment</span></span><br><span class="line"><span class="label">duoshuo_shortname:</span> guiqingblog    <span class="preprocessor">## e.g. wuchong   your duoshuo short name.</span></span><br></pre></td></tr></table></figure>
<p>如果没有请添加.   </p>
<ol>
<li>修改 <code>themes\XXX\layout_partial\article.ejs</code><br>在最后加上下面的代码:</li>
</ol>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span> <span class="keyword">if</span><span class="comment">(!index)</span>&#123; <span class="preprocessor">%</span>&gt;</span><br><span class="line">&lt;<span class="preprocessor">%</span>- partial<span class="comment">('comment')</span> <span class="preprocessor">%</span>&gt;</span><br><span class="line">&lt;<span class="preprocessor">%</span> &#125; <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>修改 <code>themes/jacman/layout/_partial/post/comment.ejs</code> 为你通用代码的 js 部分,如果没有这个文件请新建.</li>
</ol>
<p>最终效果:  </p>
<p><img src="http://ww3.sinaimg.cn/large/9e446dffjw1er66il80t3j20mp09ujs8.jpg"></p>
<p>参考网址:  </p>
<p><a href="http://gpio.me/hexo-duoshuo.html" target="_blank" rel="external">http://gpio.me/hexo-duoshuo.html</a><br><a href="http://duoshuo.com" target="_blank" rel="external">http://duoshuo.com</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T04:47:38.000Z"><a href="/2015/04/15/iOS&OC/在类的头文件中尽量少引入其他头文件/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/iOS&OC/在类的头文件中尽量少引入其他头文件/">高效OC编程-在类的头文件中尽量少引入其他头文件</a></h1>
  

    </header>
    <div class="entry">
      
        <p>与C 和C++ 一样，Objective-C 也使用“头文件”（header file） 与“实现文件”（implementation file）来区隔代码。用Objective-C 语言编写“类”（class）的标准方式为：以类名做文件名，分别创建两个文件，头文件后缀用.h，实现文件后缀用.m。创建好一个类之后，其代码看上去如下所示:   </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCPerson.h</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCPerson.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"EOCPerson.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span></span></span><br><span class="line"><span class="comment">// Implementation of methods</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/15/iOS&OC/在类的头文件中尽量少引入其他头文件/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T01:32:52.000Z"><a href="/2015/04/15/Core Aniamtion深入探讨/3-图层几何学/图层几何学/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/Core Aniamtion深入探讨/3-图层几何学/图层几何学/">3-图层几何学</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="图层几何学">图层几何学</h1><blockquote>
<p><em>不熟悉几何学的人就不要来这里了</em> —柏拉图学院入口的签名</p>
</blockquote>
<p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<h2 id="布局">布局</h2><p><code>UIView</code>有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，<code>CALayer</code>对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p><code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>所在的位置。<code>anchorPoint</code>的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="http://i1.tietuku.com/71af11930be4457f.jpg" alt="图3.1" title="图3.1" width="700"></p>
<p>图3.1 <code>UIView</code>和<code>CALayer</code>的坐标系</p>
<p>视图的<code>frame</code>，<code>bounds</code>和<code>center</code>属性仅仅是<em>存取方法</em>，当操纵视图的<code>frame</code>，实际上是在改变位于视图下方<code>CALayer</code>的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<p>对于视图或者图层来说，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，<code>frame</code>实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说<code>frame</code>的宽高可能和<code>bounds</code>的宽高不再一致了（图3.2）</p>
<p><img src="http://i1.tietuku.com/b3cc087d8701c6c4.jpg"></p>
<p>图3.2 旋转一个视图或者图层之后的<code>frame</code>属性</p>
<h2 id="锚点">锚点</h2><p>之前提到过，视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置，你可以认为<code>anchorPoint</code>是用来移动图层的<em>把柄</em>。</p>
<p>默认来说，<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。<code>anchorPoint</code>属性并没有被<code>UIView</code>接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的<code>anchorPoint</code>可以被移动，比如你可以把它置于图层<code>frame</code>的左上角，于是图层的内容将会向右下角的<code>position</code>方向移动（图3.3），而不是居中了。</p>
<p><img src="http://i1.tietuku.com/cd0b18512266f4e8.jpg"></p>
<p>图3.3 改变<code>anchorPoint</code>的效果</p>
<p>和第二章提到的<code>contentsRect</code>和<code>contentsCenter</code>属性类似，<code>anchorPoint</code>用<em>单位坐标</em>来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。<code>anchorPoint</code>可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了<code>anchorPoint</code>，<code>position</code>属性保持固定的值并没有发生改变，但是<code>frame</code>却移动了。</p>
<p>那在什么场合需要改变<code>anchorPoint</code>呢？既然我们可以随意改变图层位置，那改变<code>anchorPoint</code>不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个<code>UIImageView</code>实例（当然你也可以用正常的视图，设置他们图层的<code>contents</code>图片）。</p>
<p><img src="http://i1.tietuku.com/4cf92548d6313258.jpg"></p>
<p>图3.4 组成钟面和钟表的四张图片</p>
<p>闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的<code>frame</code>，而根据图3.2的演示，当视图旋转的时候，<code>frame</code>是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用<code>NSTimer</code>来更新闹钟，使用视图的<code>transform</code>属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="http://i1.tietuku.com/2eb6826a87ecce6b.jpg"></p>
<p>图3.5 在Interface Builder中布局闹钟视图</p>
<p>清单3.1 <strong>Clock</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIImageView *hourHand;&#10;@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;&#10;@property (nonatomic, weak) IBOutlet UIImageView *secondHand;&#10;@property (nonatomic, weak) NSTimer *timer;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //start timer&#10;    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&#10;                  &#65532;&#10;    //set initial hand positions&#10;    [self tick];&#10;&#125;&#10;&#10;- (void)tick&#10;&#123;&#10;    //convert time to hours, minutes and seconds&#10;    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];&#10;    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&#10;    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&#10;    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;&#10;    //calculate hour hand angle //calculate minute hand angle&#10;    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;&#10;    //calculate second hand angle&#10;    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;&#10;    //rotate hands&#10;    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);&#10;    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);&#10;    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。</p>
<p><img src="http://i1.tietuku.com/8718ca04ee738767.jpg"></p>
<p>图3.6 钟面，和不对齐的钟指针</p>
<p>你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用<code>anchorPoint</code>属性，我们来在<code>-viewDidLoad</code>方法中添加几行代码来给每个钟指针的<code>anchorPoint</code>做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>清单3.2<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#10;&#123;&#10;    [super viewDidLoad];&#10;    // adjust anchor points&#10;&#10;    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &#10;    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &#10;    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);&#10;&#10;&#10;    // start timer&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://i1.tietuku.com/e93155e73f1094dd.jpg"></p>
<p>图3.7 钟面，和正确对齐的钟指针</p>
<h2 id="坐标系">坐标系</h2><p>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的<code>position</code>依赖于它父图层的<code>bounds</code>，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的<em>绝对</em>位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。</p>
<p><code>CALayer</code>给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<pre><code><span class="tag">-</span> (<span class="tag">CGPoint</span>)<span class="rule"><span class="attribute">convertPoint</span>:<span class="value">(CGPoint)point fromLayer:(CALayer *)layer</span></span>; 
<span class="tag">-</span> (<span class="tag">CGPoint</span>)<span class="rule"><span class="attribute">convertPoint</span>:<span class="value">(CGPoint)point toLayer:(CALayer *)layer</span></span>; 
<span class="tag">-</span> (<span class="tag">CGRect</span>)<span class="rule"><span class="attribute">convertRect</span>:<span class="value">(CGRect)rect fromLayer:(CALayer *)layer</span></span>;
<span class="tag">-</span> (<span class="tag">CGRect</span>)<span class="rule"><span class="attribute">convertRect</span>:<span class="value">(CGRect)rect toLayer:(CALayer *)layer</span></span>;
</code></pre><p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<h3 id="翻转的几何结构">翻转的几何结构</h3><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个<code>BOOL</code>类型。在iOS上通过设置它为<code>YES</code>意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的<code>geometryFlipped</code>属性也设为<code>YES</code>）。</p>
<h3 id="Z坐标轴">Z坐标轴</h3><p>和<code>UIView</code>严格的二维坐标系不同，<code>CALayer</code>存在于一个三维空间当中。除了我们已经讨论过的<code>position</code>和<code>anchorPoint</code>属性之外，<code>CALayer</code>还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更<em>深</em>的属性来描述由宽和高做成的<code>bounds</code>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p><code>zPosition</code>属性在大多数情况下其实并不常用。在第五章，我们将会涉及<code>CATransform3D</code>，你会知道如何在三维空间移动和旋转图层，除了做变换之外，<code>zPosition</code>最实用的功能就是改变图层的<em>显示顺序</em>了。</p>
<p>通常，图层是根据它们子图层的<code>sublayers</code>出现的顺序来类绘制的，这就是所谓的<em>画家的算法</em>—就像一个画家在墙上作画—后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的<code>zPosition</code>，就可以把图层向相机方向<em>前置</em>，于是它就在所有其他图层的<em>前面</em>了（或者至少是小于它的<code>zPosition</code>值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="http://i1.tietuku.com/f648365a2b676b41.jpg"></p>
<p>图3.8 在视图层级中绿色视图被绘制在红色视图的后面</p>
<p>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的<code>zPosition</code>（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给<code>zPosition</code>提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>清单3.3</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *greenView;&#10;@property (nonatomic, weak) IBOutlet UIView *redView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    &#65532;&#10;    //move the green view zPosition nearer to the camera&#10;    self.greenView.layer.zPosition = 1.0f;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/5bc7eba82db3b159.jpg"></p>
<p>图3.9 绿色视图被绘制在红色视图的前面</p>
<h2 id="Hit_Testing">Hit Testing</h2><p>第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p><code>CALayer</code>并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<p><code>-containsPoint:</code>接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层<code>frame</code>范围内就返回<code>YES</code>。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用<code>-containsPoint:</code>方法来判断到底是白色还是蓝色的图层被触摸了<br>（图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>清单3.4 使用containsPoint判断被点击的图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView;&#10;@property (nonatomic, weak) CALayer *blueLayer;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create sublayer&#10;    self.blueLayer = [CALayer layer];&#10;    self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);&#10;    self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;&#10;    //add it to our view&#10;    [self.layerView.layer addSublayer:self.blueLayer];&#10;&#125;&#10;&#10;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#10;&#123;&#10;    //get touch position relative to main view&#10;    CGPoint point = [[touches anyObject] locationInView:self.view];&#10;    //convert point to the white layer&#39;s coordinates&#10;    point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];&#10;    //get layer using containsPoint:&#10;    if ([self.layerView.layer containsPoint:point]) &#123;&#10;        //convert point to blueLayer&#8217;s coordinates&#10;        point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];&#10;        if ([self.blueLayer containsPoint:point]) &#123;&#10;            [[[UIAlertView alloc] initWithTitle:@&#34;Inside Blue Layer&#34; &#10;                                        message:nil&#10;                                       delegate:nil &#10;                              cancelButtonTitle:@&#34;OK&#34;&#10;                              otherButtonTitles:nil] show];&#10;        &#125; else &#123;&#10;            [[[UIAlertView alloc] initWithTitle:@&#34;Inside White Layer&#34;&#10;                                        message:nil &#10;                                       delegate:nil&#10;                              cancelButtonTitle:@&#34;OK&#34;&#10;                              otherButtonTitles:nil] show];&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/163d32eb250cae4f.jpg"></p>
<p>图3.10 点击图层被正确标识</p>
<p><code>-hitTest:</code>方法同样接受一个<code>CGPoint</code>类型参数，而不是<code>BOOL</code>类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用<code>-containsPoint:</code>那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用<code>-hitTest:</code>方法被点击图层的代码如清单3.5所示。</p>
<p>清单3.5 使用hitTest判断被点击的图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#10;&#123;&#10;    //get touch position&#10;    CGPoint point = [[touches anyObject] locationInView:self.view];&#10;    //get touched layer&#10;    CALayer *layer = [self.layerView.layer hitTest:point];&#10;    //get layer using hitTest&#10;    if (layer == self.blueLayer) &#123;&#10;        [[[UIAlertView alloc] initWithTitle:@&#34;Inside Blue Layer&#34;&#10;                                    message:nil&#10;                                   delegate:nil&#10;                          cancelButtonTitle:@&#34;OK&#34;&#10;                          otherButtonTitles:nil] show];&#10;    &#125; else if (layer == self.layerView.layer) &#123;&#10;        [[[UIAlertView alloc] initWithTitle:@&#34;Inside White Layer&#34;&#10;                                    message:nil&#10;                                   delegate:nil&#10;                          cancelButtonTitle:@&#34;OK&#34;&#10;                          otherButtonTitles:nil] show];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的<code>zPosition</code>值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<h2 id="自动布局">自动布局</h2><p>你可能用过<code>UIViewAutoresizingMask</code>类型的一些常量，应用于当父视图改变尺寸的时候，相应<code>UIView</code>的<code>frame</code>也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了<em>自动排版</em>机制，它和自动调整不同，并且更加复杂。</p>
<p>在Mac OS平台，<code>CALayer</code>有一个叫做<code>layoutManager</code>的属性可以通过<code>CALayoutManager</code>协议和<code>CAConstraintLayoutManager</code>类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用<code>UIView</code>类接口暴露出来的<code>UIViewAutoresizingMask</code>和<code>NSLayoutConstraint</code>API，但如果想随意控制<code>CALayer</code>的布局，就需要手工操作。最简单的方法就是使用<code>CALayerDelegate</code>如下函数：</p>
<pre><code><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">layoutSublayersOfLayer</span>:<span class="value">(CALayer *)layer</span></span>;
</code></pre><p>当图层的<code>bounds</code>发生改变，或者图层的<code>-setNeedsLayout</code>方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像<code>UIView</code>的<code>autoresizingMask</code>和<code>constraints</code>属性做到自适应屏幕旋转。</p>
<p>这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。</p>
<h2 id="总结">总结</h2><p>本章涉及了<code>CALayer</code>的集合结构，包括它的<code>frame</code>，<code>position</code>和<code>bounds</code>，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-14T04:54:11.000Z"><a href="/2015/04/14/辅助编程技能/git问题汇总/">2015-04-14</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/14/辅助编程技能/git问题汇总/">git问题汇总</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="2015-04-14_12:54:43">2015-04-14 12:54:43</h3><h4 id="问题描述">问题描述</h4><p>使用git add添加要提交的文件的时候，如果文件名是中文，会显示形如274\232\350\256\256\346\200\273\347\273\223.png的乱码。</p>
<h4 id="解决方案">解决方案</h4><p>在终端输入    </p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">global</span> core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="说明">说明</h4><p>core.quotepath设为false的话，就不会对0×80以上的字符进行quote。中文显示正常。  </p>
<h4 id="问题描述-1">问题描述</h4><p>在MsysGit中，使用git log显示提交的中文log乱码。</p>
<h4 id="解决方案-1">解决方案</h4><p>设置git gui的界面编码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global gui<span class="class">.encoding</span> utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>设置 commit log 提交时使用 utf-8 编码，可避免服务器上乱码，同时与linux上的提交保持一致！</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n<span class="class">.commitencoding</span> utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>使得在 <code>$ git log</code> 时将 utf-8 编码转换成 gbk 编码，解决Msys bash中git log 乱码。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n<span class="class">.logoutputencoding</span> gbk</span><br></pre></td></tr></table></figure>
<p>使得 git log 可以正常显示中文（配合i18n.logoutputencoding = gbk)，在 /etc/profile 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LESSCHARSET=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="问题描述-2">问题描述</h4><p>在MsysGit自带的bash中，使用ls命令查看中文文件名乱码。cygwin没有这个问题。  </p>
<h4 id="解决方案-2">解决方案</h4><p>使用 <code>lls --show-control-chars</code> 命令来强制使用控制台字符编码显示文件名，即可查看中文文件名。</p>
<p>为了方便使用，可以编辑 <code>/etc/git-completion.bash</code> ，新增一行 <code>alias ls=&quot;ls --show-control-chars&quot;</code>  </p>
<p>参考地址:<a href="http://www.cnblogs.com/perseus/archive/2012/11/21/2781074.html" target="_blank" rel="external">http://www.cnblogs.com/perseus/archive/2012/11/21/2781074.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-14T03:03:13.000Z"><a href="/2015/04/14/主页维护记录/网站错误解决日志/">2015-04-14</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/14/主页维护记录/网站错误解决日志/">网站错误解决日志</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="时间">时间</h2><h3 id=""> </h3><h2 id="时间_2015-04-14_11:10:43">时间 2015-04-14 11:10:43</h2><h3 id="问题描述">问题描述</h3><p>今天使用 hexo 部署到 git 的时候,报错:  </p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Error: <span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span>@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line"><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span><span class="variable">@@</span>@</span><br><span class="line">Permissions <span class="number">0777</span> <span class="keyword">for</span> <span class="string">'/Users/katsura/.ssh/id_rsa'</span> are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">bad permissions: ignore key: /Users/katsura/.ssh/id_rsa</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository <span class="keyword">exists</span>.</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/Users/katsura/Git/guiqingblog.github.io/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:<span class="number">42</span>:<span class="number">17</span>)</span><br><span class="line">    at ChildProcess.<span class="keyword">emit</span> (events.js:<span class="number">98</span>:<span class="number">17</span>)</span><br><span class="line">    at maybeClose (child_process.js:<span class="number">766</span>:<span class="number">16</span>)</span><br><span class="line">    at Socket.&lt;anonymous&gt; (child_process.js:<span class="number">979</span>:<span class="number">11</span>)</span><br><span class="line">    at Socket.<span class="keyword">emit</span> (events.js:<span class="number">95</span>:<span class="number">17</span>)</span><br><span class="line">    at Pipe.close (net.js:<span class="number">466</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/14/主页维护记录/网站错误解决日志/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-13T14:25:14.000Z"><a href="/2015/04/13/iOS&OC/UIApplication-tips/">2015-04-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/13/iOS&OC/UIApplication-tips/">UIApplication tips -给新手的笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="UIApplication_对象是应用程序的象征">UIApplication 对象是应用程序的象征</h3><p>每一个应用程序都有自己的 UIApplication对象,而且是单例的.<br>通过 [UIApplication sharedApplication]可以获得这个单例对象<br>一个iOS程序启动后创建的第一个对象就是 UIApplication 对象<br>一个iOS程序启动后创建的第一个对象就是 UIApplication 对象<br>利用 UIApplication 对象,能进行一些应用级别的操作 </p>
<p>验证单例操作:  </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIApplication</span> *app  = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">    <span class="built_in">UIApplication</span> *app2 = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">    <span class="built_in">UIApplication</span> *app3 = [[<span class="built_in">UIApplication</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p,%p,%p"</span>,app,app2,app3);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/13/iOS&OC/UIApplication-tips/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/categories/Swift进阶/">Swift进阶</a><small>1</small></li>
  
    <li><a href="/categories/iOS-OC/">iOS&amp;OC</a><small>11</small></li>
  
    <li><a href="/categories/主页维护记录/">主页维护记录</a><small>3</small></li>
  
    <li><a href="/categories/应用架构/">应用架构</a><small>2</small></li>
  
    <li><a href="/categories/开发环境相关/">开发环境相关</a><small>1</small></li>
  
    <li><a href="/categories/开发环境配置/">开发环境配置</a><small>1</small></li>
  
    <li><a href="/categories/知识技巧总结/">知识技巧总结</a><small>2</small></li>
  
    <li><a href="/categories/辅助编程技能/">辅助编程技能</a><small>5</small></li>
  
    <li><a href="/categories/高效OC编程/">高效OC编程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/tags/Swift-进阶/">Swift 进阶</a><small>1</small></li>
  
    <li><a href="/tags/主页维护记录/">主页维护记录</a><small>1</small></li>
  
    <li><a href="/tags/小脚本大智慧/">小脚本大智慧</a><small>1</small></li>
  
    <li><a href="/tags/正则表达式/">正则表达式</a><small>2</small></li>
  
    <li><a href="/tags/测试小样/">测试小样</a><small>1</small></li>
  
    <li><a href="/tags/辅助编程技能/">辅助编程技能</a><small>2</small></li>
  
    <li><a href="/tags/问题解决和思考/">问题解决和思考</a><small>5</small></li>
  
    <li><a href="/tags/高效OC编程/">高效OC编程</a><small>4</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 桂庆
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>