<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 6 页 | Kenny 肉桂的主页</title>
  <meta name="author" content="桂庆">
  
  <meta name="description" content="Kenny 肉桂的主页 记录自己的进步">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Kenny 肉桂的主页"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kenny 肉桂的主页" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Kenny 肉桂的主页</a></h1>
  <h2><a href="/">记录自己的进步</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/about">关于我</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-21T01:32:52.000Z"><a href="/2015/04/21/Core Aniamtion深入探讨/5-变换/变换/">2015-04-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/21/Core Aniamtion深入探讨/5-变换/变换/">5-变换</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="变换">变换</h1><blockquote>
<p><em>很不幸，没人能告诉你母体是什么，你只能自己体会</em> — 骇客帝国</p>
</blockquote>
<p>在第四章“可视效果”中，我们研究了一些增强图层和它的内容显示效果的一些技术，在这一章中，我们将要研究可以用来对图层旋转，摆放或者扭曲的<code>CGAffineTransform</code>，以及可以将扁平物体转换成三维空间对象的<code>CATransform3D</code>（而不是仅仅对圆角矩形添加下沉阴影）。</p>
<h2 id="仿射变换">仿射变换</h2><p>在第三章“图层几何学”中，我们使用了<code>UIView</code>的<code>transform</code>属性旋转了钟的指针，但并没有解释背后运作的原理，实际上<code>UIView</code>的<code>transform</code>属性是一个<code>CGAffineTransform</code>类型，用于在二维空间做旋转，缩放和平移。<code>CGAffineTransform</code>是一个可以和二维空间向量（例如<code>CGPoint</code>）做乘法的3X2的矩阵（见图5.1）。</p>
<p><img src="http://i1.tietuku.com/adb6d030a880b185.jpg"></p>
<p>图5.1 用矩阵表示的<code>CGAffineTransform</code>和<code>CGPoint</code></p>
<p>用<code>CGPoint</code>的每一列和<code>CGAffineTransform</code>矩阵的每一行对应元素相乘再求和，就形成了一个新的<code>CGPoint</code>类型的结果。要解释一下图中显示的灰色元素，为了能让矩阵做乘法，左边矩阵的列数一定要和右边矩阵的行数个数相同，所以要给矩阵填充一些标志值，使得既可以让矩阵做乘法，又不改变运算结果，并且没必要存储这些添加的值，因为它们的值不会发生变化，但是要用来做运算。</p>
<p>因此，通常会用3×3（而不是2×3）的矩阵来做二维变换，你可能会见到3行2列格式的矩阵，这是所谓的以列为主的格式，图5.1所示的是以行为主的格式，只要能保持一致，用哪种格式都无所谓。</p>
<p>当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。<code>CGAffineTransform</code>中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行，<code>CGAffineTransform</code>可以做出任意符合上述标注的变换，图5.2显示了一些仿射的和非仿射的变换：</p>
<p><img src="http://i1.tietuku.com/efa605e116f25bcf.jpg"></p>
<p>图5.2 仿射和非仿射变换</p>
<h3 id="创建一个CGAffineTransform">创建一个<code>CGAffineTransform</code></h3><p>对矩阵数学做一个全面的阐述就超出本书的讨论范围了，不过如果你对矩阵完全不熟悉的话，矩阵变换可能会使你感到畏惧。幸运的是，Core Graphics提供了一系列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个<code>CGAffineTransform</code>实例：</p>
<pre><code><span class="function"><span class="title">CGAffineTransformMakeRotation</span><span class="params">(CGFloat angle)</span></span> 
<span class="function"><span class="title">CGAffineTransformMakeScale</span><span class="params">(CGFloat sx, CGFloat sy)</span></span>
<span class="function"><span class="title">CGAffineTransformMakeTranslation</span><span class="params">(CGFloat tx, CGFloat ty)</span></span>
</code></pre><p>旋转和缩放变换都可以很好解释—分别旋转或者缩放一个向量的值。平移变换是指每个点都移动了向量指定的x或者y值—所以如果向量代表了一个点，那它就平移了这个点的距离。</p>
<p>我们用一个很简单的项目来做个demo，把一个原始视图旋转45度角度（图5.3）</p>
<p><img src="http://i1.tietuku.com/070f74e3ec457111.jpg"></p>
<p>图5.3 使用仿射变换旋转45度角之后的视图</p>
<p><code>UIView</code>可以通过设置<code>transform</code>属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p><code>CALayer</code>同样也有一个<code>transform</code>属性，但它的类型是<code>CATransform3D</code>，而不是<code>CGAffineTransform</code>，本章后续将会详细解释。<code>CALayer</code>对应于<code>UIView</code>的<code>transform</code>属性叫做<code>affineTransform</code>，清单5.1的例子就是使用<code>affineTransform</code>对图层做了45度顺时针旋转。</p>
<p>清单5.1 使用<code>affineTransform</code>对图层旋转45度<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees&#10;    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>注意我们使用的旋转常量是<code>M_PI_4</code>，而不是你想象的45，因为iOS的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。</p>
<p>C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，<code>M_PI_4</code>于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">RADIANS_TO_DEGREES</span><span class="params">(x)</span></span> ((x)/M_PI*<span class="number">180.0</span>) 
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">DEGREES_TO_RADIANS</span><span class="params">(x)</span></span> ((x)/<span class="number">180.0</span>*M_PI)
</code></pre><h3 id="混合变换">混合变换</h3><p>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要<em>缩放</em>又要<em>旋转</em>的变换，这就会非常有用了。例如下面几个函数：</p>
<pre><code><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> angle)     
<span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)      
<span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)
</code></pre><p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要—也就是创建一个<code>CGAffineTransform</code>类型的空值，矩阵论中称作<em>单位矩阵</em>，Core Graphics同样也提供了一个方便的常量：</p>
<pre><code><span class="built_in">CGAffineTransformIdentity</span>
</code></pre><p>最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：</p>
<pre><code><span class="built_in">CGAffineTransformConcat</span>(<span class="built_in">CGAffineTransform</span> t1, <span class="built_in">CGAffineTransform</span> t2);
</code></pre><p>我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。</p>
<p>清单5.2 使用若干方法创建一个复合变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad]; //create a new transform&#10;    CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%&#10;    transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees&#10;    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //translate by 200 points&#10;    transform = CGAffineTransformTranslate(transform, 200, 0);&#10;    //apply transform to layer&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1ea93463a1d07eaa.jpg"></p>
<p>图5.4 顺序应用多个仿射变换之后的结果</p>
<p>图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<h3 id="剪切变换">剪切变换</h3><p>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置<code>CGAffineTransform</code>的值。除非需要创建一个<em>斜切</em>的变换，Core Graphics并没有提供直接的函数。</p>
<p>斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。</p>
<p><img src="http://i1.tietuku.com/c7d96f71ed1c7751.jpg"></p>
<p>图5.5 水平方向的斜切变换</p>
<p>清单5.3 实现一个斜切变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)&#10;&#123;&#10;    CGAffineTransform transform = CGAffineTransformIdentity;&#10;    transform.c = -x;&#10;    transform.b = y;&#10;    return transform;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //shear the layer at a 45-degree angle&#10;    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<h2 id="3D变换">3D变换</h2><p>CG的前缀告诉我们，<code>CGAffineTransform</code>类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且<code>CGAffineTransform</code>仅仅对2D变换有效。</p>
<p>在第三章中，我们提到了<code>zPosition</code>属性，可以用来让图层靠近或者远离相机（用户视角），<code>transform</code>属性（<code>CATransform3D</code>类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。</p>
<p>和<code>CGAffineTransform</code>类似，<code>CATransform3D</code>也是一个矩阵，但是和2x3的矩阵不同，<code>CATransform3D</code>是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。</p>
<p><img src="http://i1.tietuku.com/a1ea53bd4112cdd0.png"></p>
<p>图5.6 对一个3D像素点做<code>CATransform3D</code>矩阵变换</p>
<p>和<code>CGAffineTransform</code>矩阵类似，Core Animation提供了一系列的方法用来创建和组合<code>CATransform3D</code>类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个<code>z</code>参数，并且旋转函数除了<code>angle</code>之外多出了<code>x</code>,<code>y</code>,<code>z</code>三个参数，分别决定了每个坐标轴方向上的旋转：</p>
<pre><code><span class="built_in">CATransform3DMakeRotation</span>(<span class="built_in">CGFloat</span> angle, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> z)
<span class="built_in">CATransform3DMakeScale</span>(<span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy, <span class="built_in">CGFloat</span> sz) 
<span class="built_in">CATransform3DMakeTranslation</span>(Gloat tx, <span class="built_in">CGFloat</span> ty, <span class="built_in">CGFloat</span> tz)
</code></pre><p>你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7）。</p>
<p><img src="http://i1.tietuku.com/c6b630ab7aa08924.jpg"></p>
<p>图5.7 X，Y，Z轴，以及围绕它们旋转的方向</p>
<p>由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>
<p>举个例子：清单5.4的代码使用了<code>CATransform3DMakeRotation</code>对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。</p>
<p>结果见图5.8，但并不像我们期待的那样。</p>
<p>清单5.4 绕Y轴旋转图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees along the Y axis&#10;    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/d033b9cb3cc6e390.jpg"></p>
<p>图5.8 绕y轴旋转45度的视图</p>
<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？</p>
<p>其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是<em>透视</em>。</p>
<h3 id="透视投影">透视投影</h3><p>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入<em>投影变换</em>（又称作<em>z变换</em>）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p><code>CATransform3D</code>的透视效果通过一个矩阵中一个很简单的元素来控制：<code>m34</code>。<code>m34</code>（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><img src="http://i1.tietuku.com/d6160e8602e6a4ce.jpg"></p>
<p>图5.9 <code>CATransform3D</code>的<code>m34</code>元素，用来做透视</p>
<p><code>m34</code>的默认值是0，我们可以通过设置<code>m34</code>为-1.0 / <code>d</code>来应用透视效果，<code>d</code>代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的防止的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。</p>
<p>清单5.5 对变换应用透视效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create a new transform&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    //apply perspective&#10;    transform.m34 = - 1.0 / 500.0;&#10;    //rotate by 45 degrees along the Y axis&#10;    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);&#10;    //apply to layer&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/c2ecbd5db5454204.jpg"></p>
<p>图5.10 应用透视效果之后再次对图层做旋转</p>
<h3 id="灭点">灭点</h3><p>当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><img src="http://i1.tietuku.com/efe4aebcddaef0d0.png"></p>
<p>图5.11 灭点</p>
<p>Core Animation定义了这个点位于变换图层的<code>anchorPoint</code>（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前<code>anchorPoint</code>的位置。</p>
<p>当改变一个图层的<code>position</code>，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整<code>m34</code>来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的<code>position</code>），这样所有的3D图层都共享一个灭点。</p>
<h3 id="sublayerTransform属性"><code>sublayerTransform</code>属性</h3><p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个<code>position</code>，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。</p>
<p><code>CALayer</code>有一个属性叫做<code>sublayerTransform</code>。它也是<code>CATransform3D</code>类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在<em>容器图层</em>的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用<code>position</code>和<code>frame</code>来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p>我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。</p>
<p><img src="http://i1.tietuku.com/1dff7af353fc1e09.jpg"></p>
<p>图5.12 在一个视图容器内并排放置两个视图</p>
<p>清单5.6 应用<code>sublayerTransform</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //apply perspective transform to container&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = - 1.0 / 500.0;&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //rotate layerView1 by 45 degrees along the Y axis&#10;    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView1.layer.transform = transform1;&#10;    //rotate layerView2 by 45 degrees along the Y axis&#10;    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);&#10;    self.layerView2.layer.transform = transform2;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/6d6a571f355e1889.jpg"></p>
<p>图5.13 通过相同的透视效果分别对视图做变换</p>
<h3 id="背面">背面</h3><p>我们既然可以在3D场景下旋转图层，那么也可以从<em>背面</em>去观察它。如果我们在清单5.4中把角度修改为<code>M_PI</code>（180度）而不是当前的<code>M_PI_4</code>（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。</p>
<p>那么从背部看图层是什么样的呢，见图5.14</p>
<p><img src="http://i1.tietuku.com/d256c892ff0ee21a.jpg"></p>
<p>图5.14 视图的背面，一个镜像对称的图片</p>
<p>如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p><code>CALayer</code>有一个叫做<code>doubleSided</code>的属性来控制图层的背面是否要被绘制。这是一个<code>BOOL</code>类型，默认为<code>YES</code>，如果设置为<code>NO</code>，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<h3 id="扁平化图层">扁平化图层</h3><p>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15</p>
<p><img src="http://i1.tietuku.com/cfb668bfe041f088.jpg"></p>
<p>图5.15 反方向变换的嵌套图层</p>
<p>注意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。</p>
<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>
<p>验证一下，相应代码见清单5.7，结果见5.16</p>
<p>清单5.7 绕Z轴做相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *outerView;&#10;@property (nonatomic, weak) IBOutlet UIView *innerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);&#10;    self.innerView.layer.transform = inner;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/0d4804a3dc9fd31a.jpg"></p>
<p>图5.16 旋转后的视图</p>
<p>运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用<code>sublayerTransform</code>属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。</p>
<p>清单5.8 绕Y轴相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DIdentity;&#10;    outer.m34 = -1.0 / 500.0;&#10;    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DIdentity;&#10;    inner.m34 = -1.0 / 500.0;&#10;    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);&#10;    self.innerView.layer.transform = inner;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>预期的效果应该如图5.17所示。</p>
<p><img src="http://i1.tietuku.com/92f50e93fb3ac918.jpg"></p>
<p>图5.17 绕Y轴做相反旋转的预期结果。</p>
<p>但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。</p>
<p>这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在<em>同一个</em>3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p><img src="http://i1.tietuku.com/7781e04efefb13e7.jpg"></p>
<p>图5.18 绕Y轴做相反旋转的真实结果</p>
<p>类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系—在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的<code>CALayer</code>的时候是这样，<code>CALayer</code>有一个叫做<code>CATransformLayer</code>的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。</p>
<h2 id="固体对象">固体对象</h2><p>现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的<em>空洞</em>对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。</p>
<p>在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。</p>
<p><img src="http://i1.tietuku.com/5b91ab29ab27a4e7.jpg"></p>
<p>图5.19 用Interface Builder对立方体的六个面进行布局</p>
<p>这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的<code>transform</code>对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。</p>
<p>我们把一个有颜色的<code>UILabel</code>放置在视图内部，是为了清楚的辨别它们之间的关系，并且<code>UIButton</code>被放置在第三个面视图里面，后面会做简单的解释。</p>
<p>具体把视图组织成立方体的代码见清单5.9，结果见图5.20</p>
<p>清单5.9 创建一个立方体</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees&#10;    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>注意我们使用的旋转常量是<code>M_PI_4</code>，而不是你想象的45，因为iOS的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。</p>
<p>C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，<code>M_PI_4</code>于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：</p>
<pre><code><span class="hexcolor">#def</span>ine <span class="function"><span class="title">RADIANS_TO_DEGREES</span><span class="params">(x)</span></span> ((x)/M_PI*<span class="number">180.0</span>) 
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">DEGREES_TO_RADIANS</span><span class="params">(x)</span></span> ((x)/<span class="number">180.0</span>*M_PI)
</code></pre><h3 id="混合变换-1">混合变换</h3><p>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要<em>缩放</em>又要<em>旋转</em>的变换，这就会非常有用了。例如下面几个函数：</p>
<pre><code><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> angle)     
<span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)      
<span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)
</code></pre><p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要—也就是创建一个<code>CGAffineTransform</code>类型的空值，矩阵论中称作<em>单位矩阵</em>，Core Graphics同样也提供了一个方便的常量：</p>
<pre><code><span class="built_in">CGAffineTransformIdentity</span>
</code></pre><p>最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：</p>
<pre><code><span class="built_in">CGAffineTransformConcat</span>(<span class="built_in">CGAffineTransform</span> t1, <span class="built_in">CGAffineTransform</span> t2);
</code></pre><p>我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。</p>
<p>清单5.2 使用若干方法创建一个复合变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad]; //create a new transform&#10;    CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%&#10;    transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees&#10;    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //translate by 200 points&#10;    transform = CGAffineTransformTranslate(transform, 200, 0);&#10;    //apply transform to layer&#10;    self.layerView.layer.affineTransform = transform;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1ea93463a1d07eaa.jpg"></p>
<p>图5.4 顺序应用多个仿射变换之后的结果</p>
<p>图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<h3 id="剪切变换-1">剪切变换</h3><p>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置<code>CGAffineTransform</code>的值。除非需要创建一个<em>斜切</em>的变换，Core Graphics并没有提供直接的函数。</p>
<p>斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。</p>
<p><img src="http://i1.tietuku.com/c7d96f71ed1c7751.jpg"></p>
<p>图5.5 水平方向的斜切变换</p>
<p>清单5.3 实现一个斜切变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)&#10;&#123;&#10;    CGAffineTransform transform = CGAffineTransformIdentity;&#10;    transform.c = -x;&#10;    transform.b = y;&#10;    return transform;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //shear the layer at a 45-degree angle&#10;    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<h2 id="3D变换-1">3D变换</h2><p>CG的前缀告诉我们，<code>CGAffineTransform</code>类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且<code>CGAffineTransform</code>仅仅对2D变换有效。</p>
<p>在第三章中，我们提到了<code>zPosition</code>属性，可以用来让图层靠近或者远离相机（用户视角），<code>transform</code>属性（<code>CATransform3D</code>类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。</p>
<p>和<code>CGAffineTransform</code>类似，<code>CATransform3D</code>也是一个矩阵，但是和2x3的矩阵不同，<code>CATransform3D</code>是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。</p>
<p><img src="./5.6.jpeg" alt="图5.6" title="图5.6" width="700"></p>
<p>图5.6 对一个3D像素点做<code>CATransform3D</code>矩阵变换</p>
<p>和<code>CGAffineTransform</code>矩阵类似，Core Animation提供了一系列的方法用来创建和组合<code>CATransform3D</code>类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个<code>z</code>参数，并且旋转函数除了<code>angle</code>之外多出了<code>x</code>,<code>y</code>,<code>z</code>三个参数，分别决定了每个坐标轴方向上的旋转：</p>
<pre><code><span class="built_in">CATransform3DMakeRotation</span>(<span class="built_in">CGFloat</span> angle, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> z)
<span class="built_in">CATransform3DMakeScale</span>(<span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy, <span class="built_in">CGFloat</span> sz) 
<span class="built_in">CATransform3DMakeTranslation</span>(Gloat tx, <span class="built_in">CGFloat</span> ty, <span class="built_in">CGFloat</span> tz)
</code></pre><p>你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7）。</p>
<p><img src="./5.7.jpeg" alt="图5.7" title="图5.7" width="700"></p>
<p>图5.7 X，Y，Z轴，以及围绕它们旋转的方向</p>
<p>由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>
<p>举个例子：清单5.4的代码使用了<code>CATransform3DMakeRotation</code>对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。</p>
<p>结果见图5.8，但并不像我们期待的那样。</p>
<p>清单5.4 绕Y轴旋转图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the layer 45 degrees along the Y axis&#10;    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="./5.8.jpeg" alt="图5.8" title="图5.8" width="700"></p>
<p>图5.8 绕y轴旋转45度的视图</p>
<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？</p>
<p>其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是<em>透视</em>。</p>
<h3 id="透视投影-1">透视投影</h3><p>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入<em>投影变换</em>（又称作<em>z变换</em>）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p><code>CATransform3D</code>的透视效果通过一个矩阵中一个很简单的元素来控制：<code>m34</code>。<code>m34</code>（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><img src="./5.9.jpeg" alt="图5.9" title="图5.9" width="700"></p>
<p>图5.9 <code>CATransform3D</code>的<code>m34</code>元素，用来做透视</p>
<p><code>m34</code>的默认值是0，我们可以通过设置<code>m34</code>为-1.0 / <code>d</code>来应用透视效果，<code>d</code>代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的放置的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小或者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。</p>
<p>清单5.5 对变换应用透视效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create a new transform&#10;    CATransform3D transform = CATransform3DIdentity;&#10;    //apply perspective&#10;    transform.m34 = - 1.0 / 500.0;&#10;    //rotate by 45 degrees along the Y axis&#10;    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);&#10;    //apply to layer&#10;    self.layerView.layer.transform = transform;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="./5.10.jpeg" alt="图5.10" title="图5.10" width="700"></p>
<p>图5.10 应用透视效果之后再次对图层做旋转</p>
<h3 id="灭点-1">灭点</h3><p>当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><img src="./5.11.jpeg" alt="图5.11" title="图5.11" width="700"></p>
<p>图5.11 灭点</p>
<p>Core Animation定义了这个点位于变换图层的<code>anchorPoint</code>（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前<code>anchorPoint</code>的位置。</p>
<p>当改变一个图层的<code>position</code>，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整<code>m34</code>来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的<code>position</code>），这样所有的3D图层都共享一个灭点。</p>
<h3 id="sublayerTransform属性-1"><code>sublayerTransform</code>属性</h3><p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个<code>position</code>，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。</p>
<p><code>CALayer</code>有一个属性叫做<code>sublayerTransform</code>。它也是<code>CATransform3D</code>类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在<em>容器图层</em>的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用<code>position</code>和<code>frame</code>来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p>我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。</p>
<p><img src="./5.12.jpeg" alt="图5.12" title="图5.12" width="700"></p>
<p>图5.12 在一个视图容器内并排放置两个视图</p>
<p>清单5.6 应用<code>sublayerTransform</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //apply perspective transform to container&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = - 1.0 / 500.0;&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //rotate layerView1 by 45 degrees along the Y axis&#10;    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);&#10;    self.layerView1.layer.transform = transform1;&#10;    //rotate layerView2 by 45 degrees along the Y axis&#10;    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);&#10;    self.layerView2.layer.transform = transform2;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./5.13.jpeg" alt="图5.13" title="图5.13" width="700"></p>
<p>图5.13 通过相同的透视效果分别对视图做变换</p>
<h3 id="背面-1">背面</h3><p>我们既然可以在3D场景下旋转图层，那么也可以从<em>背面</em>去观察它。如果我们在清单5.4中把角度修改为<code>M_PI</code>（180度）而不是当前的<code>M_PI_4</code>（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。</p>
<p>那么从背部看图层是什么样的呢，见图5.14</p>
<p><img src="./5.14.jpeg" alt="图5.14" title="图5.14" width="700"></p>
<p>图5.14 视图的背面，一个镜像对称的图片</p>
<p>如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p><code>CALayer</code>有一个叫做<code>doubleSided</code>的属性来控制图层的背面是否要被绘制。这是一个<code>BOOL</code>类型，默认为<code>YES</code>，如果设置为<code>NO</code>，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<h3 id="扁平化图层-1">扁平化图层</h3><p>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15</p>
<p><img src="./5.15.jpeg" alt="图5.15" title="图5.15" width="700"></p>
<p>图5.15 反方向变换的嵌套图层</p>
<p>注意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。</p>
<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>
<p>验证一下，相应代码见清单5.7，结果见5.16</p>
<p>清单5.7 绕Z轴做相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *outerView;&#10;@property (nonatomic, weak) IBOutlet UIView *innerView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);&#10;    self.innerView.layer.transform = inner;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="./5.16.jpeg" alt="图5.16" title="图5.16" width="700"></p>
<p>图5.16 旋转后的视图</p>
<p>运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用<code>sublayerTransform</code>属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。</p>
<p>清单5.8 绕Y轴相反的旋转变换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //rotate the outer layer 45 degrees&#10;    CATransform3D outer = CATransform3DIdentity;&#10;    outer.m34 = -1.0 / 500.0;&#10;    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);&#10;    self.outerView.layer.transform = outer;&#10;    //rotate the inner layer -45 degrees&#10;    CATransform3D inner = CATransform3DIdentity;&#10;    inner.m34 = -1.0 / 500.0;&#10;    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);&#10;    self.innerView.layer.transform = inner;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>预期的效果应该如图5.17所示。</p>
<p><img src="./5.17.jpeg" alt="图5.17" title="图5.17" width="700"></p>
<p>图5.17 绕Y轴做相反旋转的预期结果。</p>
<p>但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。</p>
<p>这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在<em>同一个</em>3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p><img src="./5.18.jpeg" alt="图5.18" title="图5.18" width="700"></p>
<p>图5.18 绕Y轴做相反旋转的真实结果</p>
<p>类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系—在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的<code>CALayer</code>的时候是这样，<code>CALayer</code>有一个叫做<code>CATransformLayer</code>的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。</p>
<h2 id="固体对象-1">固体对象</h2><p>现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的<em>空洞</em>对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。</p>
<p>在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。</p>
<p><img src="./5.19.jpeg" alt="图5.19" title="图5.19" width="700"></p>
<p>图5.19 用Interface Builder对立方体的六个面进行布局</p>
<p>这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的<code>transform</code>对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。</p>
<p>我们把一个有颜色的<code>UILabel</code>放置在视图内部，是为了清楚的辨别它们之间的关系，并且<code>UIButton</code>被放置在第三个面视图里面，后面会做简单的解释。</p>
<p>具体把视图组织成立方体的代码见清单5.9，结果见图5.20</p>
<p>清单5.9 创建一个立方体</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform&#10;&#123;&#10;    //get the face view and add it to the container&#10;    UIView *face = self.faces[index];&#10;    [self.containerView addSubview:face];&#10;    //center the face view within the container&#10;    CGSize containerSize = self.containerView.bounds.size;&#10;    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);&#10;    // apply the transform&#10;    face.layer.transform = transform;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //set up the container sublayer transform&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = -1.0 / 500.0;&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //add cube face 1&#10;    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);&#10;    [self addFace:0 withTransform:transform];&#10;    //add cube face 2&#10;    transform = CATransform3DMakeTranslation(100, 0, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);&#10;    [self addFace:1 withTransform:transform];&#10;    //add cube face 3&#10;    transform = CATransform3DMakeTranslation(0, -100, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);&#10;    [self addFace:2 withTransform:transform];&#10;    //add cube face 4&#10;    transform = CATransform3DMakeTranslation(0, 100, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);&#10;    [self addFace:3 withTransform:transform];&#10;    //add cube face 5&#10;    transform = CATransform3DMakeTranslation(-100, 0, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);&#10;    [self addFace:4 withTransform:transform];&#10;    //add cube face 6&#10;    transform = CATransform3DMakeTranslation(0, 0, -100);&#10;    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);&#10;    [self addFace:5 withTransform:transform];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/6eb66c57fcdc0d1d.jpg"></p>
<p>图5.20 正面朝上的立方体</p>
<p>从这个角度看立方体并不是很明显；看起来只是一个方块，为了更好地欣赏它，我们将更换一个<em>不同的视角</em>。</p>
<p>旋转这个立方体将会显得很笨重，因为我们要单独对每个面做旋转。另一个简单的方案是通过调整容器视图的<code>sublayerTransform</code>去旋转<em>照相机</em>。</p>
<p>添加如下几行去旋转<code>containerView</code>图层的<code>perspective</code>变换矩阵：</p>
<pre><code>perspective = CATra<span class="label">nsform3</span>DRotate<span class="comment">(perspective, -M_PI_4, 1, 0, 0)</span>; 
perspective = CATra<span class="label">nsform3</span>DRotate<span class="comment">(perspective, -M_PI_4, 0, 1, 0)</span>;
</code></pre><p>这就对相机（或者相对相机的整个场景，你也可以这么认为）绕Y轴旋转45度，并且绕X轴旋转45度。现在从另一个角度去观察立方体，就能看出它的真实面貌（图5.21）。</p>
<p><img src="http://i1.tietuku.com/fefaf7cd35c56492.jpg"></p>
<p>图5.21 从一个边角观察的立方体</p>
<h3 id="光亮和阴影">光亮和阴影</h3><p>现在它看起来更像是一个立方体没错了，但是对每个面之间的连接还是很难分辨。Core Animation可以用3D显示图层，但是它对<em>光线</em>并没有概念。如果想让立方体看起来更加真实，需要自己做一个阴影效果。你可以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。</p>
<p>如果需要<em>动态</em>地创建光线效果，你可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，你需要得到每个面的<em>正太向量</em>（垂直于表面的向量），然后根据一个想象的光源计算出两个向量<em>叉乘</em>结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</p>
<p>清单5.10实现了这样一个结果，我们用GLKit框架来做向量的计算（你需要引入GLKit库来运行代码），每个面的<code>CATransform3D</code>都被转换成<code>GLKMatrix4</code>，然后通过<code>GLKMatrix4GetMatrix3</code>函数得出一个3×3的<em>旋转矩阵</em>。这个旋转矩阵指定了图层的方向，然后可以用它来得到正太向量的值。</p>
<p>结果如图5.22所示，试着调整<code>LIGHT_DIRECTION</code>和<code>AMBIENT_LIGHT</code>的值来切换光线效果</p>
<p>清单5.10 对立方体的表面应用动态的光线效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34; &#10;#import &#60;QuartzCore/QuartzCore.h&#62; &#10;#import &#60;GLKit/GLKit.h&#62;&#10;&#10;#define LIGHT_DIRECTION 0, 1, -0.5 &#10;#define AMBIENT_LIGHT 0.5&#10;&#10;@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)applyLightingToFace:(CALayer *)face&#10;&#123;&#10;    //add lighting layer&#10;    CALayer *layer = [CALayer layer];&#10;    layer.frame = face.bounds;&#10;    [face addSublayer:layer];&#10;    //convert the face transform to matrix&#10;    //(GLKMatrix4 has the same structure as CATransform3D)&#10;    //&#35793;&#32773;&#27880;&#65306;GLKMatrix4&#21644;CATransform3D&#20869;&#23384;&#32467;&#26500;&#19968;&#33268;&#65292;&#20294;&#22352;&#26631;&#31867;&#22411;&#26377;&#38271;&#24230;&#21306;&#21035;&#65292;&#25152;&#20197;&#29702;&#35770;&#19978;&#24212;&#35813;&#20570;&#19968;&#27425;float&#21040;CGFloat&#30340;&#36716;&#25442;&#65292;&#24863;&#35874;[@zihuyishi](https://github.com/zihuyishi)&#21516;&#23398;~&#10;    CATransform3D transform = face.transform;&#10;    GLKMatrix4 matrix4 = *(GLKMatrix4 *)&#38;transform;&#10;    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);&#10;    //get face normal&#10;    GLKVector3 normal = GLKVector3Make(0, 0, 1);&#10;    normal = GLKMatrix3MultiplyVector3(matrix3, normal);&#10;    normal = GLKVector3Normalize(normal);&#10;    //get dot product with light direction&#10;    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));&#10;    float dotProduct = GLKVector3DotProduct(light, normal);&#10;    //set lighting layer opacity&#10;    CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;&#10;    UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];&#10;    layer.backgroundColor = color.CGColor;&#10;&#125;&#10;&#10;- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform&#10;&#123;&#10;    //get the face view and add it to the container&#10;    UIView *face = self.faces[index];&#10;    [self.containerView addSubview:face];&#10;    //center the face view within the container&#10;    CGSize containerSize = self.containerView.bounds.size;&#10;    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);&#10;    // apply the transform&#10;    face.layer.transform = transform;&#10;    //apply lighting&#10;    [self applyLightingToFace:face.layer];&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //set up the container sublayer transform&#10;    CATransform3D perspective = CATransform3DIdentity;&#10;    perspective.m34 = -1.0 / 500.0;&#10;    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);&#10;    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);&#10;    self.containerView.layer.sublayerTransform = perspective;&#10;    //add cube face 1&#10;    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);&#10;    [self addFace:0 withTransform:transform];&#10;    //add cube face 2&#10;    transform = CATransform3DMakeTranslation(100, 0, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);&#10;    [self addFace:1 withTransform:transform];&#10;    //add cube face 3&#10;    transform = CATransform3DMakeTranslation(0, -100, 0);&#10;    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);&#10;    [self addFace:2 withTransform:transform];&#10;    //add cube face 4&#10;    transform = CATransform3DMakeTranslation(0, 100, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);&#10;    [self addFace:3 withTransform:transform];&#10;    //add cube face 5&#10;    transform = CATransform3DMakeTranslation(-100, 0, 0);&#10;    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);&#10;    [self addFace:4 withTransform:transform];&#10;    //add cube face 6&#10;    transform = CATransform3DMakeTranslation(0, 0, -100);&#10;    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);&#10;    [self addFace:5 withTransform:transform];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/bf9c09e6dcc75155.jpg"></p>
<p>图5.22 动态计算光线效果之后的立方体</p>
<h3 id="点击事件">点击事件</h3><p>你应该能注意到现在可以在第三个表面的顶部看见按钮了，点击它，什么都没发生，为什么呢？</p>
<p>这并不是因为iOS在3D场景下正确地处理响应事件，实际上是可以做到的。问题在于<em>视图顺序</em>。在第三章中我们简要提到过，点击事件的处理由视图在父视图中的顺序决定的，并不是3D空间中的Z轴顺序。当给立方体添加视图的时候，我们实际上是按照一个顺序添加，所以按照视图/图层顺序来说，4，5，6在3的前面。</p>
<p>即使我们看不见4，5，6的表面（因为被1，2，3遮住了），iOS在事件响应上仍然保持之前的顺序。当试图点击表面3上的按钮，表面4，5，6截断了点击事件（取决于点击的位置），这就和普通的2D布局在按钮上覆盖物体一样。</p>
<p>你也许认为把<code>doubleSided</code>设置成<code>NO</code>可以解决这个问题，因为它不再渲染视图后面的内容，但实际上并不起作用。因为背对相机而隐藏的视图仍然会响应点击事件（这和通过设置<code>hidden</code>属性或者设置<code>alpha</code>为0而隐藏的视图不同，那两种方式将不会响应事件）。所以即使禁止了双面渲染仍然不能解决这个问题（虽然由于性能问题，还是需要把它设置成<code>NO</code>）。</p>
<p>这里有几种正确的方案：把除了表面3的其他视图<code>userInteractionEnabled</code>属性都设置成<code>NO</code>来禁止事件传递。或者简单通过代码把视图3覆盖在视图6上。无论怎样都可以点击按钮了（图5.23）。</p>
<p><img src="http://i1.tietuku.com/1096c5e277cf7dd9.jpg"></p>
<p>图5.23 背景视图不再阻碍按钮，我们可以点击它了</p>
<h2 id="总结">总结</h2><p>这一章涉及了一些2D和3D的变换。你学习了一些矩阵计算的基础，以及如何用Core Animation创建3D场景。你看到了图层背后到底是如何呈现的，并且知道了不能把扁平的图片做成真实的立体效果，最后我们用demo说明了触摸事件的处理，视图中图层添加的层级顺序会比屏幕上显示的顺序更有意义。</p>
<p>第六章我们会研究一些Core Animation提供不同功能的具体的<code>CALayer</code>子类。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-18T07:33:48.000Z"><a href="/2015/04/18/iOS Tips/MJExtention-对不规范-JSON-解析的一个测试/">2015-04-18</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/18/iOS Tips/MJExtention-对不规范-JSON-解析的一个测试/">MJExtention 对不规范 JSON 解析的一个测试</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Context">Context</h2><p>今天受 MJ 老师吩咐,测试 MJExtension 对于不规范的 JSON 的解析情况.特记录于此 </p>
<h2 id="说明几点">说明几点</h2><h3 id="何为不规范">何为不规范</h3><p>我说的不规则指的是有一定容错能力,但是前提还是 JSON,弄些乱七八糟的字符串就没有意义了哈.比如说,这次我想测试的是前一段事件遇到的一个小问题:服务端返回的是类似这样的一个结果:  </p>
<p><img src="http://ww1.sinaimg.cn/large/9e446dffjw1er9qrf2g2hj206608vaad.jpg"></p>
<p>为了展现,截图是规范的 JSON,服务端给我的实际数据是:<br>两个箭头指向处还有 <code>&quot;</code>  .</p>
<p><img src="http://ww2.sinaimg.cn/large/9e446dffjw1er9ql5uocrj206k08sq3c.jpg">  </p>
<p>换句话说,他是严格执行的: <code>&quot;键&quot;:&quot;无论啥类型&quot;</code> . 网上大多数的所谓的 JSON 格式校验工具认为这种格式是 okay 的,但是它的问题是,没法继续”钻下去” ,这里就是我所说的 “不规范”.<br>说到这里,推荐个地址 <a href="http://tool.oschina.net/codeformat/json">在线校验</a>,这个不仅仅是校验,还有格式化功能.支持按层级折叠和展开.</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/18/iOS Tips/MJExtention-对不规范-JSON-解析的一个测试/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-17T01:32:52.000Z"><a href="/2015/04/17/Core Aniamtion深入探讨/4-视觉效果/4-视觉效果/">2015-04-17</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/17/Core Aniamtion深入探讨/4-视觉效果/4-视觉效果/">4-视觉效果</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="视觉效果">视觉效果</h1><blockquote>
<p>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢？</p>
<p>我们现在能做到那样了么？</p>
<p>史蒂芬·乔布斯</p>
</blockquote>
<p>我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。</p>
<h2 id="圆角">圆角</h2><p>圆角矩形是iOS的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。</p>
<p>CALayer有一个叫做<code>conrnerRadius</code>的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会被截取。</p>
<p>我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)</p>
<p><img src="http://i1.tietuku.com/3a95761f3df03285.png"></p>
<p>图4.1 两个白色的大视图，他们都包含了小一些的红色视图。</p>
<p>然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果</p>
<p>清单4.1 设置<code>cornerRadius</code>和<code>masksToBounds</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;- (void)viewDidLoad&#10;&#123;&#65532;&#65532;&#65532;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/dc9050c13c4b29c0.png"></p>
<p>右图中，红色的子视图沿角半径被裁剪了</p>
<p>如你所见，右边的子视图沿边界被裁剪了。</p>
<p>单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者是CAShapeLayer（见第六章『专用图层』）。</p>
<h2 id="图层边框">图层边框</h2><p>CALayer另外两个非常有用属性就是<code>borderWidth</code>和<code>borderColor</code>。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的<code>bounds</code>绘制，同时也包含图层的角。</p>
<p><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0.<code>borderColor</code>定义了边框的颜色，默认为黑色。</p>
<p><code>borderColor</code>是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了<code>borderColor</code>，虽然属性声明并不能证明这一点。<code>CGColorRef</code>在引用/释放时候的行为表现得与<code>NSObject</code>极其相似。但是Objective-C语法并不支持这一做法，所以<code>CGColorRef</code>属性即便是强引用也只能通过assign关键字来声明。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.</p>
<p>清单4.2 加上边框</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //add a border to our layers&#10;  self.layerView1.layer.borderWidth = 5.0f;&#10;  self.layerView2.layer.borderWidth = 5.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/36dc54ae201277f2.png"></p>
<p>图4.3 给图层增加一个边框</p>
<p>仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.</p>
<p><img src="http://i1.tietuku.com/86e5c09f8cf07c10.png"></p>
<p>图4.4 边框是跟随图层的边界变化的，而不是图层里面的内容</p>
<h2 id="阴影">阴影</h2><p>iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</p>
<p>给<code>shadowOpacity</code>属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。<code>shadowOpacity</code>是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：<code>shadowColor</code>，<code>shadowOffset</code>和<code>shadowRadius</code>。</p>
<p>显而易见，<code>shadowColor</code>属性控制着阴影的颜色，和<code>borderColor</code>和<code>backgroundColor</code>一样，它的类型也是<code>CGColorRef</code>。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</p>
<p><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个<code>CGSize</code>的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。<code>shadowOffset</code>的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p>为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，<code>shadowOffset</code>的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.</p>
<p><img src="http://i1.tietuku.com/7db986fe34f3b61a.png"></p>
<p>图4.5 在iOS（左）和Mac OS（右）上<code>shadowOffset</code>的表现。</p>
<p>苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>
<p><code>shadowRadius</code>属性控制着阴影的<em>模糊度</em>，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。</p>
<p>通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给<code>shadowRadius</code>设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.</p>
<p><img src="http://i1.tietuku.com/be6b969406fb888a.png"></p>
<p>图4.6 大一些的阴影位移和角半径会增加图层的深度即视感</p>
<h2 id="阴影裁剪">阴影裁剪</h2><p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。</p>
<p><img src="http://i1.tietuku.com/f3cbc8b39c5d0031.png"></p>
<p>图4.7 阴影是根据寄宿图的轮廓来确定的</p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了<code>masksToBounds</code>属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.</p>
<p><img src="http://i1.tietuku.com/3beca24155d015a1.png"></p>
<p>图4.8 <code>maskToBounds</code>属性裁剪掉了阴影和内容</p>
<p>从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用<code>masksToBounds</code>裁剪内容的内图层。</p>
<p>如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.</p>
<p><img src="http://i1.tietuku.com/7760492f8e8ba8bf.png"></p>
<p>图4.9 右边，用额外的阴影转换视图包裹被裁剪的视图</p>
<p>我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。</p>
<p>清单4.3 用一个额外的视图来解决阴影裁切的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;@property (nonatomic, weak) IBOutlet UIView *shadowView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#65532;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //set the corner radius on our layers&#10;  self.layerView1.layer.cornerRadius = 20.0f;&#10;  self.layerView2.layer.cornerRadius = 20.0f;&#10;&#10;  //add a border to our layers&#10;  self.layerView1.layer.borderWidth = 5.0f;&#10;  self.layerView2.layer.borderWidth = 5.0f;&#10;&#10;  //add a shadow to layerView1&#10;  self.layerView1.layer.shadowOpacity = 0.5f;&#10;  self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&#10;  self.layerView1.layer.shadowRadius = 5.0f;&#10;&#10;  //add same shadow to shadowView (not layerView2)&#10;  self.shadowView.layer.shadowOpacity = 0.5f;&#10;  self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&#10;  self.shadowView.layer.shadowRadius = 5.0f;&#10;&#10;  //enable clipping on the second layer&#10;  self.layerView2.layer.masksToBounds = YES;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/346b0e2ad8ae09d7.png"></p>
<p>图4.10 右边视图，不受裁切阴影的阴影视图。</p>
<h2 id="shadowPath属性"><code>shadowPath</code>属性</h2><p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<code>shadowPath</code>是一个<code>CGPathRef</code>类型（一个指向<code>CGPath</code>的指针）。<code>CGPath</code>是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<p>图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。</p>
<p><img src="http://i1.tietuku.com/2799e67d09602635.png"></p>
<p>图4.11 用<code>shadowPath</code>指定任意阴影形状</p>
<p>清单4.4 创建简单的阴影形状</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView1;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView2;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //enable layer shadows&#10;  self.layerView1.layer.shadowOpacity = 0.5f;&#10;  self.layerView2.layer.shadowOpacity = 0.5f;&#10;&#10;  //create a square shadow&#10;  CGMutablePathRef squarePath = CGPathCreateMutable();&#10;  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);&#10;  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);&#10;&#10;  &#65532;//create a circular shadow&#10;  CGMutablePathRef circlePath = CGPathCreateMutable();&#10;  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);&#10;  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>如果是一个矩形或者是圆，用<code>CGPath</code>会相当简单明了。但是如果是更加复杂一点的图形，<code>UIBezierPath</code>类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<h2 id="图层蒙板">图层蒙板</h2><p>通过<code>masksToBounds</code>属性，我们可以沿边界裁剪图形；通过<code>cornerRadius</code>属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个属性叫做<code>mask</code>可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
<p><code>mask</code>图层的<code>Color</code>属性是无关紧要的，真正重要的是图层的轮廓。<code>mask</code>属性就像是一个饼干切割机，<code>mask</code>图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）</p>
<p>如果<code>mask</code>图层比父图层要小，只有在<code>mask</code>图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p><img src="http://i1.tietuku.com/3123be453a267e1d.png"></p>
<p>图4.12 把图片和蒙板图层作用在一起的效果</p>
<p>我们将代码演示一下这个过程，创建一个简单的项目，通过图层的<code>mask</code>属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。</p>
<p>清单4.5 应用蒙板图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIImageView *imageView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create mask layer&#10;  CALayer *maskLayer = [CALayer layer];&#10;  maskLayer.frame = self.layerView.bounds;&#10;  UIImage *maskImage = [UIImage imageNamed:@&#34;Cone.png&#34;];&#10;  maskLayer.contents = (__bridge id)maskImage.CGImage;&#10;&#10;  //apply mask to image layer&#65532;&#10;  self.imageView.layer.mask = maskLayer;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/91a010e3dcb3e549.png"></p>
<p>图4.13 使用了<code>mask</code>之后的UIImageView</p>
<p>CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为<code>mask</code>属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。</p>
<h2 id="拉伸过滤">拉伸过滤</h2><p>最后我们再来谈谈<code>minificationFilter</code>和<code>magnificationFilter</code>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。</p>
<p>当图片需要显示不同的大小的时候，有一种叫做<em>拉伸过滤</em>的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
<p>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。<code>CALayer</code>为此提供了三种拉伸过滤方法，他们是：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。</p>
<p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<p><img src="http://i1.tietuku.com/362db4f8519bde1d.png"></p>
<p>图4.14 对于大图来说，双线性滤波和三线性滤波表现得更出色</p>
<p><code>kCAFilterNearest</code>是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>
<p><img src="http://i1.tietuku.com/79c8bfe9549efe33.png"></p>
<p>图4.15 对于没有斜线的小图来说，最近过滤算法要好很多</p>
<p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<p>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。</p>
<p><img src="http://i1.tietuku.com/c5d07147325d611e.png"></p>
<p>图4.16 一个简单的运用拼合技术显示的LCD数字风格的像素字体</p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个<code>IBOutletCollection</code>对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。</p>
<p><img src="http://i1.tietuku.com/6d751b3556c52024.png"><br>图4.17</p>
<p>清单4.6 显示一个LCD风格的时钟</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;&#10;@property (nonatomic, weak) NSTimer *timer;&#10;&#65532;&#65532;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //get spritesheet image&#10;  UIImage *digits = [UIImage imageNamed:@&#34;Digits.png&#34;];&#10;&#10;  //set up digit views&#10;  for (UIView *view in self.digitViews) &#123;&#10;    //set contents&#10;    view.layer.contents = (__bridge id)digits.CGImage;&#10;    view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);&#10;    view.layer.contentsGravity = kCAGravityResizeAspect;&#10;  &#125;&#10;&#10;  //start timer&#10;  self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&#10;&#10;  //set initial clock time&#10;  [self tick];&#10;&#125;&#10;&#10;- (void)setDigit:(NSInteger)digit forView:(UIView *)view&#10;&#123;&#10;  //adjust contentsRect to select correct digit&#10;  view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);&#10;&#125;&#10;&#10;- (void)tick&#10;&#123;&#10;  //convert time to hours, minutes and seconds&#10;  NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];&#10;  NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&#10;  &#65532;&#10;  NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&#10;&#10;  //set hours&#10;  [self setDigit:components.hour / 10 forView:self.digitViews[0]];&#10;  [self setDigit:components.hour % 10 forView:self.digitViews[1]];&#10;&#10;  //set minutes&#10;  [self setDigit:components.minute / 10 forView:self.digitViews[2]];&#10;  [self setDigit:components.minute % 10 forView:self.digitViews[3]];&#10;&#10;  //set seconds&#10;  [self setDigit:components.second / 10 forView:self.digitViews[4]];&#10;  [self setDigit:components.second % 10 forView:self.digitViews[5]];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>如图4.18，这样做的确起了效果，但是图片看起来模糊了。看起来默认的<code>kCAFilterLinear</code>选项让我们失望了。</p>
<p><img src="http://i1.tietuku.com/9907966a7840c64a.png"></p>
<p>图4.18 一个模糊的时钟，由默认的<code>kCAFilterLinear</code>引起</p>
<p>为了能像图4.19中那样，我们需要在for循环中加入如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.magnificationFilter = kCAFilterNearest;</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/7acc929bf7f74628.png"></p>
<p>图4.19 设置了最近过滤之后的清晰显示</p>
<h2 id="组透明">组透明</h2><p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了<code>opacity</code>属性，那它的子图层都会受此影响。</p>
<p>iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p><img src="http://i1.tietuku.com/9d67bc29e9634724.png"></p>
<p>图4.20 右边的渐隐按钮中，里面的标签清晰可见</p>
<p>这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的<code>UIViewGroupOpacity</code>为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果<code>UIViewGroupOpacity</code>并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做<code>shouldRasterize</code>属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。</p>
<p>为了启用<code>shouldRasterize</code>属性，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当<code>shouldRasterize</code>和<code>UIViewGroupOpacity</code>一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。</p>
<p>清单4.7 使用<code>shouldRasterize</code>属性解决组透明问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;@property (nonatomic, weak) IBOutlet UIView *containerView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (UIButton *)customButton&#10;&#123;&#10;  //create button&#10;  CGRect frame = CGRectMake(0, 0, 150, 50);&#10;  UIButton *button = [[UIButton alloc] initWithFrame:frame];&#10;  button.backgroundColor = [UIColor whiteColor];&#10;  button.layer.cornerRadius = 10;&#10;&#10;  //add label&#10;  frame = CGRectMake(20, 10, 110, 30);&#10;  UILabel *label = [[UILabel alloc] initWithFrame:frame];&#10;  label.text = @&#34;Hello World&#34;;&#10;  label.textAlignment = NSTextAlignmentCenter;&#10;  [button addSubview:label];&#10;  return button;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;&#10;  //create opaque button&#10;  UIButton *button1 = [self customButton];&#10;  button1.center = CGPointMake(50, 150);&#10;  [self.containerView addSubview:button1];&#10;&#10;  //create translucent button&#10;  UIButton *button2 = [self customButton];&#10;  &#65532;&#10;  button2.center = CGPointMake(250, 150);&#10;  button2.alpha = 0.5;&#10;  [self.containerView addSubview:button2];&#10;&#10;  //enable rasterization for the translucent button&#10;  button2.layer.shouldRasterize = YES;&#10;  button2.layer.rasterizationScale = [UIScreen mainScreen].scale;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1cdd82c2af9c9a89.png"></p>
<p>图4.21 修正后的图</p>
<h2 id="总结">总结</h2><p>这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。</p>
<p>在第五章，『变换』中，我们将会研究图层变化和3D转换。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T04:58:58.000Z"><a href="/2015/04/15/主页维护记录/博客成长记/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/主页维护记录/博客成长记/">博客成长记</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="加入评论功能">加入评论功能</h2><p><em>2015-04-15 12:59:49</em>   </p>
<ol>
<li><p>使用微博或者其他帐号登录<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>,建立自己的一个帐号,同时拿到通用代码.    </p>
</li>
<li><p>取消HEXO博客根目录中的 <code>_config.yml</code> 中 <code>disqus_shortname:</code> ，暂时不用这个功能，直接永久开启多说评论。</p>
</li>
<li><p>修改主题目录下面的(我的是 <code>/themes/jacman/_config.ym</code> ) <code>_config.yml</code> 中的 </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### Comment&#10;duoshuo_shortname: guiqingblog    ## e.g. wuchong   your duoshuo short name.</span><br></pre></td></tr></table></figure>
<p>如果没有请添加.   </p>
<ol>
<li>修改 <code>themes\XXX\layout_partial\article.ejs</code><br>在最后加上下面的代码:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;% if(!index)&#123; %&#62;&#10;&#60;%- partial(&#39;comment&#39;) %&#62;&#10;&#60;% &#125; %&#62;</span><br></pre></td></tr></table></figure>
<ol>
<li>修改 <code>themes/jacman/layout/_partial/post/comment.ejs</code> 为你通用代码的 js 部分,如果没有这个文件请新建.</li>
</ol>
<p>最终效果:  </p>
<p><img src="http://ww3.sinaimg.cn/large/9e446dffjw1er66il80t3j20mp09ujs8.jpg"></p>
<p>参考网址:  </p>
<p><a href="http://gpio.me/hexo-duoshuo.html" target="_blank" rel="external">http://gpio.me/hexo-duoshuo.html</a><br><a href="http://duoshuo.com" target="_blank" rel="external">http://duoshuo.com</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T04:47:38.000Z"><a href="/2015/04/15/iOS Tips/在类的头文件中尽量少引入其他头文件/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/iOS Tips/在类的头文件中尽量少引入其他头文件/">高效OC编程-在类的头文件中尽量少引入其他头文件</a></h1>
  

    </header>
    <div class="entry">
      
        <p>与C 和C++ 一样，Objective-C 也使用“头文件”（header file） 与“实现文件”（implementation file）来区隔代码。用Objective-C 语言编写“类”（class）的标准方式为：以类名做文件名，分别创建两个文件，头文件后缀用.h，实现文件后缀用.m。创建好一个类之后，其代码看上去如下所示:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// EOCPerson.h&#10;#import &#60;Foundation/Foundation.h&#62;&#10;@interface EOCPerson : NSObject&#10;@property (nonatomic, copy) NSString *firstName;&#10;@property (nonatomic, copy) NSString *lastName;&#10;@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// EOCPerson.m&#10;#import &#34;EOCPerson.h&#34;&#10;@implementation EOCPerson&#10;// Implementation of methods&#10;@end</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/15/iOS Tips/在类的头文件中尽量少引入其他头文件/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-15T01:32:52.000Z"><a href="/2015/04/15/Core Aniamtion深入探讨/3-图层几何学/图层几何学/">2015-04-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/15/Core Aniamtion深入探讨/3-图层几何学/图层几何学/">3-图层几何学</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="图层几何学">图层几何学</h1><blockquote>
<p><em>不熟悉几何学的人就不要来这里了</em> —柏拉图学院入口的签名</p>
</blockquote>
<p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<h2 id="布局">布局</h2><p><code>UIView</code>有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，<code>CALayer</code>对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p><code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>所在的位置。<code>anchorPoint</code>的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="http://i1.tietuku.com/71af11930be4457f.jpg" alt="图3.1" title="图3.1" width="700"></p>
<p>图3.1 <code>UIView</code>和<code>CALayer</code>的坐标系</p>
<p>视图的<code>frame</code>，<code>bounds</code>和<code>center</code>属性仅仅是<em>存取方法</em>，当操纵视图的<code>frame</code>，实际上是在改变位于视图下方<code>CALayer</code>的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<p>对于视图或者图层来说，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，<code>frame</code>实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说<code>frame</code>的宽高可能和<code>bounds</code>的宽高不再一致了（图3.2）</p>
<p><img src="http://i1.tietuku.com/b3cc087d8701c6c4.jpg"></p>
<p>图3.2 旋转一个视图或者图层之后的<code>frame</code>属性</p>
<h2 id="锚点">锚点</h2><p>之前提到过，视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置，你可以认为<code>anchorPoint</code>是用来移动图层的<em>把柄</em>。</p>
<p>默认来说，<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。<code>anchorPoint</code>属性并没有被<code>UIView</code>接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的<code>anchorPoint</code>可以被移动，比如你可以把它置于图层<code>frame</code>的左上角，于是图层的内容将会向右下角的<code>position</code>方向移动（图3.3），而不是居中了。</p>
<p><img src="http://i1.tietuku.com/cd0b18512266f4e8.jpg"></p>
<p>图3.3 改变<code>anchorPoint</code>的效果</p>
<p>和第二章提到的<code>contentsRect</code>和<code>contentsCenter</code>属性类似，<code>anchorPoint</code>用<em>单位坐标</em>来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。<code>anchorPoint</code>可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了<code>anchorPoint</code>，<code>position</code>属性保持固定的值并没有发生改变，但是<code>frame</code>却移动了。</p>
<p>那在什么场合需要改变<code>anchorPoint</code>呢？既然我们可以随意改变图层位置，那改变<code>anchorPoint</code>不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个<code>UIImageView</code>实例（当然你也可以用正常的视图，设置他们图层的<code>contents</code>图片）。</p>
<p><img src="http://i1.tietuku.com/4cf92548d6313258.jpg"></p>
<p>图3.4 组成钟面和钟表的四张图片</p>
<p>闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的<code>frame</code>，而根据图3.2的演示，当视图旋转的时候，<code>frame</code>是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用<code>NSTimer</code>来更新闹钟，使用视图的<code>transform</code>属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="http://i1.tietuku.com/2eb6826a87ecce6b.jpg"></p>
<p>图3.5 在Interface Builder中布局闹钟视图</p>
<p>清单3.1 <strong>Clock</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIImageView *hourHand;&#10;@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;&#10;@property (nonatomic, weak) IBOutlet UIImageView *secondHand;&#10;@property (nonatomic, weak) NSTimer *timer;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //start timer&#10;    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&#10;                  &#65532;&#10;    //set initial hand positions&#10;    [self tick];&#10;&#125;&#10;&#10;- (void)tick&#10;&#123;&#10;    //convert time to hours, minutes and seconds&#10;    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];&#10;    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&#10;    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&#10;    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;&#10;    //calculate hour hand angle //calculate minute hand angle&#10;    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;&#10;    //calculate second hand angle&#10;    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;&#10;    //rotate hands&#10;    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);&#10;    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);&#10;    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。</p>
<p><img src="http://i1.tietuku.com/8718ca04ee738767.jpg"></p>
<p>图3.6 钟面，和不对齐的钟指针</p>
<p>你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用<code>anchorPoint</code>属性，我们来在<code>-viewDidLoad</code>方法中添加几行代码来给每个钟指针的<code>anchorPoint</code>做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>清单3.2<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#10;&#123;&#10;    [super viewDidLoad];&#10;    // adjust anchor points&#10;&#10;    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &#10;    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &#10;    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);&#10;&#10;&#10;    // start timer&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://i1.tietuku.com/e93155e73f1094dd.jpg"></p>
<p>图3.7 钟面，和正确对齐的钟指针</p>
<h2 id="坐标系">坐标系</h2><p>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的<code>position</code>依赖于它父图层的<code>bounds</code>，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的<em>绝对</em>位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。</p>
<p><code>CALayer</code>给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<pre><code><span class="tag">-</span> (<span class="tag">CGPoint</span>)<span class="rule"><span class="attribute">convertPoint</span>:<span class="value">(CGPoint)point fromLayer:(CALayer *)layer</span></span>; 
<span class="tag">-</span> (<span class="tag">CGPoint</span>)<span class="rule"><span class="attribute">convertPoint</span>:<span class="value">(CGPoint)point toLayer:(CALayer *)layer</span></span>; 
<span class="tag">-</span> (<span class="tag">CGRect</span>)<span class="rule"><span class="attribute">convertRect</span>:<span class="value">(CGRect)rect fromLayer:(CALayer *)layer</span></span>;
<span class="tag">-</span> (<span class="tag">CGRect</span>)<span class="rule"><span class="attribute">convertRect</span>:<span class="value">(CGRect)rect toLayer:(CALayer *)layer</span></span>;
</code></pre><p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<h3 id="翻转的几何结构">翻转的几何结构</h3><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个<code>BOOL</code>类型。在iOS上通过设置它为<code>YES</code>意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的<code>geometryFlipped</code>属性也设为<code>YES</code>）。</p>
<h3 id="Z坐标轴">Z坐标轴</h3><p>和<code>UIView</code>严格的二维坐标系不同，<code>CALayer</code>存在于一个三维空间当中。除了我们已经讨论过的<code>position</code>和<code>anchorPoint</code>属性之外，<code>CALayer</code>还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更<em>深</em>的属性来描述由宽和高做成的<code>bounds</code>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p><code>zPosition</code>属性在大多数情况下其实并不常用。在第五章，我们将会涉及<code>CATransform3D</code>，你会知道如何在三维空间移动和旋转图层，除了做变换之外，<code>zPosition</code>最实用的功能就是改变图层的<em>显示顺序</em>了。</p>
<p>通常，图层是根据它们子图层的<code>sublayers</code>出现的顺序来类绘制的，这就是所谓的<em>画家的算法</em>—就像一个画家在墙上作画—后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的<code>zPosition</code>，就可以把图层向相机方向<em>前置</em>，于是它就在所有其他图层的<em>前面</em>了（或者至少是小于它的<code>zPosition</code>值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="http://i1.tietuku.com/f648365a2b676b41.jpg"></p>
<p>图3.8 在视图层级中绿色视图被绘制在红色视图的后面</p>
<p>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的<code>zPosition</code>（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给<code>zPosition</code>提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>清单3.3</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *greenView;&#10;@property (nonatomic, weak) IBOutlet UIView *redView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    &#65532;&#10;    //move the green view zPosition nearer to the camera&#10;    self.greenView.layer.zPosition = 1.0f;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/5bc7eba82db3b159.jpg"></p>
<p>图3.9 绿色视图被绘制在红色视图的前面</p>
<h2 id="Hit_Testing">Hit Testing</h2><p>第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p><code>CALayer</code>并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<p><code>-containsPoint:</code>接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层<code>frame</code>范围内就返回<code>YES</code>。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用<code>-containsPoint:</code>方法来判断到底是白色还是蓝色的图层被触摸了<br>（图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>清单3.4 使用containsPoint判断被点击的图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *layerView;&#10;@property (nonatomic, weak) CALayer *blueLayer;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    //create sublayer&#10;    self.blueLayer = [CALayer layer];&#10;    self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);&#10;    self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;&#10;    //add it to our view&#10;    [self.layerView.layer addSublayer:self.blueLayer];&#10;&#125;&#10;&#10;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#10;&#123;&#10;    //get touch position relative to main view&#10;    CGPoint point = [[touches anyObject] locationInView:self.view];&#10;    //convert point to the white layer&#39;s coordinates&#10;    point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];&#10;    //get layer using containsPoint:&#10;    if ([self.layerView.layer containsPoint:point]) &#123;&#10;        //convert point to blueLayer&#8217;s coordinates&#10;        point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];&#10;        if ([self.blueLayer containsPoint:point]) &#123;&#10;            [[[UIAlertView alloc] initWithTitle:@&#34;Inside Blue Layer&#34; &#10;                                        message:nil&#10;                                       delegate:nil &#10;                              cancelButtonTitle:@&#34;OK&#34;&#10;                              otherButtonTitles:nil] show];&#10;        &#125; else &#123;&#10;            [[[UIAlertView alloc] initWithTitle:@&#34;Inside White Layer&#34;&#10;                                        message:nil &#10;                                       delegate:nil&#10;                              cancelButtonTitle:@&#34;OK&#34;&#10;                              otherButtonTitles:nil] show];&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/163d32eb250cae4f.jpg"></p>
<p>图3.10 点击图层被正确标识</p>
<p><code>-hitTest:</code>方法同样接受一个<code>CGPoint</code>类型参数，而不是<code>BOOL</code>类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用<code>-containsPoint:</code>那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用<code>-hitTest:</code>方法被点击图层的代码如清单3.5所示。</p>
<p>清单3.5 使用hitTest判断被点击的图层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#10;&#123;&#10;    //get touch position&#10;    CGPoint point = [[touches anyObject] locationInView:self.view];&#10;    //get touched layer&#10;    CALayer *layer = [self.layerView.layer hitTest:point];&#10;    //get layer using hitTest&#10;    if (layer == self.blueLayer) &#123;&#10;        [[[UIAlertView alloc] initWithTitle:@&#34;Inside Blue Layer&#34;&#10;                                    message:nil&#10;                                   delegate:nil&#10;                          cancelButtonTitle:@&#34;OK&#34;&#10;                          otherButtonTitles:nil] show];&#10;    &#125; else if (layer == self.layerView.layer) &#123;&#10;        [[[UIAlertView alloc] initWithTitle:@&#34;Inside White Layer&#34;&#10;                                    message:nil&#10;                                   delegate:nil&#10;                          cancelButtonTitle:@&#34;OK&#34;&#10;                          otherButtonTitles:nil] show];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的<code>zPosition</code>值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<h2 id="自动布局">自动布局</h2><p>你可能用过<code>UIViewAutoresizingMask</code>类型的一些常量，应用于当父视图改变尺寸的时候，相应<code>UIView</code>的<code>frame</code>也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了<em>自动排版</em>机制，它和自动调整不同，并且更加复杂。</p>
<p>在Mac OS平台，<code>CALayer</code>有一个叫做<code>layoutManager</code>的属性可以通过<code>CALayoutManager</code>协议和<code>CAConstraintLayoutManager</code>类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用<code>UIView</code>类接口暴露出来的<code>UIViewAutoresizingMask</code>和<code>NSLayoutConstraint</code>API，但如果想随意控制<code>CALayer</code>的布局，就需要手工操作。最简单的方法就是使用<code>CALayerDelegate</code>如下函数：</p>
<pre><code><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">layoutSublayersOfLayer</span>:<span class="value">(CALayer *)layer</span></span>;
</code></pre><p>当图层的<code>bounds</code>发生改变，或者图层的<code>-setNeedsLayout</code>方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像<code>UIView</code>的<code>autoresizingMask</code>和<code>constraints</code>属性做到自适应屏幕旋转。</p>
<p>这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。</p>
<h2 id="总结">总结</h2><p>本章涉及了<code>CALayer</code>的集合结构，包括它的<code>frame</code>，<code>position</code>和<code>bounds</code>，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-14T04:54:11.000Z"><a href="/2015/04/14/辅助编程技能/git问题汇总/">2015-04-14</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/14/辅助编程技能/git问题汇总/">git问题汇总</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="2015-04-14_12:54:43">2015-04-14 12:54:43</h3><h4 id="问题描述">问题描述</h4><p>使用git add添加要提交的文件的时候，如果文件名是中文，会显示形如274\232\350\256\256\346\200\273\347\273\223.png的乱码。</p>
<h4 id="解决方案">解决方案</h4><p>在终端输入    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure>
<h4 id="说明">说明</h4><p>core.quotepath设为false的话，就不会对0×80以上的字符进行quote。中文显示正常。  </p>
<h4 id="问题描述-1">问题描述</h4><p>在MsysGit中，使用git log显示提交的中文log乱码。</p>
<h4 id="解决方案-1">解决方案</h4><p>设置git gui的界面编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global gui.encoding utf-8</span><br></pre></td></tr></table></figure>
<p>设置 commit log 提交时使用 utf-8 编码，可避免服务器上乱码，同时与linux上的提交保持一致！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br></pre></td></tr></table></figure>
<p>使得在 <code>$ git log</code> 时将 utf-8 编码转换成 gbk 编码，解决Msys bash中git log 乱码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n.logoutputencoding gbk</span><br></pre></td></tr></table></figure>
<p>使得 git log 可以正常显示中文（配合i18n.logoutputencoding = gbk)，在 /etc/profile 中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>
<h4 id="问题描述-2">问题描述</h4><p>在MsysGit自带的bash中，使用ls命令查看中文文件名乱码。cygwin没有这个问题。  </p>
<h4 id="解决方案-2">解决方案</h4><p>使用 <code>lls --show-control-chars</code> 命令来强制使用控制台字符编码显示文件名，即可查看中文文件名。</p>
<p>为了方便使用，可以编辑 <code>/etc/git-completion.bash</code> ，新增一行 <code>alias ls=&quot;ls --show-control-chars&quot;</code>  </p>
<p>参考地址:<a href="http://www.cnblogs.com/perseus/archive/2012/11/21/2781074.html" target="_blank" rel="external">http://www.cnblogs.com/perseus/archive/2012/11/21/2781074.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-14T03:03:13.000Z"><a href="/2015/04/14/主页维护记录/网站错误解决日志/">2015-04-14</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/14/主页维护记录/网站错误解决日志/">网站错误解决日志</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="时间">时间</h2><h3 id=""> </h3><h2 id="时间_2015-04-14_11:10:43">时间 2015-04-14 11:10:43</h2><h3 id="问题描述">问题描述</h3><p>今天使用 hexo 部署到 git 的时候,报错:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#10;@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @&#10;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#10;Permissions 0777 for &#39;/Users/katsura/.ssh/id_rsa&#39; are too open.&#10;It is required that your private key files are NOT accessible by others.&#10;This private key will be ignored.&#10;bad permissions: ignore key: /Users/katsura/.ssh/id_rsa&#10;Permission denied (publickey).&#10;fatal: Could not read from remote repository.&#10;&#10;Please make sure you have the correct access rights&#10;and the repository exists.&#10;&#10;    at ChildProcess.&#60;anonymous&#62; (/Users/katsura/Git/guiqingblog.github.io/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:42:17)&#10;    at ChildProcess.emit (events.js:98:17)&#10;    at maybeClose (child_process.js:766:16)&#10;    at Socket.&#60;anonymous&#62; (child_process.js:979:11)&#10;    at Socket.emit (events.js:95:17)&#10;    at Pipe.close (net.js:466:12)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/14/主页维护记录/网站错误解决日志/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-13T14:25:14.000Z"><a href="/2015/04/13/iOS Tips/UIApplication-tips/">2015-04-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/13/iOS Tips/UIApplication-tips/">UIApplication tips -给新手的笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="UIApplication_对象是应用程序的象征">UIApplication 对象是应用程序的象征</h3><p>每一个应用程序都有自己的 UIApplication对象,而且是单例的.<br>通过 [UIApplication sharedApplication]可以获得这个单例对象<br>一个iOS程序启动后创建的第一个对象就是 UIApplication 对象<br>一个iOS程序启动后创建的第一个对象就是 UIApplication 对象<br>利用 UIApplication 对象,能进行一些应用级别的操作 </p>
<p>验证单例操作:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;&#10;&#9;    [super viewDidLoad];&#10;    &#10;    UIApplication *app  = [UIApplication sharedApplication];&#10;    UIApplication *app2 = [UIApplication sharedApplication];&#10;    UIApplication *app3 = [[UIApplication alloc] init];&#10;    &#10;    NSLog(@&#34;%p,%p,%p&#34;,app,app2,app3);&#10;    &#10;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/04/13/iOS Tips/UIApplication-tips/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-13T01:32:52.000Z"><a href="/2015/04/13/Core Aniamtion深入探讨/2-寄宿图/寄宿图/">2015-04-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/13/Core Aniamtion深入探讨/2-寄宿图/寄宿图/">2-寄宿图</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="寄宿图">寄宿图</h1><blockquote>
<p>图片胜过千言万语，界面抵得上千图片  ——Ben Shneiderman</p>
</blockquote>
<p>我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。</p>
<h2 id="contents属性">contents属性</h2><p>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p>
<p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p>
<p>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。</p>
<p>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contents = (__bridge id)image.CGImage;</span><br></pre></td></tr></table></figure>
<p>如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p>
<p>让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的<code>contents</code>属性设置成图片。</p>
<p>清单2.1 更新后的代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //load an image&#10;  UIImage *image = [UIImage imageNamed:@&#34;Snowman.png&#34;];&#10;&#10;  //add it directly to our view&#39;s layer&#10;  self.layerView.layer.contents = (__bridge id)image.CGImage;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>图表2.1 在UIView的宿主图层中显示一张图片</p>
<p><img src="http://i1.tietuku.com/32c66c1156e89ff6.png"></p>
<p>我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。</p>
<p><strong>contentGravity</strong></p>
<p>你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把<code>contentMode</code>属性设置成更合适的值，像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.contentMode = UIViewContentModeScaleAspectFit;</span><br></pre></td></tr></table></figure>
<p>这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如<code>contentMode</code>，对这些属性的操作其实是对对应图层的操作。</p>
<p>CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。<code>contentsGravity</code>可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<p>和<code>cotentMode</code>一样，<code>contentsGravity</code>的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</span><br></pre></td></tr></table></figure>
<p>图2.2 可以看到结果</p>
<p><img src="http://i1.tietuku.com/e60dd08653489c05.png"></p>
<p>图2.2 正确地设置<code>contentsGravity</code>的值</p>
<h2 id="contentsScale">contentsScale</h2><p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p><code>contentsScale</code>的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为<code>contents</code>由于设置了<code>contentsGravity</code>属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的<code>contents</code>图片，你可以通过使用图层的<code>transform</code>和<code>affineTransform</code>属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是<code>contentsScale</code>的目的所在.</p>
<p><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置<code>contentsGravity</code>属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。</p>
<p>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。</p>
<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）</p>
<p><img src="http://i1.tietuku.com/265368df4b0dee5d.png"></p>
<p>图2.3 用错误的<code>contentsScale</code>属性显示Retina图片</p>
<p>如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置<code>contentsScale</code>来修复这个问题（如2.2清单），图2.4是结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //load an image&#10;  UIImage *image = [UIImage imageNamed:@&#34;Snowman.png&#34;]; //add it directly to our view&#39;s layer&#10;  self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image&#10;  self.layerView.layer.contentsGravity = kCAGravityCenter;&#10;&#10;  //set the contentsScale to match image&#10;  self.layerView.layer.contentsScale = image.scale;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/7ed03480b54336a5.png"></p>
<p>图2.4 同样的Retina图片设置了正确的<code>contentsScale</code>之后</p>
<p>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的<code>contentsScale</code>属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contentsScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>
<h2 id="maskToBounds">maskToBounds</h2><p>现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。</p>
<p>UIView有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code>，把它设置为YES，雪人就在边界里啦～（如图2.5）</p>
<p><img src="http://i1.tietuku.com/fd4ce0c4dd5a0cc1.png"></p>
<p>图2.5 使用<code>masksToBounds</code>来修建图层内容</p>
<h2 id="contentsRect">contentsRect</h2><p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比<code>contentsGravity</code>灵活多了</p>
<p>和<code>bounds</code>，<code>frame</code>不同，<code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<p>默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）</p>
<p><img src="http://i1.tietuku.com/87eb9c5c16057eb0.png"></p>
<p>图2.6 一个自定义的<code>contentsRect</code>（左）和之前显示的内容（右）</p>
<p>事实上给<code>contentsRect</code>设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p><code>contentsRect</code>在app中最有趣的地方在于一个叫做<em>image sprites</em>（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</p>
<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</p>
<p>2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用<code>contentsRect</code></p>
<p>首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：</p>
<p><img src="http://i1.tietuku.com/cfbaa7a4d5061b3a.png"></p>
<p>接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的<code>contents</code>，然后设置每个图层的<code>contentsRect</code>来去掉我们不想显示的部分。</p>
<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;@interface ViewController ()&#10;@property (nonatomic, weak) IBOutlet UIView *coneView;&#10;@property (nonatomic, weak) IBOutlet UIView *shipView;&#10;@property (nonatomic, weak) IBOutlet UIView *iglooView;&#10;@property (nonatomic, weak) IBOutlet UIView *anchorView;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect &#65532;toLayer:(CALayer *)layer //set image&#10;&#123;&#10;  layer.contents = (__bridge id)image.CGImage;&#10;&#10;  //scale contents to fit&#10;  layer.contentsGravity = kCAGravityResizeAspect;&#10;&#10;  //set contentsRect&#10;  layer.contentsRect = rect;&#10;&#125;&#10;&#10;- (void)viewDidLoad &#10;&#123;&#10;  [super viewDidLoad]; //load sprite sheet&#10;  UIImage *image = [UIImage imageNamed:@&#34;Sprites.png&#34;];&#10;  //set igloo sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];&#10;  //set cone sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];&#10;  //set anchor sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];&#10;  //set spaceship sprite&#10;  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/cfbaa7a4d5061b3a.png"></p>
<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。</p>
<p>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置<code>contentsRect</code>，这样开发者就不用手动写代码来摆放位置了。</p>
<p>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites" target="_blank" rel="external">https://github.com/nicklockwood/LayerSprites</a>)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。</p>
<h2 id="contentsCenter">contentsCenter</h2><p>本章我们介绍的最后一个和内容有关的属性是<code>contentsCenter</code>，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。<code>contentsCenter</code>其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<p>默认情况下，<code>contentsCenter</code>是{0, 0, 1, 1}，这意味着如果大小（由<code>conttensGravity</code>决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了<code>contentsCenter</code>设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>
<p><img src="http://i1.tietuku.com/b3f2cc3480447a08.png"></p>
<p>图2.9 <code>contentsCenter</code>的例子</p>
<p>这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。</p>
<p><img src="http://i1.tietuku.com/36ceb25b30b0c7dd.png"></p>
<p>图2.10 同一图片使用不同的<code>contentsCenter</code></p>
<p>清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11</p>
<p>清单2.4 用<code>contentsCenter</code>设置可拉伸视图</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&#10;&#10;@property (nonatomic, weak) IBOutlet UIView *button1;&#10;@property (nonatomic, weak) IBOutlet UIView *button2;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)addStretchableImage:(UIImage *)image withContentCenter:(CGRect)rect toLayer:(CALayer *)layer&#10;&#123;  &#10;  //set image&#10;  layer.contents = (__bridge id)image.CGImage;&#10;&#10;  //set contentsCenter&#10;  layer.contentsCenter = rect;&#10;&#125;&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad]; //load button image&#10;  UIImage *image = [UIImage imageNamed:@&#34;Button.png&#34;];&#10;&#10;  //set button 1&#10;  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button1.layer];&#10;&#10;  //set button 2&#10;  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button2.layer];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/f4ac7ce4f38e0537.png"></p>
<p>图2.11 用Interface Builder 探测窗口控制<code>contentsCenter</code>属性</p>
<h2 id="Custome_Drawing">Custome Drawing</h2><p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
<p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</p>
<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code>协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（<code>delegate</code>属性被声明为id类型，所有的代理方法都是可选的）。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(void)displayLayer:(CALayerCALayer *)layer;</span><br></pre></td></tr></table></figure>
<p>趁着这个机会，如果代理想直接设置<code>contents</code>属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现<code>-displayLayer:</code>方法，CALayer就会转而尝试调用下面这个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</span><br></pre></td></tr></table></figure>
<p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<p>让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是他的结果</p>
<p>清单2.5 实现CALayerDelegate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController&#10;- (void)viewDidLoad&#10;&#123;&#10;  [super viewDidLoad];&#10;  &#65532;&#10;  //create sublayer&#10;  CALayer *blueLayer = [CALayer layer];&#10;  blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);&#10;  blueLayer.backgroundColor = [UIColor blueColor].CGColor;&#10;&#10;  //set controller as layer delegate&#10;  blueLayer.delegate = self;&#10;&#10;  //ensure that layer backing image uses correct scale&#10;  blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view&#10;  [self.layerView.layer addSublayer:blueLayer];&#10;&#10;  //force layer to redraw&#10;  [blueLayer display];&#10;&#125;&#10;&#10;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#10;&#123;&#10;  //draw a thick red circle&#10;  CGContextSetLineWidth(ctx, 10.0f); &#10;  CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);&#10;  CGContextStrokeEllipseInRect(ctx, layer.bounds);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><img src="http://i1.tietuku.com/1bc64ecb7d221235.png"></p>
<p>图2.12 实现CALayerDelegate来绘制图层</p>
<p>注意一下一些有趣的事情：</p>
<ul>
<li>我们在blueLayer上显式地调用了<code>-display</code>。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用<code>masksToBounds</code>属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<p>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个<code>-displayLayer:</code>的实现，那所有的问题就都没了。</p>
<p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>
<h2 id="总结">总结</h2><p>本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。</p>
<p>在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察他们是如何放置和改变相互的尺寸的。</p>
<p><strong>来源网址:[<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques](</a></strong>来源网址:<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__" target="_blank" rel="external">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques__)__</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="page/6/index.html" data-title="undefined" data-url="undefined"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"guiqingblog"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->




<nav id="pagination">
  
    <a href="/page/5/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/7/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/categories/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/categories/Git/">Git</a><small>1</small></li>
  
    <li><a href="/categories/ReactiveCocoa/">ReactiveCocoa</a><small>2</small></li>
  
    <li><a href="/categories/Swift/">Swift</a><small>1</small></li>
  
    <li><a href="/categories/Swift进阶/">Swift进阶</a><small>4</small></li>
  
    <li><a href="/categories/iOS-Tips/">iOS Tips</a><small>14</small></li>
  
    <li><a href="/categories/主页维护记录/">主页维护记录</a><small>4</small></li>
  
    <li><a href="/categories/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/categories/开发环境相关/">开发环境相关</a><small>5</small></li>
  
    <li><a href="/categories/悟/">悟</a><small>1</small></li>
  
    <li><a href="/categories/知识技巧总结/">知识技巧总结</a><small>1</small></li>
  
    <li><a href="/categories/算法专题/">算法专题</a><small>1</small></li>
  
    <li><a href="/categories/辅助编程技能/">辅助编程技能</a><small>7</small></li>
  
    <li><a href="/categories/重构、模式、架构/">重构、模式、架构</a><small>10</small></li>
  
    <li><a href="/categories/高效OC编程/">高效OC编程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/ClassyLiveLayout/">ClassyLiveLayout</a><small>1</small></li>
  
    <li><a href="/tags/Core-Aniamtion深入探讨/">Core Aniamtion深入探讨</a><small>15</small></li>
  
    <li><a href="/tags/Git-命令/">Git 命令</a><small>1</small></li>
  
    <li><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a><small>2</small></li>
  
    <li><a href="/tags/Swift/">Swift</a><small>1</small></li>
  
    <li><a href="/tags/Swift-进阶/">Swift 进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶/">Swift进阶</a><small>1</small></li>
  
    <li><a href="/tags/Swift进阶-variable-with-a-setter-must-also-have-a-getter/">Swift进阶 variable with a setter must also have a getter</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Tips/">iOS Tips</a><small>3</small></li>
  
    <li><a href="/tags/主页维护记录/">主页维护记录</a><small>2</small></li>
  
    <li><a href="/tags/利用Runtime实现自依赖按钮/">利用Runtime实现自依赖按钮</a><small>1</small></li>
  
    <li><a href="/tags/小脚本大智慧/">小脚本大智慧</a><small>1</small></li>
  
    <li><a href="/tags/开发环境相关/">开发环境相关</a><small>3</small></li>
  
    <li><a href="/tags/悟/">悟</a><small>1</small></li>
  
    <li><a href="/tags/正则表达式/">正则表达式</a><small>2</small></li>
  
    <li><a href="/tags/测试小样/">测试小样</a><small>1</small></li>
  
    <li><a href="/tags/算法专题-字符串/">算法专题 字符串</a><small>1</small></li>
  
    <li><a href="/tags/设计模式/">设计模式</a><small>1</small></li>
  
    <li><a href="/tags/辅助编程技能/">辅助编程技能</a><small>2</small></li>
  
    <li><a href="/tags/重构、模式、架构/">重构、模式、架构</a><small>5</small></li>
  
    <li><a href="/tags/问题解决和思考/">问题解决和思考</a><small>5</small></li>
  
    <li><a href="/tags/高效OC编程/">高效OC编程</a><small>4</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 桂庆
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>